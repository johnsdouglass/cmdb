// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: github.com/seizadi/cmdb/pkg/pb/cmdb.proto

// Generated with protoc-gen-gorm version: master
// Anticipating compatibility with atlas-app-toolkit version: master

/*
Package pb is a generated protocol buffer package.

It is generated from these files:
	github.com/seizadi/cmdb/pkg/pb/cmdb.proto

It has these top-level messages:
	VersionResponse
	Region
	CreateRegionRequest
	CreateRegionResponse
	ReadRegionRequest
	ReadRegionResponse
	UpdateRegionRequest
	UpdateRegionResponse
	DeleteRegionRequest
	DeleteRegionResponse
	ListRegionRequest
	ListRegionsResponse
	Container
	CreateContainerRequest
	CreateContainerResponse
	ReadContainerRequest
	ReadContainerResponse
	UpdateContainerRequest
	UpdateContainerResponse
	DeleteContainerRequest
	DeleteContainerResponse
	ListContainerRequest
	ListContainersResponse
	VersionTag
	CreateVersionTagRequest
	CreateVersionTagResponse
	ReadVersionTagRequest
	ReadVersionTagResponse
	UpdateVersionTagRequest
	UpdateVersionTagResponse
	DeleteVersionTagRequest
	DeleteVersionTagResponse
	ListVersionTagRequest
	ListVersionTagsResponse
	Secret
	CreateSecretRequest
	CreateSecretResponse
	ReadSecretRequest
	ReadSecretResponse
	UpdateSecretRequest
	UpdateSecretResponse
	DeleteSecretRequest
	DeleteSecretResponse
	ListSecretRequest
	ListSecretsResponse
	Vault
	CreateVaultRequest
	CreateVaultResponse
	ReadVaultRequest
	ReadVaultResponse
	UpdateVaultRequest
	UpdateVaultResponse
	DeleteVaultRequest
	DeleteVaultResponse
	ListVaultRequest
	ListVaultsResponse
*/
package pb

import context "context"
import errors "errors"

import auth1 "github.com/infobloxopen/atlas-app-toolkit/auth"
import field_mask1 "google.golang.org/genproto/protobuf/field_mask"
import gateway1 "github.com/infobloxopen/atlas-app-toolkit/gateway"
import gorm1 "github.com/jinzhu/gorm"
import gorm2 "github.com/infobloxopen/atlas-app-toolkit/gorm"
import query1 "github.com/infobloxopen/atlas-app-toolkit/query"
import resource1 "github.com/infobloxopen/atlas-app-toolkit/gorm/resource"

import fmt "fmt"
import math "math"
import _ "github.com/golang/protobuf/ptypes/empty"
import _ "google.golang.org/genproto/protobuf/field_mask"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import _ "github.com/lyft/protoc-gen-validate/validate"
import _ "github.com/grpc-ecosystem/grpc-gateway/protoc-gen-swagger/options"
import _ "github.com/infobloxopen/atlas-app-toolkit/query"
import _ "github.com/infobloxopen/atlas-app-toolkit/rpc/resource"
import _ "github.com/infobloxopen/protoc-gen-atlas-query-validate/options"
import _ "github.com/infobloxopen/protoc-gen-atlas-validate/options"

// Reference imports to suppress errors if they are not otherwise used.
var _ = fmt.Errorf
var _ = math.Inf

type RegionORM struct {
	AccountID   string
	Description string
	Id          int64 `gorm:"type:serial;primary_key"`
	Name        string
}

// TableName overrides the default tablename generated by GORM
func (RegionORM) TableName() string {
	return "regions"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Region) ToORM(ctx context.Context) (RegionORM, error) {
	to := RegionORM{}
	var err error
	if prehook, ok := interface{}(m).(RegionWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.DecodeInt64(&Region{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Description = m.Description
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(RegionWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *RegionORM) ToPB(ctx context.Context) (Region, error) {
	to := Region{}
	var err error
	if prehook, ok := interface{}(m).(RegionWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&Region{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Description = m.Description
	if posthook, ok := interface{}(m).(RegionWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Region the arg will be the target, the caller the one being converted from

// RegionBeforeToORM called before default ToORM code
type RegionWithBeforeToORM interface {
	BeforeToORM(context.Context, *RegionORM) error
}

// RegionAfterToORM called after default ToORM code
type RegionWithAfterToORM interface {
	AfterToORM(context.Context, *RegionORM) error
}

// RegionBeforeToPB called before default ToPB code
type RegionWithBeforeToPB interface {
	BeforeToPB(context.Context, *Region) error
}

// RegionAfterToPB called after default ToPB code
type RegionWithAfterToPB interface {
	AfterToPB(context.Context, *Region) error
}

type ContainerORM struct {
	AccountID       string
	ContainerName   string
	Description     string
	Digest          string
	Id              int64 `gorm:"type:serial;primary_key"`
	ImagePullPolicy string
	ImageRepo       string
	ImageTag        string
	Name            string
}

// TableName overrides the default tablename generated by GORM
func (ContainerORM) TableName() string {
	return "containers"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Container) ToORM(ctx context.Context) (ContainerORM, error) {
	to := ContainerORM{}
	var err error
	if prehook, ok := interface{}(m).(ContainerWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.DecodeInt64(&Container{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Description = m.Description
	to.ContainerName = m.ContainerName
	to.ImageRepo = m.ImageRepo
	to.ImageTag = m.ImageTag
	to.ImagePullPolicy = m.ImagePullPolicy
	to.Digest = m.Digest
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(ContainerWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ContainerORM) ToPB(ctx context.Context) (Container, error) {
	to := Container{}
	var err error
	if prehook, ok := interface{}(m).(ContainerWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&Container{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Description = m.Description
	to.ContainerName = m.ContainerName
	to.ImageRepo = m.ImageRepo
	to.ImageTag = m.ImageTag
	to.ImagePullPolicy = m.ImagePullPolicy
	to.Digest = m.Digest
	if posthook, ok := interface{}(m).(ContainerWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Container the arg will be the target, the caller the one being converted from

// ContainerBeforeToORM called before default ToORM code
type ContainerWithBeforeToORM interface {
	BeforeToORM(context.Context, *ContainerORM) error
}

// ContainerAfterToORM called after default ToORM code
type ContainerWithAfterToORM interface {
	AfterToORM(context.Context, *ContainerORM) error
}

// ContainerBeforeToPB called before default ToPB code
type ContainerWithBeforeToPB interface {
	BeforeToPB(context.Context, *Container) error
}

// ContainerAfterToPB called after default ToPB code
type ContainerWithAfterToPB interface {
	AfterToPB(context.Context, *Container) error
}

type VersionTagORM struct {
	AccountID   string
	Commit      string
	Description string
	Id          int64 `gorm:"type:serial;primary_key"`
	Name        string
	Repo        string
	Version     string
}

// TableName overrides the default tablename generated by GORM
func (VersionTagORM) TableName() string {
	return "version_tags"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *VersionTag) ToORM(ctx context.Context) (VersionTagORM, error) {
	to := VersionTagORM{}
	var err error
	if prehook, ok := interface{}(m).(VersionTagWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.DecodeInt64(&VersionTag{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Description = m.Description
	to.Version = m.Version
	to.Repo = m.Repo
	to.Commit = m.Commit
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(VersionTagWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *VersionTagORM) ToPB(ctx context.Context) (VersionTag, error) {
	to := VersionTag{}
	var err error
	if prehook, ok := interface{}(m).(VersionTagWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&VersionTag{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Description = m.Description
	to.Version = m.Version
	to.Repo = m.Repo
	to.Commit = m.Commit
	if posthook, ok := interface{}(m).(VersionTagWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type VersionTag the arg will be the target, the caller the one being converted from

// VersionTagBeforeToORM called before default ToORM code
type VersionTagWithBeforeToORM interface {
	BeforeToORM(context.Context, *VersionTagORM) error
}

// VersionTagAfterToORM called after default ToORM code
type VersionTagWithAfterToORM interface {
	AfterToORM(context.Context, *VersionTagORM) error
}

// VersionTagBeforeToPB called before default ToPB code
type VersionTagWithBeforeToPB interface {
	BeforeToPB(context.Context, *VersionTag) error
}

// VersionTagAfterToPB called after default ToPB code
type VersionTagWithAfterToPB interface {
	AfterToPB(context.Context, *VersionTag) error
}

type SecretORM struct {
	AccountID   string
	Description string
	Id          int64 `gorm:"type:serial;primary_key"`
	Key         string
	Name        string
	Type        string
	VaultId     *int64
}

// TableName overrides the default tablename generated by GORM
func (SecretORM) TableName() string {
	return "secrets"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Secret) ToORM(ctx context.Context) (SecretORM, error) {
	to := SecretORM{}
	var err error
	if prehook, ok := interface{}(m).(SecretWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.DecodeInt64(&Secret{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Description = m.Description
	to.Type = m.Type
	to.Key = m.Key
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(SecretWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *SecretORM) ToPB(ctx context.Context) (Secret, error) {
	to := Secret{}
	var err error
	if prehook, ok := interface{}(m).(SecretWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&Secret{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Description = m.Description
	to.Type = m.Type
	to.Key = m.Key
	if posthook, ok := interface{}(m).(SecretWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Secret the arg will be the target, the caller the one being converted from

// SecretBeforeToORM called before default ToORM code
type SecretWithBeforeToORM interface {
	BeforeToORM(context.Context, *SecretORM) error
}

// SecretAfterToORM called after default ToORM code
type SecretWithAfterToORM interface {
	AfterToORM(context.Context, *SecretORM) error
}

// SecretBeforeToPB called before default ToPB code
type SecretWithBeforeToPB interface {
	BeforeToPB(context.Context, *Secret) error
}

// SecretAfterToPB called after default ToPB code
type SecretWithAfterToPB interface {
	AfterToPB(context.Context, *Secret) error
}

type VaultORM struct {
	AccountID   string
	Description string
	Id          int64 `gorm:"type:serial;primary_key"`
	Name        string
	Path        string
	Secrets     []*SecretORM `gorm:"foreignkey:VaultId;association_foreignkey:Id"`
}

// TableName overrides the default tablename generated by GORM
func (VaultORM) TableName() string {
	return "vaults"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Vault) ToORM(ctx context.Context) (VaultORM, error) {
	to := VaultORM{}
	var err error
	if prehook, ok := interface{}(m).(VaultWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.DecodeInt64(&Vault{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Description = m.Description
	to.Path = m.Path
	for _, v := range m.Secrets {
		if v != nil {
			if tempSecrets, cErr := v.ToORM(ctx); cErr == nil {
				to.Secrets = append(to.Secrets, &tempSecrets)
			} else {
				return to, cErr
			}
		} else {
			to.Secrets = append(to.Secrets, nil)
		}
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(VaultWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *VaultORM) ToPB(ctx context.Context) (Vault, error) {
	to := Vault{}
	var err error
	if prehook, ok := interface{}(m).(VaultWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&Vault{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Description = m.Description
	to.Path = m.Path
	for _, v := range m.Secrets {
		if v != nil {
			if tempSecrets, cErr := v.ToPB(ctx); cErr == nil {
				to.Secrets = append(to.Secrets, &tempSecrets)
			} else {
				return to, cErr
			}
		} else {
			to.Secrets = append(to.Secrets, nil)
		}
	}
	if posthook, ok := interface{}(m).(VaultWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Vault the arg will be the target, the caller the one being converted from

// VaultBeforeToORM called before default ToORM code
type VaultWithBeforeToORM interface {
	BeforeToORM(context.Context, *VaultORM) error
}

// VaultAfterToORM called after default ToORM code
type VaultWithAfterToORM interface {
	AfterToORM(context.Context, *VaultORM) error
}

// VaultBeforeToPB called before default ToPB code
type VaultWithBeforeToPB interface {
	BeforeToPB(context.Context, *Vault) error
}

// VaultAfterToPB called after default ToPB code
type VaultWithAfterToPB interface {
	AfterToPB(context.Context, *Vault) error
}

// DefaultCreateRegion executes a basic gorm create call
func DefaultCreateRegion(ctx context.Context, in *Region, db *gorm1.DB) (*Region, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultCreateRegion")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(RegionORMWithBeforeCreate); ok {
		if db, err = hook.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(RegionORMWithAfterCreate); ok {
		if err = hook.AfterCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type RegionORMWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type RegionORMWithAfterCreate interface {
	AfterCreate(context.Context, *gorm1.DB) error
}

// DefaultReadRegion executes a basic gorm read call
func DefaultReadRegion(ctx context.Context, in *Region, db *gorm1.DB, fs *query1.FieldSelection) (*Region, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultReadRegion")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.New("DefaultReadRegion requires a non-zero primary key")
	}
	if hook, ok := interface{}(&ormObj).(RegionORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, fs, &RegionORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(RegionORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	ormResponse := RegionORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(RegionORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type RegionORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type RegionORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type RegionORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) error
}

func DefaultDeleteRegion(ctx context.Context, in *Region, db *gorm1.DB) error {
	if in == nil {
		return errors.New("Nil argument to DefaultDeleteRegion")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.New("A non-zero ID value is required for a delete call")
	}
	if hook, ok := interface{}(&ormObj).(RegionORMWithBeforeDelete); ok {
		if db, err = hook.BeforeDelete(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&RegionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(RegionORMWithAfterDelete); ok {
		err = hook.AfterDelete(ctx, db)
	}
	return err
}

type RegionORMWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type RegionORMWithAfterDelete interface {
	AfterDelete(context.Context, *gorm1.DB) error
}

// DefaultStrictUpdateRegion clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateRegion(ctx context.Context, in *Region, db *gorm1.DB) (*Region, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateRegion")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	var count int64
	lockedRow := &RegionORM{}
	count = db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow).RowsAffected
	if hook, ok := interface{}(&ormObj).(RegionORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(RegionORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(RegionORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	if count == 0 {
		err = gateway1.SetCreated(ctx, "")
	}
	return &pbResponse, err
}

type RegionORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type RegionORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type RegionORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchRegion executes a basic gorm update call with patch behavior
func DefaultPatchRegion(ctx context.Context, in *Region, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Region, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultPatchRegion")
	}
	var pbObj Region
	var err error
	if hook, ok := interface{}(&pbObj).(RegionWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadRegion(ctx, &Region{Id: in.GetId()}, db, nil)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(RegionWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskRegion(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(RegionWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateRegion(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(RegionWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type RegionWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Region, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type RegionWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Region, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type RegionWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Region, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type RegionWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Region, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultApplyFieldMaskRegion patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskRegion(ctx context.Context, patchee *Region, patcher *Region, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Region, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.New("Patchee inputs to DefaultApplyFieldMaskRegion must be non-nil")
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListRegion executes a gorm list call
func DefaultListRegion(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*Region, error) {
	in := Region{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(RegionORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &RegionORM{}, &Region{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(RegionORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []RegionORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(RegionORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Region{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type RegionORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type RegionORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type RegionORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]RegionORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateContainer executes a basic gorm create call
func DefaultCreateContainer(ctx context.Context, in *Container, db *gorm1.DB) (*Container, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultCreateContainer")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ContainerORMWithBeforeCreate); ok {
		if db, err = hook.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ContainerORMWithAfterCreate); ok {
		if err = hook.AfterCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ContainerORMWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ContainerORMWithAfterCreate interface {
	AfterCreate(context.Context, *gorm1.DB) error
}

// DefaultReadContainer executes a basic gorm read call
func DefaultReadContainer(ctx context.Context, in *Container, db *gorm1.DB, fs *query1.FieldSelection) (*Container, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultReadContainer")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.New("DefaultReadContainer requires a non-zero primary key")
	}
	if hook, ok := interface{}(&ormObj).(ContainerORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, fs, &ContainerORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ContainerORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	ormResponse := ContainerORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ContainerORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ContainerORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type ContainerORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type ContainerORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) error
}

func DefaultDeleteContainer(ctx context.Context, in *Container, db *gorm1.DB) error {
	if in == nil {
		return errors.New("Nil argument to DefaultDeleteContainer")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.New("A non-zero ID value is required for a delete call")
	}
	if hook, ok := interface{}(&ormObj).(ContainerORMWithBeforeDelete); ok {
		if db, err = hook.BeforeDelete(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ContainerORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ContainerORMWithAfterDelete); ok {
		err = hook.AfterDelete(ctx, db)
	}
	return err
}

type ContainerORMWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ContainerORMWithAfterDelete interface {
	AfterDelete(context.Context, *gorm1.DB) error
}

// DefaultStrictUpdateContainer clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateContainer(ctx context.Context, in *Container, db *gorm1.DB) (*Container, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateContainer")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	var count int64
	lockedRow := &ContainerORM{}
	count = db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow).RowsAffected
	if hook, ok := interface{}(&ormObj).(ContainerORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ContainerORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ContainerORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	if count == 0 {
		err = gateway1.SetCreated(ctx, "")
	}
	return &pbResponse, err
}

type ContainerORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ContainerORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ContainerORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchContainer executes a basic gorm update call with patch behavior
func DefaultPatchContainer(ctx context.Context, in *Container, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Container, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultPatchContainer")
	}
	var pbObj Container
	var err error
	if hook, ok := interface{}(&pbObj).(ContainerWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadContainer(ctx, &Container{Id: in.GetId()}, db, nil)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ContainerWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskContainer(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ContainerWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateContainer(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ContainerWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ContainerWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Container, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ContainerWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Container, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ContainerWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Container, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ContainerWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Container, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultApplyFieldMaskContainer patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskContainer(ctx context.Context, patchee *Container, patcher *Container, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Container, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.New("Patchee inputs to DefaultApplyFieldMaskContainer must be non-nil")
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"ContainerName" {
			patchee.ContainerName = patcher.ContainerName
			continue
		}
		if f == prefix+"ImageRepo" {
			patchee.ImageRepo = patcher.ImageRepo
			continue
		}
		if f == prefix+"ImageTag" {
			patchee.ImageTag = patcher.ImageTag
			continue
		}
		if f == prefix+"ImagePullPolicy" {
			patchee.ImagePullPolicy = patcher.ImagePullPolicy
			continue
		}
		if f == prefix+"Digest" {
			patchee.Digest = patcher.Digest
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListContainer executes a gorm list call
func DefaultListContainer(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*Container, error) {
	in := Container{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ContainerORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &ContainerORM{}, &Container{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ContainerORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ContainerORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ContainerORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Container{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ContainerORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ContainerORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ContainerORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]ContainerORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateVersionTag executes a basic gorm create call
func DefaultCreateVersionTag(ctx context.Context, in *VersionTag, db *gorm1.DB) (*VersionTag, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultCreateVersionTag")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VersionTagORMWithBeforeCreate); ok {
		if db, err = hook.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VersionTagORMWithAfterCreate); ok {
		if err = hook.AfterCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type VersionTagORMWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type VersionTagORMWithAfterCreate interface {
	AfterCreate(context.Context, *gorm1.DB) error
}

// DefaultReadVersionTag executes a basic gorm read call
func DefaultReadVersionTag(ctx context.Context, in *VersionTag, db *gorm1.DB, fs *query1.FieldSelection) (*VersionTag, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultReadVersionTag")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.New("DefaultReadVersionTag requires a non-zero primary key")
	}
	if hook, ok := interface{}(&ormObj).(VersionTagORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, fs, &VersionTagORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VersionTagORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	ormResponse := VersionTagORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(VersionTagORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type VersionTagORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type VersionTagORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type VersionTagORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) error
}

func DefaultDeleteVersionTag(ctx context.Context, in *VersionTag, db *gorm1.DB) error {
	if in == nil {
		return errors.New("Nil argument to DefaultDeleteVersionTag")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.New("A non-zero ID value is required for a delete call")
	}
	if hook, ok := interface{}(&ormObj).(VersionTagORMWithBeforeDelete); ok {
		if db, err = hook.BeforeDelete(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&VersionTagORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(VersionTagORMWithAfterDelete); ok {
		err = hook.AfterDelete(ctx, db)
	}
	return err
}

type VersionTagORMWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type VersionTagORMWithAfterDelete interface {
	AfterDelete(context.Context, *gorm1.DB) error
}

// DefaultStrictUpdateVersionTag clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateVersionTag(ctx context.Context, in *VersionTag, db *gorm1.DB) (*VersionTag, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateVersionTag")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	var count int64
	lockedRow := &VersionTagORM{}
	count = db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow).RowsAffected
	if hook, ok := interface{}(&ormObj).(VersionTagORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(VersionTagORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VersionTagORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	if count == 0 {
		err = gateway1.SetCreated(ctx, "")
	}
	return &pbResponse, err
}

type VersionTagORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type VersionTagORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type VersionTagORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchVersionTag executes a basic gorm update call with patch behavior
func DefaultPatchVersionTag(ctx context.Context, in *VersionTag, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*VersionTag, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultPatchVersionTag")
	}
	var pbObj VersionTag
	var err error
	if hook, ok := interface{}(&pbObj).(VersionTagWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadVersionTag(ctx, &VersionTag{Id: in.GetId()}, db, nil)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(VersionTagWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskVersionTag(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(VersionTagWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateVersionTag(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(VersionTagWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type VersionTagWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *VersionTag, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type VersionTagWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *VersionTag, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type VersionTagWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *VersionTag, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type VersionTagWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *VersionTag, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultApplyFieldMaskVersionTag patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskVersionTag(ctx context.Context, patchee *VersionTag, patcher *VersionTag, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*VersionTag, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.New("Patchee inputs to DefaultApplyFieldMaskVersionTag must be non-nil")
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"Version" {
			patchee.Version = patcher.Version
			continue
		}
		if f == prefix+"Repo" {
			patchee.Repo = patcher.Repo
			continue
		}
		if f == prefix+"Commit" {
			patchee.Commit = patcher.Commit
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListVersionTag executes a gorm list call
func DefaultListVersionTag(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*VersionTag, error) {
	in := VersionTag{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VersionTagORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &VersionTagORM{}, &VersionTag{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VersionTagORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []VersionTagORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VersionTagORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*VersionTag{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type VersionTagORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type VersionTagORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type VersionTagORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]VersionTagORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateSecret executes a basic gorm create call
func DefaultCreateSecret(ctx context.Context, in *Secret, db *gorm1.DB) (*Secret, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultCreateSecret")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SecretORMWithBeforeCreate); ok {
		if db, err = hook.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SecretORMWithAfterCreate); ok {
		if err = hook.AfterCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type SecretORMWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type SecretORMWithAfterCreate interface {
	AfterCreate(context.Context, *gorm1.DB) error
}

// DefaultReadSecret executes a basic gorm read call
func DefaultReadSecret(ctx context.Context, in *Secret, db *gorm1.DB, fs *query1.FieldSelection) (*Secret, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultReadSecret")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.New("DefaultReadSecret requires a non-zero primary key")
	}
	if hook, ok := interface{}(&ormObj).(SecretORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, fs, &SecretORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SecretORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	ormResponse := SecretORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(SecretORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type SecretORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type SecretORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type SecretORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) error
}

func DefaultDeleteSecret(ctx context.Context, in *Secret, db *gorm1.DB) error {
	if in == nil {
		return errors.New("Nil argument to DefaultDeleteSecret")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.New("A non-zero ID value is required for a delete call")
	}
	if hook, ok := interface{}(&ormObj).(SecretORMWithBeforeDelete); ok {
		if db, err = hook.BeforeDelete(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&SecretORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(SecretORMWithAfterDelete); ok {
		err = hook.AfterDelete(ctx, db)
	}
	return err
}

type SecretORMWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type SecretORMWithAfterDelete interface {
	AfterDelete(context.Context, *gorm1.DB) error
}

// DefaultStrictUpdateSecret clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateSecret(ctx context.Context, in *Secret, db *gorm1.DB) (*Secret, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateSecret")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	var count int64
	lockedRow := &SecretORM{}
	count = db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow).RowsAffected
	if hook, ok := interface{}(&ormObj).(SecretORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(SecretORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SecretORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	if count == 0 {
		err = gateway1.SetCreated(ctx, "")
	}
	return &pbResponse, err
}

type SecretORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type SecretORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type SecretORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchSecret executes a basic gorm update call with patch behavior
func DefaultPatchSecret(ctx context.Context, in *Secret, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Secret, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultPatchSecret")
	}
	var pbObj Secret
	var err error
	if hook, ok := interface{}(&pbObj).(SecretWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadSecret(ctx, &Secret{Id: in.GetId()}, db, nil)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(SecretWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskSecret(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(SecretWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateSecret(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(SecretWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type SecretWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Secret, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type SecretWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Secret, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type SecretWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Secret, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type SecretWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Secret, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultApplyFieldMaskSecret patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskSecret(ctx context.Context, patchee *Secret, patcher *Secret, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Secret, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.New("Patchee inputs to DefaultApplyFieldMaskSecret must be non-nil")
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"Type" {
			patchee.Type = patcher.Type
			continue
		}
		if f == prefix+"Key" {
			patchee.Key = patcher.Key
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListSecret executes a gorm list call
func DefaultListSecret(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*Secret, error) {
	in := Secret{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SecretORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &SecretORM{}, &Secret{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SecretORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []SecretORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SecretORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Secret{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type SecretORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type SecretORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type SecretORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]SecretORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateVault executes a basic gorm create call
func DefaultCreateVault(ctx context.Context, in *Vault, db *gorm1.DB) (*Vault, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultCreateVault")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VaultORMWithBeforeCreate); ok {
		if db, err = hook.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VaultORMWithAfterCreate); ok {
		if err = hook.AfterCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type VaultORMWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type VaultORMWithAfterCreate interface {
	AfterCreate(context.Context, *gorm1.DB) error
}

// DefaultReadVault executes a basic gorm read call
func DefaultReadVault(ctx context.Context, in *Vault, db *gorm1.DB, fs *query1.FieldSelection) (*Vault, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultReadVault")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.New("DefaultReadVault requires a non-zero primary key")
	}
	if hook, ok := interface{}(&ormObj).(VaultORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, fs, &VaultORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VaultORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	ormResponse := VaultORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(VaultORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type VaultORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type VaultORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type VaultORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) error
}

func DefaultDeleteVault(ctx context.Context, in *Vault, db *gorm1.DB) error {
	if in == nil {
		return errors.New("Nil argument to DefaultDeleteVault")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.New("A non-zero ID value is required for a delete call")
	}
	if hook, ok := interface{}(&ormObj).(VaultORMWithBeforeDelete); ok {
		if db, err = hook.BeforeDelete(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&VaultORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(VaultORMWithAfterDelete); ok {
		err = hook.AfterDelete(ctx, db)
	}
	return err
}

type VaultORMWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type VaultORMWithAfterDelete interface {
	AfterDelete(context.Context, *gorm1.DB) error
}

// DefaultStrictUpdateVault clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateVault(ctx context.Context, in *Vault, db *gorm1.DB) (*Vault, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateVault")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	var count int64
	lockedRow := &VaultORM{}
	count = db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow).RowsAffected
	if hook, ok := interface{}(&ormObj).(VaultORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterSecrets := SecretORM{}
	if ormObj.Id == 0 {
		return nil, errors.New("Can't do overwriting update with no Id value for VaultORM")
	}
	filterSecrets.VaultId = new(int64)
	*filterSecrets.VaultId = ormObj.Id
	if err = db.Where(filterSecrets).Delete(SecretORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VaultORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VaultORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	if count == 0 {
		err = gateway1.SetCreated(ctx, "")
	}
	return &pbResponse, err
}

type VaultORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type VaultORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type VaultORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchVault executes a basic gorm update call with patch behavior
func DefaultPatchVault(ctx context.Context, in *Vault, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Vault, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultPatchVault")
	}
	var pbObj Vault
	var err error
	if hook, ok := interface{}(&pbObj).(VaultWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadVault(ctx, &Vault{Id: in.GetId()}, db, nil)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(VaultWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskVault(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(VaultWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateVault(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(VaultWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type VaultWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Vault, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type VaultWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Vault, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type VaultWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Vault, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type VaultWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Vault, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultApplyFieldMaskVault patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskVault(ctx context.Context, patchee *Vault, patcher *Vault, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Vault, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.New("Patchee inputs to DefaultApplyFieldMaskVault must be non-nil")
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"Path" {
			patchee.Path = patcher.Path
			continue
		}
		if f == prefix+"Secrets" {
			patchee.Secrets = patcher.Secrets
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListVault executes a gorm list call
func DefaultListVault(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*Vault, error) {
	in := Vault{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VaultORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &VaultORM{}, &Vault{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VaultORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []VaultORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VaultORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Vault{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type VaultORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type VaultORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type VaultORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]VaultORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}
type RegionsDefaultServer struct {
}

// Create ...
func (m *RegionsDefaultServer) Create(ctx context.Context, in *CreateRegionRequest) (*CreateRegionResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors.New("Database Transaction For Request Missing")
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(RegionsRegionWithBeforeCreate); ok {
		var err error
		if db, err = custom.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateRegion(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreateRegionResponse{Result: res}
	if custom, ok := interface{}(in).(RegionsRegionWithAfterCreate); ok {
		var err error
		if err = custom.AfterCreate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// RegionsRegionWithBeforeCreate called before DefaultCreateRegion in the default Create handler
type RegionsRegionWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// RegionsRegionWithAfterCreate called before DefaultCreateRegion in the default Create handler
type RegionsRegionWithAfterCreate interface {
	AfterCreate(context.Context, *CreateRegionResponse, *gorm1.DB) error
}

// Read ...
func (m *RegionsDefaultServer) Read(ctx context.Context, in *ReadRegionRequest) (*ReadRegionResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors.New("Database Transaction For Request Missing")
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(RegionsRegionWithBeforeRead); ok {
		var err error
		if db, err = custom.BeforeRead(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadRegion(ctx, &Region{Id: in.GetId()}, db, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ReadRegionResponse{Result: res}
	if custom, ok := interface{}(in).(RegionsRegionWithAfterRead); ok {
		var err error
		if err = custom.AfterRead(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// RegionsRegionWithBeforeRead called before DefaultReadRegion in the default Read handler
type RegionsRegionWithBeforeRead interface {
	BeforeRead(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// RegionsRegionWithAfterRead called before DefaultReadRegion in the default Read handler
type RegionsRegionWithAfterRead interface {
	AfterRead(context.Context, *ReadRegionResponse, *gorm1.DB) error
}

// Update ...
func (m *RegionsDefaultServer) Update(ctx context.Context, in *UpdateRegionRequest) (*UpdateRegionResponse, error) {
	var err error
	var res *Region
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors.New("Database Transaction For Request Missing")
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(RegionsRegionWithBeforeUpdate); ok {
		var err error
		if db, err = custom.BeforeUpdate(ctx, db); err != nil {
			return nil, err
		}
	}
	if in.GetFields() == nil {
		res, err = DefaultStrictUpdateRegion(ctx, in.GetPayload(), db)
	} else {
		res, err = DefaultPatchRegion(ctx, in.GetPayload(), in.GetFields(), db)
	}
	if err != nil {
		return nil, err
	}
	out := &UpdateRegionResponse{Result: res}
	if custom, ok := interface{}(in).(RegionsRegionWithAfterUpdate); ok {
		var err error
		if err = custom.AfterUpdate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// RegionsRegionWithBeforeUpdate called before DefaultUpdateRegion in the default Update handler
type RegionsRegionWithBeforeUpdate interface {
	BeforeUpdate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// RegionsRegionWithAfterUpdate called before DefaultUpdateRegion in the default Update handler
type RegionsRegionWithAfterUpdate interface {
	AfterUpdate(context.Context, *UpdateRegionResponse, *gorm1.DB) error
}

// Delete ...
func (m *RegionsDefaultServer) Delete(ctx context.Context, in *DeleteRegionRequest) (*DeleteRegionResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors.New("Database Transaction For Request Missing")
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(RegionsRegionWithBeforeDelete); ok {
		var err error
		if db, err = custom.BeforeDelete(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteRegion(ctx, &Region{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &DeleteRegionResponse{}
	if custom, ok := interface{}(in).(RegionsRegionWithAfterDelete); ok {
		var err error
		if err = custom.AfterDelete(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// RegionsRegionWithBeforeDelete called before DefaultDeleteRegion in the default Delete handler
type RegionsRegionWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// RegionsRegionWithAfterDelete called before DefaultDeleteRegion in the default Delete handler
type RegionsRegionWithAfterDelete interface {
	AfterDelete(context.Context, *DeleteRegionResponse, *gorm1.DB) error
}

// List ...
func (m *RegionsDefaultServer) List(ctx context.Context, in *ListRegionRequest) (*ListRegionsResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors.New("Database Transaction For Request Missing")
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(RegionsRegionWithBeforeList); ok {
		var err error
		if db, err = custom.BeforeList(ctx, db); err != nil {
			return nil, err
		}
	}
	pagedRequest := false
	if in.GetPaging().GetLimit() >= 1 {
		in.Paging.Limit++
		pagedRequest = true
	}
	res, err := DefaultListRegion(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	var resPaging *query1.PageInfo
	if pagedRequest {
		var offset int32
		var size int32 = int32(len(res))
		if size == in.GetPaging().GetLimit() {
			size--
			res = res[:size]
			offset = in.GetPaging().GetOffset() + size
		}
		resPaging = &query1.PageInfo{Offset: offset}
	}
	out := &ListRegionsResponse{Results: res, Page: resPaging}
	if custom, ok := interface{}(in).(RegionsRegionWithAfterList); ok {
		var err error
		if err = custom.AfterList(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// RegionsRegionWithBeforeList called before DefaultListRegion in the default List handler
type RegionsRegionWithBeforeList interface {
	BeforeList(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// RegionsRegionWithAfterList called before DefaultListRegion in the default List handler
type RegionsRegionWithAfterList interface {
	AfterList(context.Context, *ListRegionsResponse, *gorm1.DB) error
}
type ContainersDefaultServer struct {
}

// Create ...
func (m *ContainersDefaultServer) Create(ctx context.Context, in *CreateContainerRequest) (*CreateContainerResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors.New("Database Transaction For Request Missing")
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(ContainersContainerWithBeforeCreate); ok {
		var err error
		if db, err = custom.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateContainer(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreateContainerResponse{Result: res}
	if custom, ok := interface{}(in).(ContainersContainerWithAfterCreate); ok {
		var err error
		if err = custom.AfterCreate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ContainersContainerWithBeforeCreate called before DefaultCreateContainer in the default Create handler
type ContainersContainerWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ContainersContainerWithAfterCreate called before DefaultCreateContainer in the default Create handler
type ContainersContainerWithAfterCreate interface {
	AfterCreate(context.Context, *CreateContainerResponse, *gorm1.DB) error
}

// Read ...
func (m *ContainersDefaultServer) Read(ctx context.Context, in *ReadContainerRequest) (*ReadContainerResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors.New("Database Transaction For Request Missing")
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(ContainersContainerWithBeforeRead); ok {
		var err error
		if db, err = custom.BeforeRead(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadContainer(ctx, &Container{Id: in.GetId()}, db, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ReadContainerResponse{Result: res}
	if custom, ok := interface{}(in).(ContainersContainerWithAfterRead); ok {
		var err error
		if err = custom.AfterRead(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ContainersContainerWithBeforeRead called before DefaultReadContainer in the default Read handler
type ContainersContainerWithBeforeRead interface {
	BeforeRead(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ContainersContainerWithAfterRead called before DefaultReadContainer in the default Read handler
type ContainersContainerWithAfterRead interface {
	AfterRead(context.Context, *ReadContainerResponse, *gorm1.DB) error
}

// Update ...
func (m *ContainersDefaultServer) Update(ctx context.Context, in *UpdateContainerRequest) (*UpdateContainerResponse, error) {
	var err error
	var res *Container
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors.New("Database Transaction For Request Missing")
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(ContainersContainerWithBeforeUpdate); ok {
		var err error
		if db, err = custom.BeforeUpdate(ctx, db); err != nil {
			return nil, err
		}
	}
	if in.GetFields() == nil {
		res, err = DefaultStrictUpdateContainer(ctx, in.GetPayload(), db)
	} else {
		res, err = DefaultPatchContainer(ctx, in.GetPayload(), in.GetFields(), db)
	}
	if err != nil {
		return nil, err
	}
	out := &UpdateContainerResponse{Result: res}
	if custom, ok := interface{}(in).(ContainersContainerWithAfterUpdate); ok {
		var err error
		if err = custom.AfterUpdate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ContainersContainerWithBeforeUpdate called before DefaultUpdateContainer in the default Update handler
type ContainersContainerWithBeforeUpdate interface {
	BeforeUpdate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ContainersContainerWithAfterUpdate called before DefaultUpdateContainer in the default Update handler
type ContainersContainerWithAfterUpdate interface {
	AfterUpdate(context.Context, *UpdateContainerResponse, *gorm1.DB) error
}

// Delete ...
func (m *ContainersDefaultServer) Delete(ctx context.Context, in *DeleteContainerRequest) (*DeleteContainerResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors.New("Database Transaction For Request Missing")
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(ContainersContainerWithBeforeDelete); ok {
		var err error
		if db, err = custom.BeforeDelete(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteContainer(ctx, &Container{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &DeleteContainerResponse{}
	if custom, ok := interface{}(in).(ContainersContainerWithAfterDelete); ok {
		var err error
		if err = custom.AfterDelete(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ContainersContainerWithBeforeDelete called before DefaultDeleteContainer in the default Delete handler
type ContainersContainerWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ContainersContainerWithAfterDelete called before DefaultDeleteContainer in the default Delete handler
type ContainersContainerWithAfterDelete interface {
	AfterDelete(context.Context, *DeleteContainerResponse, *gorm1.DB) error
}

// List ...
func (m *ContainersDefaultServer) List(ctx context.Context, in *ListContainerRequest) (*ListContainersResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors.New("Database Transaction For Request Missing")
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(ContainersContainerWithBeforeList); ok {
		var err error
		if db, err = custom.BeforeList(ctx, db); err != nil {
			return nil, err
		}
	}
	pagedRequest := false
	if in.GetPaging().GetLimit() >= 1 {
		in.Paging.Limit++
		pagedRequest = true
	}
	res, err := DefaultListContainer(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	var resPaging *query1.PageInfo
	if pagedRequest {
		var offset int32
		var size int32 = int32(len(res))
		if size == in.GetPaging().GetLimit() {
			size--
			res = res[:size]
			offset = in.GetPaging().GetOffset() + size
		}
		resPaging = &query1.PageInfo{Offset: offset}
	}
	out := &ListContainersResponse{Results: res, Page: resPaging}
	if custom, ok := interface{}(in).(ContainersContainerWithAfterList); ok {
		var err error
		if err = custom.AfterList(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ContainersContainerWithBeforeList called before DefaultListContainer in the default List handler
type ContainersContainerWithBeforeList interface {
	BeforeList(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ContainersContainerWithAfterList called before DefaultListContainer in the default List handler
type ContainersContainerWithAfterList interface {
	AfterList(context.Context, *ListContainersResponse, *gorm1.DB) error
}
type VersionTagsDefaultServer struct {
}

// Create ...
func (m *VersionTagsDefaultServer) Create(ctx context.Context, in *CreateVersionTagRequest) (*CreateVersionTagResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors.New("Database Transaction For Request Missing")
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(VersionTagsVersionTagWithBeforeCreate); ok {
		var err error
		if db, err = custom.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateVersionTag(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreateVersionTagResponse{Result: res}
	if custom, ok := interface{}(in).(VersionTagsVersionTagWithAfterCreate); ok {
		var err error
		if err = custom.AfterCreate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// VersionTagsVersionTagWithBeforeCreate called before DefaultCreateVersionTag in the default Create handler
type VersionTagsVersionTagWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// VersionTagsVersionTagWithAfterCreate called before DefaultCreateVersionTag in the default Create handler
type VersionTagsVersionTagWithAfterCreate interface {
	AfterCreate(context.Context, *CreateVersionTagResponse, *gorm1.DB) error
}

// Read ...
func (m *VersionTagsDefaultServer) Read(ctx context.Context, in *ReadVersionTagRequest) (*ReadVersionTagResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors.New("Database Transaction For Request Missing")
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(VersionTagsVersionTagWithBeforeRead); ok {
		var err error
		if db, err = custom.BeforeRead(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadVersionTag(ctx, &VersionTag{Id: in.GetId()}, db, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ReadVersionTagResponse{Result: res}
	if custom, ok := interface{}(in).(VersionTagsVersionTagWithAfterRead); ok {
		var err error
		if err = custom.AfterRead(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// VersionTagsVersionTagWithBeforeRead called before DefaultReadVersionTag in the default Read handler
type VersionTagsVersionTagWithBeforeRead interface {
	BeforeRead(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// VersionTagsVersionTagWithAfterRead called before DefaultReadVersionTag in the default Read handler
type VersionTagsVersionTagWithAfterRead interface {
	AfterRead(context.Context, *ReadVersionTagResponse, *gorm1.DB) error
}

// Update ...
func (m *VersionTagsDefaultServer) Update(ctx context.Context, in *UpdateVersionTagRequest) (*UpdateVersionTagResponse, error) {
	var err error
	var res *VersionTag
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors.New("Database Transaction For Request Missing")
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(VersionTagsVersionTagWithBeforeUpdate); ok {
		var err error
		if db, err = custom.BeforeUpdate(ctx, db); err != nil {
			return nil, err
		}
	}
	if in.GetFields() == nil {
		res, err = DefaultStrictUpdateVersionTag(ctx, in.GetPayload(), db)
	} else {
		res, err = DefaultPatchVersionTag(ctx, in.GetPayload(), in.GetFields(), db)
	}
	if err != nil {
		return nil, err
	}
	out := &UpdateVersionTagResponse{Result: res}
	if custom, ok := interface{}(in).(VersionTagsVersionTagWithAfterUpdate); ok {
		var err error
		if err = custom.AfterUpdate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// VersionTagsVersionTagWithBeforeUpdate called before DefaultUpdateVersionTag in the default Update handler
type VersionTagsVersionTagWithBeforeUpdate interface {
	BeforeUpdate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// VersionTagsVersionTagWithAfterUpdate called before DefaultUpdateVersionTag in the default Update handler
type VersionTagsVersionTagWithAfterUpdate interface {
	AfterUpdate(context.Context, *UpdateVersionTagResponse, *gorm1.DB) error
}

// Delete ...
func (m *VersionTagsDefaultServer) Delete(ctx context.Context, in *DeleteVersionTagRequest) (*DeleteVersionTagResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors.New("Database Transaction For Request Missing")
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(VersionTagsVersionTagWithBeforeDelete); ok {
		var err error
		if db, err = custom.BeforeDelete(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteVersionTag(ctx, &VersionTag{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &DeleteVersionTagResponse{}
	if custom, ok := interface{}(in).(VersionTagsVersionTagWithAfterDelete); ok {
		var err error
		if err = custom.AfterDelete(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// VersionTagsVersionTagWithBeforeDelete called before DefaultDeleteVersionTag in the default Delete handler
type VersionTagsVersionTagWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// VersionTagsVersionTagWithAfterDelete called before DefaultDeleteVersionTag in the default Delete handler
type VersionTagsVersionTagWithAfterDelete interface {
	AfterDelete(context.Context, *DeleteVersionTagResponse, *gorm1.DB) error
}

// List ...
func (m *VersionTagsDefaultServer) List(ctx context.Context, in *ListVersionTagRequest) (*ListVersionTagsResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors.New("Database Transaction For Request Missing")
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(VersionTagsVersionTagWithBeforeList); ok {
		var err error
		if db, err = custom.BeforeList(ctx, db); err != nil {
			return nil, err
		}
	}
	pagedRequest := false
	if in.GetPaging().GetLimit() >= 1 {
		in.Paging.Limit++
		pagedRequest = true
	}
	res, err := DefaultListVersionTag(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	var resPaging *query1.PageInfo
	if pagedRequest {
		var offset int32
		var size int32 = int32(len(res))
		if size == in.GetPaging().GetLimit() {
			size--
			res = res[:size]
			offset = in.GetPaging().GetOffset() + size
		}
		resPaging = &query1.PageInfo{Offset: offset}
	}
	out := &ListVersionTagsResponse{Results: res, Page: resPaging}
	if custom, ok := interface{}(in).(VersionTagsVersionTagWithAfterList); ok {
		var err error
		if err = custom.AfterList(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// VersionTagsVersionTagWithBeforeList called before DefaultListVersionTag in the default List handler
type VersionTagsVersionTagWithBeforeList interface {
	BeforeList(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// VersionTagsVersionTagWithAfterList called before DefaultListVersionTag in the default List handler
type VersionTagsVersionTagWithAfterList interface {
	AfterList(context.Context, *ListVersionTagsResponse, *gorm1.DB) error
}
type SecretsDefaultServer struct {
}

// Create ...
func (m *SecretsDefaultServer) Create(ctx context.Context, in *CreateSecretRequest) (*CreateSecretResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors.New("Database Transaction For Request Missing")
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(SecretsSecretWithBeforeCreate); ok {
		var err error
		if db, err = custom.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateSecret(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreateSecretResponse{Result: res}
	if custom, ok := interface{}(in).(SecretsSecretWithAfterCreate); ok {
		var err error
		if err = custom.AfterCreate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// SecretsSecretWithBeforeCreate called before DefaultCreateSecret in the default Create handler
type SecretsSecretWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// SecretsSecretWithAfterCreate called before DefaultCreateSecret in the default Create handler
type SecretsSecretWithAfterCreate interface {
	AfterCreate(context.Context, *CreateSecretResponse, *gorm1.DB) error
}

// Read ...
func (m *SecretsDefaultServer) Read(ctx context.Context, in *ReadSecretRequest) (*ReadSecretResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors.New("Database Transaction For Request Missing")
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(SecretsSecretWithBeforeRead); ok {
		var err error
		if db, err = custom.BeforeRead(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadSecret(ctx, &Secret{Id: in.GetId()}, db, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ReadSecretResponse{Result: res}
	if custom, ok := interface{}(in).(SecretsSecretWithAfterRead); ok {
		var err error
		if err = custom.AfterRead(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// SecretsSecretWithBeforeRead called before DefaultReadSecret in the default Read handler
type SecretsSecretWithBeforeRead interface {
	BeforeRead(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// SecretsSecretWithAfterRead called before DefaultReadSecret in the default Read handler
type SecretsSecretWithAfterRead interface {
	AfterRead(context.Context, *ReadSecretResponse, *gorm1.DB) error
}

// Update ...
func (m *SecretsDefaultServer) Update(ctx context.Context, in *UpdateSecretRequest) (*UpdateSecretResponse, error) {
	var err error
	var res *Secret
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors.New("Database Transaction For Request Missing")
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(SecretsSecretWithBeforeUpdate); ok {
		var err error
		if db, err = custom.BeforeUpdate(ctx, db); err != nil {
			return nil, err
		}
	}
	if in.GetFields() == nil {
		res, err = DefaultStrictUpdateSecret(ctx, in.GetPayload(), db)
	} else {
		res, err = DefaultPatchSecret(ctx, in.GetPayload(), in.GetFields(), db)
	}
	if err != nil {
		return nil, err
	}
	out := &UpdateSecretResponse{Result: res}
	if custom, ok := interface{}(in).(SecretsSecretWithAfterUpdate); ok {
		var err error
		if err = custom.AfterUpdate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// SecretsSecretWithBeforeUpdate called before DefaultUpdateSecret in the default Update handler
type SecretsSecretWithBeforeUpdate interface {
	BeforeUpdate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// SecretsSecretWithAfterUpdate called before DefaultUpdateSecret in the default Update handler
type SecretsSecretWithAfterUpdate interface {
	AfterUpdate(context.Context, *UpdateSecretResponse, *gorm1.DB) error
}

// Delete ...
func (m *SecretsDefaultServer) Delete(ctx context.Context, in *DeleteSecretRequest) (*DeleteSecretResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors.New("Database Transaction For Request Missing")
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(SecretsSecretWithBeforeDelete); ok {
		var err error
		if db, err = custom.BeforeDelete(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteSecret(ctx, &Secret{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &DeleteSecretResponse{}
	if custom, ok := interface{}(in).(SecretsSecretWithAfterDelete); ok {
		var err error
		if err = custom.AfterDelete(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// SecretsSecretWithBeforeDelete called before DefaultDeleteSecret in the default Delete handler
type SecretsSecretWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// SecretsSecretWithAfterDelete called before DefaultDeleteSecret in the default Delete handler
type SecretsSecretWithAfterDelete interface {
	AfterDelete(context.Context, *DeleteSecretResponse, *gorm1.DB) error
}

// List ...
func (m *SecretsDefaultServer) List(ctx context.Context, in *ListSecretRequest) (*ListSecretsResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors.New("Database Transaction For Request Missing")
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(SecretsSecretWithBeforeList); ok {
		var err error
		if db, err = custom.BeforeList(ctx, db); err != nil {
			return nil, err
		}
	}
	pagedRequest := false
	if in.GetPaging().GetLimit() >= 1 {
		in.Paging.Limit++
		pagedRequest = true
	}
	res, err := DefaultListSecret(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	var resPaging *query1.PageInfo
	if pagedRequest {
		var offset int32
		var size int32 = int32(len(res))
		if size == in.GetPaging().GetLimit() {
			size--
			res = res[:size]
			offset = in.GetPaging().GetOffset() + size
		}
		resPaging = &query1.PageInfo{Offset: offset}
	}
	out := &ListSecretsResponse{Results: res, Page: resPaging}
	if custom, ok := interface{}(in).(SecretsSecretWithAfterList); ok {
		var err error
		if err = custom.AfterList(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// SecretsSecretWithBeforeList called before DefaultListSecret in the default List handler
type SecretsSecretWithBeforeList interface {
	BeforeList(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// SecretsSecretWithAfterList called before DefaultListSecret in the default List handler
type SecretsSecretWithAfterList interface {
	AfterList(context.Context, *ListSecretsResponse, *gorm1.DB) error
}
type VaultsDefaultServer struct {
}

// Create ...
func (m *VaultsDefaultServer) Create(ctx context.Context, in *CreateVaultRequest) (*CreateVaultResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors.New("Database Transaction For Request Missing")
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(VaultsVaultWithBeforeCreate); ok {
		var err error
		if db, err = custom.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateVault(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreateVaultResponse{Result: res}
	if custom, ok := interface{}(in).(VaultsVaultWithAfterCreate); ok {
		var err error
		if err = custom.AfterCreate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// VaultsVaultWithBeforeCreate called before DefaultCreateVault in the default Create handler
type VaultsVaultWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// VaultsVaultWithAfterCreate called before DefaultCreateVault in the default Create handler
type VaultsVaultWithAfterCreate interface {
	AfterCreate(context.Context, *CreateVaultResponse, *gorm1.DB) error
}

// Read ...
func (m *VaultsDefaultServer) Read(ctx context.Context, in *ReadVaultRequest) (*ReadVaultResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors.New("Database Transaction For Request Missing")
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(VaultsVaultWithBeforeRead); ok {
		var err error
		if db, err = custom.BeforeRead(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadVault(ctx, &Vault{Id: in.GetId()}, db, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ReadVaultResponse{Result: res}
	if custom, ok := interface{}(in).(VaultsVaultWithAfterRead); ok {
		var err error
		if err = custom.AfterRead(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// VaultsVaultWithBeforeRead called before DefaultReadVault in the default Read handler
type VaultsVaultWithBeforeRead interface {
	BeforeRead(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// VaultsVaultWithAfterRead called before DefaultReadVault in the default Read handler
type VaultsVaultWithAfterRead interface {
	AfterRead(context.Context, *ReadVaultResponse, *gorm1.DB) error
}

// Update ...
func (m *VaultsDefaultServer) Update(ctx context.Context, in *UpdateVaultRequest) (*UpdateVaultResponse, error) {
	var err error
	var res *Vault
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors.New("Database Transaction For Request Missing")
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(VaultsVaultWithBeforeUpdate); ok {
		var err error
		if db, err = custom.BeforeUpdate(ctx, db); err != nil {
			return nil, err
		}
	}
	if in.GetFields() == nil {
		res, err = DefaultStrictUpdateVault(ctx, in.GetPayload(), db)
	} else {
		res, err = DefaultPatchVault(ctx, in.GetPayload(), in.GetFields(), db)
	}
	if err != nil {
		return nil, err
	}
	out := &UpdateVaultResponse{Result: res}
	if custom, ok := interface{}(in).(VaultsVaultWithAfterUpdate); ok {
		var err error
		if err = custom.AfterUpdate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// VaultsVaultWithBeforeUpdate called before DefaultUpdateVault in the default Update handler
type VaultsVaultWithBeforeUpdate interface {
	BeforeUpdate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// VaultsVaultWithAfterUpdate called before DefaultUpdateVault in the default Update handler
type VaultsVaultWithAfterUpdate interface {
	AfterUpdate(context.Context, *UpdateVaultResponse, *gorm1.DB) error
}

// Delete ...
func (m *VaultsDefaultServer) Delete(ctx context.Context, in *DeleteVaultRequest) (*DeleteVaultResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors.New("Database Transaction For Request Missing")
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(VaultsVaultWithBeforeDelete); ok {
		var err error
		if db, err = custom.BeforeDelete(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteVault(ctx, &Vault{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &DeleteVaultResponse{}
	if custom, ok := interface{}(in).(VaultsVaultWithAfterDelete); ok {
		var err error
		if err = custom.AfterDelete(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// VaultsVaultWithBeforeDelete called before DefaultDeleteVault in the default Delete handler
type VaultsVaultWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// VaultsVaultWithAfterDelete called before DefaultDeleteVault in the default Delete handler
type VaultsVaultWithAfterDelete interface {
	AfterDelete(context.Context, *DeleteVaultResponse, *gorm1.DB) error
}

// List ...
func (m *VaultsDefaultServer) List(ctx context.Context, in *ListVaultRequest) (*ListVaultsResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors.New("Database Transaction For Request Missing")
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(VaultsVaultWithBeforeList); ok {
		var err error
		if db, err = custom.BeforeList(ctx, db); err != nil {
			return nil, err
		}
	}
	pagedRequest := false
	if in.GetPaging().GetLimit() >= 1 {
		in.Paging.Limit++
		pagedRequest = true
	}
	res, err := DefaultListVault(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	var resPaging *query1.PageInfo
	if pagedRequest {
		var offset int32
		var size int32 = int32(len(res))
		if size == in.GetPaging().GetLimit() {
			size--
			res = res[:size]
			offset = in.GetPaging().GetOffset() + size
		}
		resPaging = &query1.PageInfo{Offset: offset}
	}
	out := &ListVaultsResponse{Results: res, Page: resPaging}
	if custom, ok := interface{}(in).(VaultsVaultWithAfterList); ok {
		var err error
		if err = custom.AfterList(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// VaultsVaultWithBeforeList called before DefaultListVault in the default List handler
type VaultsVaultWithBeforeList interface {
	BeforeList(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// VaultsVaultWithAfterList called before DefaultListVault in the default List handler
type VaultsVaultWithAfterList interface {
	AfterList(context.Context, *ListVaultsResponse, *gorm1.DB) error
}
