// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: github.com/seizadi/cmdb/pkg/pb/cmdb.proto

// Generated with protoc-gen-gorm version: v0.18.0
// Anticipating compatibility with atlas-app-toolkit version: v0.19.0

/*
Package pb is a generated protocol buffer package.

It is generated from these files:
	github.com/seizadi/cmdb/pkg/pb/cmdb.proto

It has these top-level messages:
	VersionResponse
	CloudProvider
	CreateCloudProviderRequest
	CreateCloudProviderResponse
	ReadCloudProviderRequest
	ReadCloudProviderResponse
	UpdateCloudProviderRequest
	UpdateCloudProviderResponse
	DeleteCloudProviderRequest
	DeleteCloudProviderResponse
	ListCloudProviderRequest
	ListCloudProvidersResponse
	Region
	CreateRegionRequest
	CreateRegionResponse
	ReadRegionRequest
	ReadRegionResponse
	UpdateRegionRequest
	UpdateRegionResponse
	DeleteRegionRequest
	DeleteRegionResponse
	ListRegionRequest
	ListRegionsResponse
	Stage
	CreateStageRequest
	CreateStageResponse
	ReadStageRequest
	ReadStageResponse
	UpdateStageRequest
	UpdateStageResponse
	DeleteStageRequest
	DeleteStageResponse
	ListStageRequest
	ListStagesResponse
	Environment
	CreateEnvironmentRequest
	CreateEnvironmentResponse
	ReadEnvironmentRequest
	ReadEnvironmentResponse
	UpdateEnvironmentRequest
	UpdateEnvironmentResponse
	DeleteEnvironmentRequest
	DeleteEnvironmentResponse
	ListEnvironmentRequest
	ListEnvironmentsResponse
	Application
	CreateApplicationRequest
	CreateApplicationResponse
	ReadApplicationRequest
	ReadApplicationResponse
	UpdateApplicationRequest
	UpdateApplicationResponse
	DeleteApplicationRequest
	DeleteApplicationResponse
	ListApplicationRequest
	ListApplicationsResponse
	ChartVersion
	CreateChartVersionRequest
	CreateChartVersionResponse
	ReadChartVersionRequest
	ReadChartVersionResponse
	UpdateChartVersionRequest
	UpdateChartVersionResponse
	DeleteChartVersionRequest
	DeleteChartVersionResponse
	ListChartVersionRequest
	ListChartVersionsResponse
	ApplicationInstance
	CreateApplicationInstanceRequest
	CreateApplicationInstanceResponse
	ReadApplicationInstanceRequest
	ReadApplicationInstanceResponse
	UpdateApplicationInstanceRequest
	UpdateApplicationInstanceResponse
	DeleteApplicationInstanceRequest
	DeleteApplicationInstanceResponse
	ListApplicationInstanceRequest
	ListApplicationInstancesResponse
	Vault
	CreateVaultRequest
	CreateVaultResponse
	ReadVaultRequest
	ReadVaultResponse
	UpdateVaultRequest
	UpdateVaultResponse
	DeleteVaultRequest
	DeleteVaultResponse
	ListVaultRequest
	ListVaultsResponse
	Secret
	CreateSecretRequest
	CreateSecretResponse
	ReadSecretRequest
	ReadSecretResponse
	UpdateSecretRequest
	UpdateSecretResponse
	DeleteSecretRequest
	DeleteSecretResponse
	ListSecretRequest
	ListSecretsResponse
	AwsService
	CreateAwsServiceRequest
	CreateAwsServiceResponse
	ReadAwsServiceRequest
	ReadAwsServiceResponse
	UpdateAwsServiceRequest
	UpdateAwsServiceResponse
	DeleteAwsServiceRequest
	DeleteAwsServiceResponse
	ListAwsServiceRequest
	ListAwsServicesResponse
	AwsRdsInstance
	CreateAwsRdsInstanceRequest
	CreateAwsRdsInstanceResponse
	ReadAwsRdsInstanceRequest
	ReadAwsRdsInstanceResponse
	UpdateAwsRdsInstanceRequest
	UpdateAwsRdsInstanceResponse
	DeleteAwsRdsInstanceRequest
	DeleteAwsRdsInstanceResponse
	ListAwsRdsInstanceRequest
	ListAwsRdsInstancesResponse
	Value
	CreateValueRequest
	CreateValueResponse
	ReadValueRequest
	ReadValueResponse
	UpdateValueRequest
	UpdateValueResponse
	DeleteValueRequest
	DeleteValueResponse
	ListValueRequest
	ListValuesResponse
	Artifact
	CreateArtifactRequest
	CreateArtifactResponse
	ReadArtifactRequest
	ReadArtifactResponse
	UpdateArtifactRequest
	UpdateArtifactResponse
	DeleteArtifactRequest
	DeleteArtifactResponse
	ListArtifactRequest
	ListArtifactsResponse
	KubeCluster
	CreateKubeClusterRequest
	CreateKubeClusterResponse
	ReadKubeClusterRequest
	ReadKubeClusterResponse
	UpdateKubeClusterRequest
	UpdateKubeClusterResponse
	DeleteKubeClusterRequest
	DeleteKubeClusterResponse
	ListKubeClusterRequest
	ListKubeClustersResponse
	Deployment
	CreateDeploymentRequest
	CreateDeploymentResponse
	ReadDeploymentRequest
	ReadDeploymentResponse
	UpdateDeploymentRequest
	UpdateDeploymentResponse
	DeleteDeploymentRequest
	DeleteDeploymentResponse
	ListDeploymentRequest
	ListDeploymentsResponse
*/
package pb

import context "context"
import strings "strings"

import auth1 "github.com/infobloxopen/atlas-app-toolkit/auth"
import errors1 "github.com/infobloxopen/protoc-gen-gorm/errors"
import field_mask1 "google.golang.org/genproto/protobuf/field_mask"
import gorm1 "github.com/jinzhu/gorm"
import gorm2 "github.com/infobloxopen/atlas-app-toolkit/gorm"
import postgres1 "github.com/jinzhu/gorm/dialects/postgres"
import query1 "github.com/infobloxopen/atlas-app-toolkit/query"
import resource1 "github.com/infobloxopen/atlas-app-toolkit/gorm/resource"
import types1 "github.com/infobloxopen/protoc-gen-gorm/types"

import fmt "fmt"
import math "math"
import _ "github.com/golang/protobuf/ptypes/empty"
import _ "google.golang.org/genproto/protobuf/field_mask"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import _ "github.com/lyft/protoc-gen-validate/validate"
import _ "github.com/grpc-ecosystem/grpc-gateway/protoc-gen-swagger/options"
import _ "github.com/infobloxopen/atlas-app-toolkit/query"
import _ "github.com/infobloxopen/atlas-app-toolkit/rpc/resource"
import _ "github.com/infobloxopen/protoc-gen-atlas-query-validate/options"
import _ "github.com/infobloxopen/protoc-gen-atlas-validate/options"

// Reference imports to suppress errors if they are not otherwise used.
var _ = fmt.Errorf
var _ = math.Inf

type CloudProviderORM struct {
	Account     string
	AccountID   string
	Description string
	Id          int64 `gorm:"type:serial;primary_key"`
	Name        string
	Provider    int32
	Regions     []*RegionORM `gorm:"foreignkey:CloudProviderId;association_foreignkey:Id"`
}

// TableName overrides the default tablename generated by GORM
func (CloudProviderORM) TableName() string {
	return "cloud_providers"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *CloudProvider) ToORM(ctx context.Context) (CloudProviderORM, error) {
	to := CloudProviderORM{}
	var err error
	if prehook, ok := interface{}(m).(CloudProviderWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.DecodeInt64(&CloudProvider{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Description = m.Description
	to.Provider = int32(m.Provider)
	to.Account = m.Account
	for _, v := range m.Regions {
		if v != nil {
			if tempRegions, cErr := v.ToORM(ctx); cErr == nil {
				to.Regions = append(to.Regions, &tempRegions)
			} else {
				return to, cErr
			}
		} else {
			to.Regions = append(to.Regions, nil)
		}
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(CloudProviderWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *CloudProviderORM) ToPB(ctx context.Context) (CloudProvider, error) {
	to := CloudProvider{}
	var err error
	if prehook, ok := interface{}(m).(CloudProviderWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&CloudProvider{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Description = m.Description
	to.Provider = Provider(m.Provider)
	to.Account = m.Account
	for _, v := range m.Regions {
		if v != nil {
			if tempRegions, cErr := v.ToPB(ctx); cErr == nil {
				to.Regions = append(to.Regions, &tempRegions)
			} else {
				return to, cErr
			}
		} else {
			to.Regions = append(to.Regions, nil)
		}
	}
	if posthook, ok := interface{}(m).(CloudProviderWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type CloudProvider the arg will be the target, the caller the one being converted from

// CloudProviderBeforeToORM called before default ToORM code
type CloudProviderWithBeforeToORM interface {
	BeforeToORM(context.Context, *CloudProviderORM) error
}

// CloudProviderAfterToORM called after default ToORM code
type CloudProviderWithAfterToORM interface {
	AfterToORM(context.Context, *CloudProviderORM) error
}

// CloudProviderBeforeToPB called before default ToPB code
type CloudProviderWithBeforeToPB interface {
	BeforeToPB(context.Context, *CloudProvider) error
}

// CloudProviderAfterToPB called after default ToPB code
type CloudProviderWithAfterToPB interface {
	AfterToPB(context.Context, *CloudProvider) error
}

type RegionORM struct {
	AccountID       string
	AwsServices     []*AwsServiceORM `gorm:"foreignkey:RegionId;association_foreignkey:Id"`
	CloudProviderId *int64           `gorm:"type:integer"`
	Description     string
	Id              int64 `gorm:"type:serial;primary_key"`
	Name            string
	Stages          []*StageORM `gorm:"foreignkey:RegionId;association_foreignkey:Id"`
	ValueId         *int64      `gorm:"type:integer"`
}

// TableName overrides the default tablename generated by GORM
func (RegionORM) TableName() string {
	return "regions"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Region) ToORM(ctx context.Context) (RegionORM, error) {
	to := RegionORM{}
	var err error
	if prehook, ok := interface{}(m).(RegionWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.DecodeInt64(&Region{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Description = m.Description
	for _, v := range m.Stages {
		if v != nil {
			if tempStages, cErr := v.ToORM(ctx); cErr == nil {
				to.Stages = append(to.Stages, &tempStages)
			} else {
				return to, cErr
			}
		} else {
			to.Stages = append(to.Stages, nil)
		}
	}
	for _, v := range m.AwsServices {
		if v != nil {
			if tempAwsServices, cErr := v.ToORM(ctx); cErr == nil {
				to.AwsServices = append(to.AwsServices, &tempAwsServices)
			} else {
				return to, cErr
			}
		} else {
			to.AwsServices = append(to.AwsServices, nil)
		}
	}
	if m.ValueId != nil {
		if v, err := resource1.DecodeInt64(&Value{}, m.ValueId); err != nil {
			return to, err
		} else {
			to.ValueId = &v
		}
	}
	if m.CloudProviderId != nil {
		if v, err := resource1.DecodeInt64(&CloudProvider{}, m.CloudProviderId); err != nil {
			return to, err
		} else {
			to.CloudProviderId = &v
		}
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(RegionWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *RegionORM) ToPB(ctx context.Context) (Region, error) {
	to := Region{}
	var err error
	if prehook, ok := interface{}(m).(RegionWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&Region{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Description = m.Description
	for _, v := range m.Stages {
		if v != nil {
			if tempStages, cErr := v.ToPB(ctx); cErr == nil {
				to.Stages = append(to.Stages, &tempStages)
			} else {
				return to, cErr
			}
		} else {
			to.Stages = append(to.Stages, nil)
		}
	}
	for _, v := range m.AwsServices {
		if v != nil {
			if tempAwsServices, cErr := v.ToPB(ctx); cErr == nil {
				to.AwsServices = append(to.AwsServices, &tempAwsServices)
			} else {
				return to, cErr
			}
		} else {
			to.AwsServices = append(to.AwsServices, nil)
		}
	}
	if m.ValueId != nil {
		if v, err := resource1.Encode(&Value{}, *m.ValueId); err != nil {
			return to, err
		} else {
			to.ValueId = v
		}
	}
	if m.CloudProviderId != nil {
		if v, err := resource1.Encode(&CloudProvider{}, *m.CloudProviderId); err != nil {
			return to, err
		} else {
			to.CloudProviderId = v
		}
	}
	if posthook, ok := interface{}(m).(RegionWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Region the arg will be the target, the caller the one being converted from

// RegionBeforeToORM called before default ToORM code
type RegionWithBeforeToORM interface {
	BeforeToORM(context.Context, *RegionORM) error
}

// RegionAfterToORM called after default ToORM code
type RegionWithAfterToORM interface {
	AfterToORM(context.Context, *RegionORM) error
}

// RegionBeforeToPB called before default ToPB code
type RegionWithBeforeToPB interface {
	BeforeToPB(context.Context, *Region) error
}

// RegionAfterToPB called after default ToPB code
type RegionWithAfterToPB interface {
	AfterToPB(context.Context, *Region) error
}

type StageORM struct {
	AccountID    string
	Description  string
	Environments []*EnvironmentORM `gorm:"foreignkey:StageId;association_foreignkey:Id"`
	Id           int64             `gorm:"type:serial;primary_key"`
	Name         string
	RegionId     *int64 `gorm:"type:integer"`
	Type         int32
	ValueId      *int64 `gorm:"type:integer"`
}

// TableName overrides the default tablename generated by GORM
func (StageORM) TableName() string {
	return "stages"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Stage) ToORM(ctx context.Context) (StageORM, error) {
	to := StageORM{}
	var err error
	if prehook, ok := interface{}(m).(StageWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.DecodeInt64(&Stage{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Description = m.Description
	to.Type = int32(m.Type)
	for _, v := range m.Environments {
		if v != nil {
			if tempEnvironments, cErr := v.ToORM(ctx); cErr == nil {
				to.Environments = append(to.Environments, &tempEnvironments)
			} else {
				return to, cErr
			}
		} else {
			to.Environments = append(to.Environments, nil)
		}
	}
	if m.ValueId != nil {
		if v, err := resource1.DecodeInt64(&Value{}, m.ValueId); err != nil {
			return to, err
		} else {
			to.ValueId = &v
		}
	}
	if m.RegionId != nil {
		if v, err := resource1.DecodeInt64(&Region{}, m.RegionId); err != nil {
			return to, err
		} else {
			to.RegionId = &v
		}
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(StageWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *StageORM) ToPB(ctx context.Context) (Stage, error) {
	to := Stage{}
	var err error
	if prehook, ok := interface{}(m).(StageWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&Stage{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Description = m.Description
	to.Type = StageType(m.Type)
	for _, v := range m.Environments {
		if v != nil {
			if tempEnvironments, cErr := v.ToPB(ctx); cErr == nil {
				to.Environments = append(to.Environments, &tempEnvironments)
			} else {
				return to, cErr
			}
		} else {
			to.Environments = append(to.Environments, nil)
		}
	}
	if m.ValueId != nil {
		if v, err := resource1.Encode(&Value{}, *m.ValueId); err != nil {
			return to, err
		} else {
			to.ValueId = v
		}
	}
	if m.RegionId != nil {
		if v, err := resource1.Encode(&Region{}, *m.RegionId); err != nil {
			return to, err
		} else {
			to.RegionId = v
		}
	}
	if posthook, ok := interface{}(m).(StageWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Stage the arg will be the target, the caller the one being converted from

// StageBeforeToORM called before default ToORM code
type StageWithBeforeToORM interface {
	BeforeToORM(context.Context, *StageORM) error
}

// StageAfterToORM called after default ToORM code
type StageWithAfterToORM interface {
	AfterToORM(context.Context, *StageORM) error
}

// StageBeforeToPB called before default ToPB code
type StageWithBeforeToPB interface {
	BeforeToPB(context.Context, *Stage) error
}

// StageAfterToPB called after default ToPB code
type StageWithAfterToPB interface {
	AfterToPB(context.Context, *Stage) error
}

type EnvironmentORM struct {
	AccountID            string
	ApplicationInstances []*ApplicationInstanceORM `gorm:"foreignkey:EnvironmentId;association_foreignkey:Id"`
	Description          string
	Id                   int64 `gorm:"type:serial;primary_key"`
	Name                 string
	StageId              *int64 `gorm:"type:integer"`
	ValueId              *int64 `gorm:"type:integer"`
}

// TableName overrides the default tablename generated by GORM
func (EnvironmentORM) TableName() string {
	return "environments"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Environment) ToORM(ctx context.Context) (EnvironmentORM, error) {
	to := EnvironmentORM{}
	var err error
	if prehook, ok := interface{}(m).(EnvironmentWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.DecodeInt64(&Environment{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Description = m.Description
	for _, v := range m.ApplicationInstances {
		if v != nil {
			if tempApplicationInstances, cErr := v.ToORM(ctx); cErr == nil {
				to.ApplicationInstances = append(to.ApplicationInstances, &tempApplicationInstances)
			} else {
				return to, cErr
			}
		} else {
			to.ApplicationInstances = append(to.ApplicationInstances, nil)
		}
	}
	if m.ValueId != nil {
		if v, err := resource1.DecodeInt64(&Value{}, m.ValueId); err != nil {
			return to, err
		} else {
			to.ValueId = &v
		}
	}
	if m.StageId != nil {
		if v, err := resource1.DecodeInt64(&Stage{}, m.StageId); err != nil {
			return to, err
		} else {
			to.StageId = &v
		}
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(EnvironmentWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *EnvironmentORM) ToPB(ctx context.Context) (Environment, error) {
	to := Environment{}
	var err error
	if prehook, ok := interface{}(m).(EnvironmentWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&Environment{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Description = m.Description
	for _, v := range m.ApplicationInstances {
		if v != nil {
			if tempApplicationInstances, cErr := v.ToPB(ctx); cErr == nil {
				to.ApplicationInstances = append(to.ApplicationInstances, &tempApplicationInstances)
			} else {
				return to, cErr
			}
		} else {
			to.ApplicationInstances = append(to.ApplicationInstances, nil)
		}
	}
	if m.ValueId != nil {
		if v, err := resource1.Encode(&Value{}, *m.ValueId); err != nil {
			return to, err
		} else {
			to.ValueId = v
		}
	}
	if m.StageId != nil {
		if v, err := resource1.Encode(&Stage{}, *m.StageId); err != nil {
			return to, err
		} else {
			to.StageId = v
		}
	}
	if posthook, ok := interface{}(m).(EnvironmentWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Environment the arg will be the target, the caller the one being converted from

// EnvironmentBeforeToORM called before default ToORM code
type EnvironmentWithBeforeToORM interface {
	BeforeToORM(context.Context, *EnvironmentORM) error
}

// EnvironmentAfterToORM called after default ToORM code
type EnvironmentWithAfterToORM interface {
	AfterToORM(context.Context, *EnvironmentORM) error
}

// EnvironmentBeforeToPB called before default ToPB code
type EnvironmentWithBeforeToPB interface {
	BeforeToPB(context.Context, *Environment) error
}

// EnvironmentAfterToPB called after default ToPB code
type EnvironmentWithAfterToPB interface {
	AfterToPB(context.Context, *Environment) error
}

type ApplicationORM struct {
	AccountID            string
	ApplicationInstances []*ApplicationInstanceORM `gorm:"foreignkey:ApplicationId;association_foreignkey:Id"`
	Description          string
	Id                   int64 `gorm:"type:serial;primary_key"`
	Name                 string
	StageId              *int64 `gorm:"type:integer"`
	ValueId              *int64 `gorm:"type:integer"`
}

// TableName overrides the default tablename generated by GORM
func (ApplicationORM) TableName() string {
	return "applications"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Application) ToORM(ctx context.Context) (ApplicationORM, error) {
	to := ApplicationORM{}
	var err error
	if prehook, ok := interface{}(m).(ApplicationWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.DecodeInt64(&Application{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Description = m.Description
	for _, v := range m.ApplicationInstances {
		if v != nil {
			if tempApplicationInstances, cErr := v.ToORM(ctx); cErr == nil {
				to.ApplicationInstances = append(to.ApplicationInstances, &tempApplicationInstances)
			} else {
				return to, cErr
			}
		} else {
			to.ApplicationInstances = append(to.ApplicationInstances, nil)
		}
	}
	if m.ValueId != nil {
		if v, err := resource1.DecodeInt64(&Value{}, m.ValueId); err != nil {
			return to, err
		} else {
			to.ValueId = &v
		}
	}
	if m.StageId != nil {
		if v, err := resource1.DecodeInt64(&Stage{}, m.StageId); err != nil {
			return to, err
		} else {
			to.StageId = &v
		}
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(ApplicationWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ApplicationORM) ToPB(ctx context.Context) (Application, error) {
	to := Application{}
	var err error
	if prehook, ok := interface{}(m).(ApplicationWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&Application{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Description = m.Description
	for _, v := range m.ApplicationInstances {
		if v != nil {
			if tempApplicationInstances, cErr := v.ToPB(ctx); cErr == nil {
				to.ApplicationInstances = append(to.ApplicationInstances, &tempApplicationInstances)
			} else {
				return to, cErr
			}
		} else {
			to.ApplicationInstances = append(to.ApplicationInstances, nil)
		}
	}
	if m.ValueId != nil {
		if v, err := resource1.Encode(&Value{}, *m.ValueId); err != nil {
			return to, err
		} else {
			to.ValueId = v
		}
	}
	if m.StageId != nil {
		if v, err := resource1.Encode(&Stage{}, *m.StageId); err != nil {
			return to, err
		} else {
			to.StageId = v
		}
	}
	if posthook, ok := interface{}(m).(ApplicationWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Application the arg will be the target, the caller the one being converted from

// ApplicationBeforeToORM called before default ToORM code
type ApplicationWithBeforeToORM interface {
	BeforeToORM(context.Context, *ApplicationORM) error
}

// ApplicationAfterToORM called after default ToORM code
type ApplicationWithAfterToORM interface {
	AfterToORM(context.Context, *ApplicationORM) error
}

// ApplicationBeforeToPB called before default ToPB code
type ApplicationWithBeforeToPB interface {
	BeforeToPB(context.Context, *Application) error
}

// ApplicationAfterToPB called after default ToPB code
type ApplicationWithAfterToPB interface {
	AfterToPB(context.Context, *Application) error
}

type ChartVersionORM struct {
	AccountID   string
	Description string
	Id          int64 `gorm:"type:serial;primary_key"`
	Name        string
	Repo        string
	Version     string
}

// TableName overrides the default tablename generated by GORM
func (ChartVersionORM) TableName() string {
	return "chart_versions"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *ChartVersion) ToORM(ctx context.Context) (ChartVersionORM, error) {
	to := ChartVersionORM{}
	var err error
	if prehook, ok := interface{}(m).(ChartVersionWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.DecodeInt64(&ChartVersion{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Description = m.Description
	to.Repo = m.Repo
	to.Version = m.Version
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(ChartVersionWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ChartVersionORM) ToPB(ctx context.Context) (ChartVersion, error) {
	to := ChartVersion{}
	var err error
	if prehook, ok := interface{}(m).(ChartVersionWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&ChartVersion{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Description = m.Description
	to.Repo = m.Repo
	to.Version = m.Version
	if posthook, ok := interface{}(m).(ChartVersionWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type ChartVersion the arg will be the target, the caller the one being converted from

// ChartVersionBeforeToORM called before default ToORM code
type ChartVersionWithBeforeToORM interface {
	BeforeToORM(context.Context, *ChartVersionORM) error
}

// ChartVersionAfterToORM called after default ToORM code
type ChartVersionWithAfterToORM interface {
	AfterToORM(context.Context, *ChartVersionORM) error
}

// ChartVersionBeforeToPB called before default ToPB code
type ChartVersionWithBeforeToPB interface {
	BeforeToPB(context.Context, *ChartVersion) error
}

// ChartVersionAfterToPB called after default ToPB code
type ChartVersionWithAfterToPB interface {
	AfterToPB(context.Context, *ChartVersion) error
}

type ApplicationInstanceORM struct {
	AccountID      string
	ApplicationId  *int64         `gorm:"type:integer"`
	ChartVersionId *int64         `gorm:"type:integer"`
	Deployment     *DeploymentORM `gorm:"foreignkey:ApplicationInstanceId;association_foreignkey:Id"`
	Description    string
	EnvironmentId  *int64 `gorm:"type:integer"`
	Id             int64  `gorm:"type:serial;primary_key"`
	Name           string
	ValueId        *int64 `gorm:"type:integer"`
}

// TableName overrides the default tablename generated by GORM
func (ApplicationInstanceORM) TableName() string {
	return "application_instances"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *ApplicationInstance) ToORM(ctx context.Context) (ApplicationInstanceORM, error) {
	to := ApplicationInstanceORM{}
	var err error
	if prehook, ok := interface{}(m).(ApplicationInstanceWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.DecodeInt64(&ApplicationInstance{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Description = m.Description
	if m.Deployment != nil {
		tempDeployment, err := m.Deployment.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Deployment = &tempDeployment
	}
	if m.ValueId != nil {
		if v, err := resource1.DecodeInt64(&Value{}, m.ValueId); err != nil {
			return to, err
		} else {
			to.ValueId = &v
		}
	}
	if m.ApplicationId != nil {
		if v, err := resource1.DecodeInt64(&Application{}, m.ApplicationId); err != nil {
			return to, err
		} else {
			to.ApplicationId = &v
		}
	}
	if m.ChartVersionId != nil {
		if v, err := resource1.DecodeInt64(&ChartVersion{}, m.ChartVersionId); err != nil {
			return to, err
		} else {
			to.ChartVersionId = &v
		}
	}
	if m.EnvironmentId != nil {
		if v, err := resource1.DecodeInt64(&Environment{}, m.EnvironmentId); err != nil {
			return to, err
		} else {
			to.EnvironmentId = &v
		}
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(ApplicationInstanceWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ApplicationInstanceORM) ToPB(ctx context.Context) (ApplicationInstance, error) {
	to := ApplicationInstance{}
	var err error
	if prehook, ok := interface{}(m).(ApplicationInstanceWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&ApplicationInstance{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Description = m.Description
	if m.Deployment != nil {
		tempDeployment, err := m.Deployment.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Deployment = &tempDeployment
	}
	if m.ValueId != nil {
		if v, err := resource1.Encode(&Value{}, *m.ValueId); err != nil {
			return to, err
		} else {
			to.ValueId = v
		}
	}
	if m.ApplicationId != nil {
		if v, err := resource1.Encode(&Application{}, *m.ApplicationId); err != nil {
			return to, err
		} else {
			to.ApplicationId = v
		}
	}
	if m.ChartVersionId != nil {
		if v, err := resource1.Encode(&ChartVersion{}, *m.ChartVersionId); err != nil {
			return to, err
		} else {
			to.ChartVersionId = v
		}
	}
	if m.EnvironmentId != nil {
		if v, err := resource1.Encode(&Environment{}, *m.EnvironmentId); err != nil {
			return to, err
		} else {
			to.EnvironmentId = v
		}
	}
	if posthook, ok := interface{}(m).(ApplicationInstanceWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type ApplicationInstance the arg will be the target, the caller the one being converted from

// ApplicationInstanceBeforeToORM called before default ToORM code
type ApplicationInstanceWithBeforeToORM interface {
	BeforeToORM(context.Context, *ApplicationInstanceORM) error
}

// ApplicationInstanceAfterToORM called after default ToORM code
type ApplicationInstanceWithAfterToORM interface {
	AfterToORM(context.Context, *ApplicationInstanceORM) error
}

// ApplicationInstanceBeforeToPB called before default ToPB code
type ApplicationInstanceWithBeforeToPB interface {
	BeforeToPB(context.Context, *ApplicationInstance) error
}

// ApplicationInstanceAfterToPB called after default ToPB code
type ApplicationInstanceWithAfterToPB interface {
	AfterToPB(context.Context, *ApplicationInstance) error
}

type VaultORM struct {
	AccountID   string
	Description string
	Id          int64 `gorm:"type:serial;primary_key"`
	Name        string
	Secrets     []*SecretORM `gorm:"foreignkey:VaultId;association_foreignkey:Id"`
}

// TableName overrides the default tablename generated by GORM
func (VaultORM) TableName() string {
	return "vaults"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Vault) ToORM(ctx context.Context) (VaultORM, error) {
	to := VaultORM{}
	var err error
	if prehook, ok := interface{}(m).(VaultWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.DecodeInt64(&Vault{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Description = m.Description
	for _, v := range m.Secrets {
		if v != nil {
			if tempSecrets, cErr := v.ToORM(ctx); cErr == nil {
				to.Secrets = append(to.Secrets, &tempSecrets)
			} else {
				return to, cErr
			}
		} else {
			to.Secrets = append(to.Secrets, nil)
		}
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(VaultWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *VaultORM) ToPB(ctx context.Context) (Vault, error) {
	to := Vault{}
	var err error
	if prehook, ok := interface{}(m).(VaultWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&Vault{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Description = m.Description
	for _, v := range m.Secrets {
		if v != nil {
			if tempSecrets, cErr := v.ToPB(ctx); cErr == nil {
				to.Secrets = append(to.Secrets, &tempSecrets)
			} else {
				return to, cErr
			}
		} else {
			to.Secrets = append(to.Secrets, nil)
		}
	}
	if posthook, ok := interface{}(m).(VaultWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Vault the arg will be the target, the caller the one being converted from

// VaultBeforeToORM called before default ToORM code
type VaultWithBeforeToORM interface {
	BeforeToORM(context.Context, *VaultORM) error
}

// VaultAfterToORM called after default ToORM code
type VaultWithAfterToORM interface {
	AfterToORM(context.Context, *VaultORM) error
}

// VaultBeforeToPB called before default ToPB code
type VaultWithBeforeToPB interface {
	BeforeToPB(context.Context, *Vault) error
}

// VaultAfterToPB called after default ToPB code
type VaultWithAfterToPB interface {
	AfterToPB(context.Context, *Vault) error
}

type SecretORM struct {
	AccountID        string
	AwsRdsInstanceId *int64 `gorm:"type:integer"`
	Description      string
	Id               int64 `gorm:"type:serial;primary_key"`
	Key              string
	Name             string
	Path             string
	Type             string
	ValueId          *int64 `gorm:"type:integer"`
	VaultId          *int64 `gorm:"type:integer"`
}

// TableName overrides the default tablename generated by GORM
func (SecretORM) TableName() string {
	return "secrets"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Secret) ToORM(ctx context.Context) (SecretORM, error) {
	to := SecretORM{}
	var err error
	if prehook, ok := interface{}(m).(SecretWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.DecodeInt64(&Secret{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Description = m.Description
	to.Path = m.Path
	to.Type = m.Type
	to.Key = m.Key
	if m.VaultId != nil {
		if v, err := resource1.DecodeInt64(&Vault{}, m.VaultId); err != nil {
			return to, err
		} else {
			to.VaultId = &v
		}
	}
	if m.ValueId != nil {
		if v, err := resource1.DecodeInt64(&Value{}, m.ValueId); err != nil {
			return to, err
		} else {
			to.ValueId = &v
		}
	}
	if m.AwsRdsInstanceId != nil {
		if v, err := resource1.DecodeInt64(&AwsRdsInstance{}, m.AwsRdsInstanceId); err != nil {
			return to, err
		} else {
			to.AwsRdsInstanceId = &v
		}
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(SecretWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *SecretORM) ToPB(ctx context.Context) (Secret, error) {
	to := Secret{}
	var err error
	if prehook, ok := interface{}(m).(SecretWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&Secret{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Description = m.Description
	to.Path = m.Path
	to.Type = m.Type
	to.Key = m.Key
	if m.VaultId != nil {
		if v, err := resource1.Encode(&Vault{}, *m.VaultId); err != nil {
			return to, err
		} else {
			to.VaultId = v
		}
	}
	if m.ValueId != nil {
		if v, err := resource1.Encode(&Value{}, *m.ValueId); err != nil {
			return to, err
		} else {
			to.ValueId = v
		}
	}
	if m.AwsRdsInstanceId != nil {
		if v, err := resource1.Encode(&AwsRdsInstance{}, *m.AwsRdsInstanceId); err != nil {
			return to, err
		} else {
			to.AwsRdsInstanceId = v
		}
	}
	if posthook, ok := interface{}(m).(SecretWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Secret the arg will be the target, the caller the one being converted from

// SecretBeforeToORM called before default ToORM code
type SecretWithBeforeToORM interface {
	BeforeToORM(context.Context, *SecretORM) error
}

// SecretAfterToORM called after default ToORM code
type SecretWithAfterToORM interface {
	AfterToORM(context.Context, *SecretORM) error
}

// SecretBeforeToPB called before default ToPB code
type SecretWithBeforeToPB interface {
	BeforeToPB(context.Context, *Secret) error
}

// SecretAfterToPB called after default ToPB code
type SecretWithAfterToPB interface {
	AfterToPB(context.Context, *Secret) error
}

type AwsServiceORM struct {
	AccountID       string
	AwsRdsInstances []*AwsRdsInstanceORM `gorm:"foreignkey:AwsServiceId;association_foreignkey:Id"`
	Description     string
	Id              int64 `gorm:"type:serial;primary_key"`
	Name            string
	RegionId        *int64 `gorm:"type:integer"`
}

// TableName overrides the default tablename generated by GORM
func (AwsServiceORM) TableName() string {
	return "aws_services"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *AwsService) ToORM(ctx context.Context) (AwsServiceORM, error) {
	to := AwsServiceORM{}
	var err error
	if prehook, ok := interface{}(m).(AwsServiceWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.DecodeInt64(&AwsService{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Description = m.Description
	for _, v := range m.AwsRdsInstances {
		if v != nil {
			if tempAwsRdsInstances, cErr := v.ToORM(ctx); cErr == nil {
				to.AwsRdsInstances = append(to.AwsRdsInstances, &tempAwsRdsInstances)
			} else {
				return to, cErr
			}
		} else {
			to.AwsRdsInstances = append(to.AwsRdsInstances, nil)
		}
	}
	if m.RegionId != nil {
		if v, err := resource1.DecodeInt64(&Region{}, m.RegionId); err != nil {
			return to, err
		} else {
			to.RegionId = &v
		}
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(AwsServiceWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *AwsServiceORM) ToPB(ctx context.Context) (AwsService, error) {
	to := AwsService{}
	var err error
	if prehook, ok := interface{}(m).(AwsServiceWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&AwsService{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Description = m.Description
	for _, v := range m.AwsRdsInstances {
		if v != nil {
			if tempAwsRdsInstances, cErr := v.ToPB(ctx); cErr == nil {
				to.AwsRdsInstances = append(to.AwsRdsInstances, &tempAwsRdsInstances)
			} else {
				return to, cErr
			}
		} else {
			to.AwsRdsInstances = append(to.AwsRdsInstances, nil)
		}
	}
	if m.RegionId != nil {
		if v, err := resource1.Encode(&Region{}, *m.RegionId); err != nil {
			return to, err
		} else {
			to.RegionId = v
		}
	}
	if posthook, ok := interface{}(m).(AwsServiceWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type AwsService the arg will be the target, the caller the one being converted from

// AwsServiceBeforeToORM called before default ToORM code
type AwsServiceWithBeforeToORM interface {
	BeforeToORM(context.Context, *AwsServiceORM) error
}

// AwsServiceAfterToORM called after default ToORM code
type AwsServiceWithAfterToORM interface {
	AfterToORM(context.Context, *AwsServiceORM) error
}

// AwsServiceBeforeToPB called before default ToPB code
type AwsServiceWithBeforeToPB interface {
	BeforeToPB(context.Context, *AwsService) error
}

// AwsServiceAfterToPB called after default ToPB code
type AwsServiceWithAfterToPB interface {
	AfterToPB(context.Context, *AwsService) error
}

type AwsRdsInstanceORM struct {
	AccountID        string
	AwsServiceId     *int64 `gorm:"type:integer"`
	DatabaseHost     string
	DatabaseName     string
	DatabasePassword *SecretORM `gorm:"foreignkey:AwsRdsInstanceId;association_foreignkey:Id"`
	DatabaseUser     string
	Description      string
	Id               int64 `gorm:"type:serial;primary_key"`
	Name             string
}

// TableName overrides the default tablename generated by GORM
func (AwsRdsInstanceORM) TableName() string {
	return "aws_rds_instances"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *AwsRdsInstance) ToORM(ctx context.Context) (AwsRdsInstanceORM, error) {
	to := AwsRdsInstanceORM{}
	var err error
	if prehook, ok := interface{}(m).(AwsRdsInstanceWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.DecodeInt64(&AwsRdsInstance{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Description = m.Description
	to.DatabaseHost = m.DatabaseHost
	to.DatabaseName = m.DatabaseName
	to.DatabaseUser = m.DatabaseUser
	if m.DatabasePassword != nil {
		tempDatabasePassword, err := m.DatabasePassword.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.DatabasePassword = &tempDatabasePassword
	}
	if m.AwsServiceId != nil {
		if v, err := resource1.DecodeInt64(&AwsService{}, m.AwsServiceId); err != nil {
			return to, err
		} else {
			to.AwsServiceId = &v
		}
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(AwsRdsInstanceWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *AwsRdsInstanceORM) ToPB(ctx context.Context) (AwsRdsInstance, error) {
	to := AwsRdsInstance{}
	var err error
	if prehook, ok := interface{}(m).(AwsRdsInstanceWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&AwsRdsInstance{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Description = m.Description
	to.DatabaseHost = m.DatabaseHost
	to.DatabaseName = m.DatabaseName
	to.DatabaseUser = m.DatabaseUser
	if m.DatabasePassword != nil {
		tempDatabasePassword, err := m.DatabasePassword.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.DatabasePassword = &tempDatabasePassword
	}
	if m.AwsServiceId != nil {
		if v, err := resource1.Encode(&AwsService{}, *m.AwsServiceId); err != nil {
			return to, err
		} else {
			to.AwsServiceId = v
		}
	}
	if posthook, ok := interface{}(m).(AwsRdsInstanceWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type AwsRdsInstance the arg will be the target, the caller the one being converted from

// AwsRdsInstanceBeforeToORM called before default ToORM code
type AwsRdsInstanceWithBeforeToORM interface {
	BeforeToORM(context.Context, *AwsRdsInstanceORM) error
}

// AwsRdsInstanceAfterToORM called after default ToORM code
type AwsRdsInstanceWithAfterToORM interface {
	AfterToORM(context.Context, *AwsRdsInstanceORM) error
}

// AwsRdsInstanceBeforeToPB called before default ToPB code
type AwsRdsInstanceWithBeforeToPB interface {
	BeforeToPB(context.Context, *AwsRdsInstance) error
}

// AwsRdsInstanceAfterToPB called after default ToPB code
type AwsRdsInstanceWithAfterToPB interface {
	AfterToPB(context.Context, *AwsRdsInstance) error
}

type ValueORM struct {
	AccountID        string
	AwsRdsInstanceId *int64 `gorm:"type:integer"`
	Description      string
	Id               int64            `gorm:"type:serial;primary_key"`
	Keys             *postgres1.Jsonb `gorm:"type:jsonb"`
	Name             string
}

// TableName overrides the default tablename generated by GORM
func (ValueORM) TableName() string {
	return "values"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Value) ToORM(ctx context.Context) (ValueORM, error) {
	to := ValueORM{}
	var err error
	if prehook, ok := interface{}(m).(ValueWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.DecodeInt64(&Value{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Description = m.Description
	if m.Keys != nil {
		to.Keys = &postgres1.Jsonb{[]byte(m.Keys.Value)}
	}
	if m.AwsRdsInstanceId != nil {
		if v, err := resource1.DecodeInt64(&AwsRdsInstance{}, m.AwsRdsInstanceId); err != nil {
			return to, err
		} else {
			to.AwsRdsInstanceId = &v
		}
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(ValueWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ValueORM) ToPB(ctx context.Context) (Value, error) {
	to := Value{}
	var err error
	if prehook, ok := interface{}(m).(ValueWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&Value{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Description = m.Description
	if m.Keys != nil {
		to.Keys = &types1.JSONValue{Value: string(m.Keys.RawMessage)}
	}
	if m.AwsRdsInstanceId != nil {
		if v, err := resource1.Encode(&AwsRdsInstance{}, *m.AwsRdsInstanceId); err != nil {
			return to, err
		} else {
			to.AwsRdsInstanceId = v
		}
	}
	if posthook, ok := interface{}(m).(ValueWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Value the arg will be the target, the caller the one being converted from

// ValueBeforeToORM called before default ToORM code
type ValueWithBeforeToORM interface {
	BeforeToORM(context.Context, *ValueORM) error
}

// ValueAfterToORM called after default ToORM code
type ValueWithAfterToORM interface {
	AfterToORM(context.Context, *ValueORM) error
}

// ValueBeforeToPB called before default ToPB code
type ValueWithBeforeToPB interface {
	BeforeToPB(context.Context, *Value) error
}

// ValueAfterToPB called after default ToPB code
type ValueWithAfterToPB interface {
	AfterToPB(context.Context, *Value) error
}

type ArtifactORM struct {
	AccountID      string
	ChartVersionId *int64 `gorm:"type:integer"`
	Commit         string
	Description    string
	Id             int64 `gorm:"type:serial;primary_key"`
	Name           string
	Repo           string
}

// TableName overrides the default tablename generated by GORM
func (ArtifactORM) TableName() string {
	return "artifacts"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Artifact) ToORM(ctx context.Context) (ArtifactORM, error) {
	to := ArtifactORM{}
	var err error
	if prehook, ok := interface{}(m).(ArtifactWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.DecodeInt64(&Artifact{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Description = m.Description
	to.Repo = m.Repo
	to.Commit = m.Commit
	if m.ChartVersionId != nil {
		if v, err := resource1.DecodeInt64(&ChartVersion{}, m.ChartVersionId); err != nil {
			return to, err
		} else {
			to.ChartVersionId = &v
		}
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(ArtifactWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ArtifactORM) ToPB(ctx context.Context) (Artifact, error) {
	to := Artifact{}
	var err error
	if prehook, ok := interface{}(m).(ArtifactWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&Artifact{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Description = m.Description
	to.Repo = m.Repo
	to.Commit = m.Commit
	if m.ChartVersionId != nil {
		if v, err := resource1.Encode(&ChartVersion{}, *m.ChartVersionId); err != nil {
			return to, err
		} else {
			to.ChartVersionId = v
		}
	}
	if posthook, ok := interface{}(m).(ArtifactWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Artifact the arg will be the target, the caller the one being converted from

// ArtifactBeforeToORM called before default ToORM code
type ArtifactWithBeforeToORM interface {
	BeforeToORM(context.Context, *ArtifactORM) error
}

// ArtifactAfterToORM called after default ToORM code
type ArtifactWithAfterToORM interface {
	AfterToORM(context.Context, *ArtifactORM) error
}

// ArtifactBeforeToPB called before default ToPB code
type ArtifactWithBeforeToPB interface {
	BeforeToPB(context.Context, *Artifact) error
}

// ArtifactAfterToPB called after default ToPB code
type ArtifactWithAfterToPB interface {
	AfterToPB(context.Context, *Artifact) error
}

type KubeClusterORM struct {
	AccountID   string
	Description string
	Id          int64 `gorm:"type:serial;primary_key"`
	Name        string
}

// TableName overrides the default tablename generated by GORM
func (KubeClusterORM) TableName() string {
	return "kube_clusters"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *KubeCluster) ToORM(ctx context.Context) (KubeClusterORM, error) {
	to := KubeClusterORM{}
	var err error
	if prehook, ok := interface{}(m).(KubeClusterWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.DecodeInt64(&KubeCluster{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Description = m.Description
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(KubeClusterWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *KubeClusterORM) ToPB(ctx context.Context) (KubeCluster, error) {
	to := KubeCluster{}
	var err error
	if prehook, ok := interface{}(m).(KubeClusterWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&KubeCluster{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Description = m.Description
	if posthook, ok := interface{}(m).(KubeClusterWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type KubeCluster the arg will be the target, the caller the one being converted from

// KubeClusterBeforeToORM called before default ToORM code
type KubeClusterWithBeforeToORM interface {
	BeforeToORM(context.Context, *KubeClusterORM) error
}

// KubeClusterAfterToORM called after default ToORM code
type KubeClusterWithAfterToORM interface {
	AfterToORM(context.Context, *KubeClusterORM) error
}

// KubeClusterBeforeToPB called before default ToPB code
type KubeClusterWithBeforeToPB interface {
	BeforeToPB(context.Context, *KubeCluster) error
}

// KubeClusterAfterToPB called after default ToPB code
type KubeClusterWithAfterToPB interface {
	AfterToPB(context.Context, *KubeCluster) error
}

type DeploymentORM struct {
	AccountID             string
	ApplicationInstanceId *int64       `gorm:"type:integer"`
	Artifact              *ArtifactORM `gorm:"foreignkey:ArtifactId;association_foreignkey:Id"`
	ArtifactId            *int64       `gorm:"type:integer"`
	Description           string
	Id                    int64           `gorm:"type:serial;primary_key"`
	KubeCluster           *KubeClusterORM `gorm:"foreignkey:KubeClusterId;association_foreignkey:Id"`
	KubeClusterId         *int64          `gorm:"type:integer"`
	Name                  string
}

// TableName overrides the default tablename generated by GORM
func (DeploymentORM) TableName() string {
	return "deployments"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Deployment) ToORM(ctx context.Context) (DeploymentORM, error) {
	to := DeploymentORM{}
	var err error
	if prehook, ok := interface{}(m).(DeploymentWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.DecodeInt64(&Deployment{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Description = m.Description
	if m.Artifact != nil {
		tempArtifact, err := m.Artifact.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Artifact = &tempArtifact
	}
	if m.ArtifactId != nil {
		if v, err := resource1.DecodeInt64(&Artifact{}, m.ArtifactId); err != nil {
			return to, err
		} else {
			to.ArtifactId = &v
		}
	}
	if m.KubeCluster != nil {
		tempKubeCluster, err := m.KubeCluster.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.KubeCluster = &tempKubeCluster
	}
	if m.KubeClusterId != nil {
		if v, err := resource1.DecodeInt64(&KubeCluster{}, m.KubeClusterId); err != nil {
			return to, err
		} else {
			to.KubeClusterId = &v
		}
	}
	if m.ApplicationInstanceId != nil {
		if v, err := resource1.DecodeInt64(&ApplicationInstance{}, m.ApplicationInstanceId); err != nil {
			return to, err
		} else {
			to.ApplicationInstanceId = &v
		}
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(DeploymentWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *DeploymentORM) ToPB(ctx context.Context) (Deployment, error) {
	to := Deployment{}
	var err error
	if prehook, ok := interface{}(m).(DeploymentWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&Deployment{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Description = m.Description
	if m.Artifact != nil {
		tempArtifact, err := m.Artifact.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Artifact = &tempArtifact
	}
	if m.ArtifactId != nil {
		if v, err := resource1.Encode(&Artifact{}, *m.ArtifactId); err != nil {
			return to, err
		} else {
			to.ArtifactId = v
		}
	}
	if m.KubeCluster != nil {
		tempKubeCluster, err := m.KubeCluster.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.KubeCluster = &tempKubeCluster
	}
	if m.KubeClusterId != nil {
		if v, err := resource1.Encode(&KubeCluster{}, *m.KubeClusterId); err != nil {
			return to, err
		} else {
			to.KubeClusterId = v
		}
	}
	if m.ApplicationInstanceId != nil {
		if v, err := resource1.Encode(&ApplicationInstance{}, *m.ApplicationInstanceId); err != nil {
			return to, err
		} else {
			to.ApplicationInstanceId = v
		}
	}
	if posthook, ok := interface{}(m).(DeploymentWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Deployment the arg will be the target, the caller the one being converted from

// DeploymentBeforeToORM called before default ToORM code
type DeploymentWithBeforeToORM interface {
	BeforeToORM(context.Context, *DeploymentORM) error
}

// DeploymentAfterToORM called after default ToORM code
type DeploymentWithAfterToORM interface {
	AfterToORM(context.Context, *DeploymentORM) error
}

// DeploymentBeforeToPB called before default ToPB code
type DeploymentWithBeforeToPB interface {
	BeforeToPB(context.Context, *Deployment) error
}

// DeploymentAfterToPB called after default ToPB code
type DeploymentWithAfterToPB interface {
	AfterToPB(context.Context, *Deployment) error
}

// DefaultCreateCloudProvider executes a basic gorm create call
func DefaultCreateCloudProvider(ctx context.Context, in *CloudProvider, db *gorm1.DB) (*CloudProvider, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CloudProviderORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CloudProviderORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type CloudProviderORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type CloudProviderORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadCloudProvider executes a basic gorm read call
func DefaultReadCloudProvider(ctx context.Context, in *CloudProvider, db *gorm1.DB, fs *query1.FieldSelection) (*CloudProvider, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CloudProviderORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, fs, &CloudProviderORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CloudProviderORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	ormResponse := CloudProviderORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(CloudProviderORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type CloudProviderORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type CloudProviderORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type CloudProviderORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) error
}

func DefaultDeleteCloudProvider(ctx context.Context, in *CloudProvider, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CloudProviderORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&CloudProviderORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(CloudProviderORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type CloudProviderORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type CloudProviderORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteCloudProviderSet(ctx context.Context, in []*CloudProvider, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&CloudProviderORM{})).(CloudProviderORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	acctId, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return err
	}
	err = db.Where("account_id = ? AND id in (?)", acctId, keys).Delete(&CloudProviderORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&CloudProviderORM{})).(CloudProviderORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type CloudProviderORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*CloudProvider, *gorm1.DB) (*gorm1.DB, error)
}
type CloudProviderORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*CloudProvider, *gorm1.DB) error
}

// DefaultStrictUpdateCloudProvider clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateCloudProvider(ctx context.Context, in *CloudProvider, db *gorm1.DB) (*CloudProvider, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateCloudProvider")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	lockedRow := &CloudProviderORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(CloudProviderORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterRegions := RegionORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterRegions.CloudProviderId = new(int64)
	*filterRegions.CloudProviderId = ormObj.Id
	if err = db.Where(filterRegions).Delete(RegionORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CloudProviderORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CloudProviderORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type CloudProviderORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type CloudProviderORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type CloudProviderORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchCloudProvider executes a basic gorm update call with patch behavior
func DefaultPatchCloudProvider(ctx context.Context, in *CloudProvider, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*CloudProvider, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj CloudProvider
	var err error
	if hook, ok := interface{}(&pbObj).(CloudProviderWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadCloudProvider(ctx, &CloudProvider{Id: in.GetId()}, db, nil)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(CloudProviderWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskCloudProvider(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(CloudProviderWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateCloudProvider(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(CloudProviderWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type CloudProviderWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *CloudProvider, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type CloudProviderWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *CloudProvider, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type CloudProviderWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *CloudProvider, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type CloudProviderWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *CloudProvider, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetCloudProvider executes a bulk gorm update call with patch behavior
func DefaultPatchSetCloudProvider(ctx context.Context, objects []*CloudProvider, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*CloudProvider, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*CloudProvider, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchCloudProvider(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskCloudProvider patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskCloudProvider(ctx context.Context, patchee *CloudProvider, patcher *CloudProvider, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*CloudProvider, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"Provider" {
			patchee.Provider = patcher.Provider
			continue
		}
		if f == prefix+"Account" {
			patchee.Account = patcher.Account
			continue
		}
		if f == prefix+"Regions" {
			patchee.Regions = patcher.Regions
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListCloudProvider executes a gorm list call
func DefaultListCloudProvider(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*CloudProvider, error) {
	in := CloudProvider{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CloudProviderORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &CloudProviderORM{}, &CloudProvider{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CloudProviderORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []CloudProviderORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CloudProviderORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*CloudProvider{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type CloudProviderORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type CloudProviderORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type CloudProviderORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]CloudProviderORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateRegion executes a basic gorm create call
func DefaultCreateRegion(ctx context.Context, in *Region, db *gorm1.DB) (*Region, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(RegionORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(RegionORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type RegionORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type RegionORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadRegion executes a basic gorm read call
func DefaultReadRegion(ctx context.Context, in *Region, db *gorm1.DB, fs *query1.FieldSelection) (*Region, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(RegionORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, fs, &RegionORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(RegionORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	ormResponse := RegionORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(RegionORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type RegionORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type RegionORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type RegionORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) error
}

func DefaultDeleteRegion(ctx context.Context, in *Region, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(RegionORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&RegionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(RegionORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type RegionORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type RegionORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteRegionSet(ctx context.Context, in []*Region, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&RegionORM{})).(RegionORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	acctId, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return err
	}
	err = db.Where("account_id = ? AND id in (?)", acctId, keys).Delete(&RegionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&RegionORM{})).(RegionORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type RegionORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Region, *gorm1.DB) (*gorm1.DB, error)
}
type RegionORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Region, *gorm1.DB) error
}

// DefaultStrictUpdateRegion clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateRegion(ctx context.Context, in *Region, db *gorm1.DB) (*Region, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateRegion")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	lockedRow := &RegionORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(RegionORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterAwsServices := AwsServiceORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterAwsServices.RegionId = new(int64)
	*filterAwsServices.RegionId = ormObj.Id
	if err = db.Where(filterAwsServices).Delete(AwsServiceORM{}).Error; err != nil {
		return nil, err
	}
	filterStages := StageORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterStages.RegionId = new(int64)
	*filterStages.RegionId = ormObj.Id
	if err = db.Where(filterStages).Delete(StageORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(RegionORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(RegionORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type RegionORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type RegionORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type RegionORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchRegion executes a basic gorm update call with patch behavior
func DefaultPatchRegion(ctx context.Context, in *Region, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Region, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Region
	var err error
	if hook, ok := interface{}(&pbObj).(RegionWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadRegion(ctx, &Region{Id: in.GetId()}, db, nil)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(RegionWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskRegion(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(RegionWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateRegion(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(RegionWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type RegionWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Region, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type RegionWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Region, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type RegionWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Region, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type RegionWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Region, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetRegion executes a bulk gorm update call with patch behavior
func DefaultPatchSetRegion(ctx context.Context, objects []*Region, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*Region, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Region, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchRegion(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskRegion patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskRegion(ctx context.Context, patchee *Region, patcher *Region, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Region, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"Stages" {
			patchee.Stages = patcher.Stages
			continue
		}
		if f == prefix+"AwsServices" {
			patchee.AwsServices = patcher.AwsServices
			continue
		}
		if f == prefix+"ValueId" {
			patchee.ValueId = patcher.ValueId
			continue
		}
		if f == prefix+"CloudProviderId" {
			patchee.CloudProviderId = patcher.CloudProviderId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListRegion executes a gorm list call
func DefaultListRegion(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*Region, error) {
	in := Region{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(RegionORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &RegionORM{}, &Region{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(RegionORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []RegionORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(RegionORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Region{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type RegionORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type RegionORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type RegionORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]RegionORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateStage executes a basic gorm create call
func DefaultCreateStage(ctx context.Context, in *Stage, db *gorm1.DB) (*Stage, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StageORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StageORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type StageORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type StageORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadStage executes a basic gorm read call
func DefaultReadStage(ctx context.Context, in *Stage, db *gorm1.DB, fs *query1.FieldSelection) (*Stage, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(StageORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, fs, &StageORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StageORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	ormResponse := StageORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(StageORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type StageORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type StageORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type StageORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) error
}

func DefaultDeleteStage(ctx context.Context, in *Stage, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(StageORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&StageORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(StageORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type StageORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type StageORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteStageSet(ctx context.Context, in []*Stage, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&StageORM{})).(StageORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	acctId, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return err
	}
	err = db.Where("account_id = ? AND id in (?)", acctId, keys).Delete(&StageORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&StageORM{})).(StageORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type StageORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Stage, *gorm1.DB) (*gorm1.DB, error)
}
type StageORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Stage, *gorm1.DB) error
}

// DefaultStrictUpdateStage clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateStage(ctx context.Context, in *Stage, db *gorm1.DB) (*Stage, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateStage")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	lockedRow := &StageORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(StageORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterEnvironments := EnvironmentORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterEnvironments.StageId = new(int64)
	*filterEnvironments.StageId = ormObj.Id
	if err = db.Where(filterEnvironments).Delete(EnvironmentORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StageORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StageORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type StageORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type StageORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type StageORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchStage executes a basic gorm update call with patch behavior
func DefaultPatchStage(ctx context.Context, in *Stage, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Stage, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Stage
	var err error
	if hook, ok := interface{}(&pbObj).(StageWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadStage(ctx, &Stage{Id: in.GetId()}, db, nil)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(StageWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskStage(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(StageWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateStage(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(StageWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type StageWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Stage, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type StageWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Stage, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type StageWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Stage, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type StageWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Stage, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetStage executes a bulk gorm update call with patch behavior
func DefaultPatchSetStage(ctx context.Context, objects []*Stage, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*Stage, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Stage, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchStage(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskStage patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskStage(ctx context.Context, patchee *Stage, patcher *Stage, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Stage, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"Type" {
			patchee.Type = patcher.Type
			continue
		}
		if f == prefix+"Environments" {
			patchee.Environments = patcher.Environments
			continue
		}
		if f == prefix+"ValueId" {
			patchee.ValueId = patcher.ValueId
			continue
		}
		if f == prefix+"RegionId" {
			patchee.RegionId = patcher.RegionId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListStage executes a gorm list call
func DefaultListStage(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*Stage, error) {
	in := Stage{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StageORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &StageORM{}, &Stage{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StageORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []StageORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StageORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Stage{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type StageORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type StageORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type StageORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]StageORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateEnvironment executes a basic gorm create call
func DefaultCreateEnvironment(ctx context.Context, in *Environment, db *gorm1.DB) (*Environment, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EnvironmentORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EnvironmentORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type EnvironmentORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type EnvironmentORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadEnvironment executes a basic gorm read call
func DefaultReadEnvironment(ctx context.Context, in *Environment, db *gorm1.DB, fs *query1.FieldSelection) (*Environment, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(EnvironmentORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, fs, &EnvironmentORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EnvironmentORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	ormResponse := EnvironmentORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(EnvironmentORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type EnvironmentORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type EnvironmentORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type EnvironmentORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) error
}

func DefaultDeleteEnvironment(ctx context.Context, in *Environment, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(EnvironmentORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&EnvironmentORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(EnvironmentORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type EnvironmentORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type EnvironmentORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteEnvironmentSet(ctx context.Context, in []*Environment, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&EnvironmentORM{})).(EnvironmentORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	acctId, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return err
	}
	err = db.Where("account_id = ? AND id in (?)", acctId, keys).Delete(&EnvironmentORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&EnvironmentORM{})).(EnvironmentORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type EnvironmentORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Environment, *gorm1.DB) (*gorm1.DB, error)
}
type EnvironmentORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Environment, *gorm1.DB) error
}

// DefaultStrictUpdateEnvironment clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateEnvironment(ctx context.Context, in *Environment, db *gorm1.DB) (*Environment, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateEnvironment")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	lockedRow := &EnvironmentORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(EnvironmentORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterApplicationInstances := ApplicationInstanceORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterApplicationInstances.EnvironmentId = new(int64)
	*filterApplicationInstances.EnvironmentId = ormObj.Id
	if err = db.Where(filterApplicationInstances).Delete(ApplicationInstanceORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EnvironmentORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EnvironmentORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type EnvironmentORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type EnvironmentORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type EnvironmentORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchEnvironment executes a basic gorm update call with patch behavior
func DefaultPatchEnvironment(ctx context.Context, in *Environment, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Environment, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Environment
	var err error
	if hook, ok := interface{}(&pbObj).(EnvironmentWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadEnvironment(ctx, &Environment{Id: in.GetId()}, db, nil)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(EnvironmentWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskEnvironment(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(EnvironmentWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateEnvironment(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(EnvironmentWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type EnvironmentWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Environment, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type EnvironmentWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Environment, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type EnvironmentWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Environment, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type EnvironmentWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Environment, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetEnvironment executes a bulk gorm update call with patch behavior
func DefaultPatchSetEnvironment(ctx context.Context, objects []*Environment, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*Environment, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Environment, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchEnvironment(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskEnvironment patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskEnvironment(ctx context.Context, patchee *Environment, patcher *Environment, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Environment, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"ApplicationInstances" {
			patchee.ApplicationInstances = patcher.ApplicationInstances
			continue
		}
		if f == prefix+"ValueId" {
			patchee.ValueId = patcher.ValueId
			continue
		}
		if f == prefix+"StageId" {
			patchee.StageId = patcher.StageId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListEnvironment executes a gorm list call
func DefaultListEnvironment(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*Environment, error) {
	in := Environment{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EnvironmentORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &EnvironmentORM{}, &Environment{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EnvironmentORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []EnvironmentORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EnvironmentORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Environment{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type EnvironmentORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type EnvironmentORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type EnvironmentORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]EnvironmentORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateApplication executes a basic gorm create call
func DefaultCreateApplication(ctx context.Context, in *Application, db *gorm1.DB) (*Application, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ApplicationORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ApplicationORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ApplicationORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ApplicationORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadApplication executes a basic gorm read call
func DefaultReadApplication(ctx context.Context, in *Application, db *gorm1.DB, fs *query1.FieldSelection) (*Application, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ApplicationORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, fs, &ApplicationORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ApplicationORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	ormResponse := ApplicationORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ApplicationORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ApplicationORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type ApplicationORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type ApplicationORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) error
}

func DefaultDeleteApplication(ctx context.Context, in *Application, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ApplicationORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ApplicationORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ApplicationORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ApplicationORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ApplicationORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteApplicationSet(ctx context.Context, in []*Application, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ApplicationORM{})).(ApplicationORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	acctId, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return err
	}
	err = db.Where("account_id = ? AND id in (?)", acctId, keys).Delete(&ApplicationORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ApplicationORM{})).(ApplicationORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ApplicationORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Application, *gorm1.DB) (*gorm1.DB, error)
}
type ApplicationORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Application, *gorm1.DB) error
}

// DefaultStrictUpdateApplication clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateApplication(ctx context.Context, in *Application, db *gorm1.DB) (*Application, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateApplication")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	lockedRow := &ApplicationORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ApplicationORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterApplicationInstances := ApplicationInstanceORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterApplicationInstances.ApplicationId = new(int64)
	*filterApplicationInstances.ApplicationId = ormObj.Id
	if err = db.Where(filterApplicationInstances).Delete(ApplicationInstanceORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ApplicationORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ApplicationORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ApplicationORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ApplicationORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ApplicationORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchApplication executes a basic gorm update call with patch behavior
func DefaultPatchApplication(ctx context.Context, in *Application, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Application, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Application
	var err error
	if hook, ok := interface{}(&pbObj).(ApplicationWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadApplication(ctx, &Application{Id: in.GetId()}, db, nil)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ApplicationWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskApplication(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ApplicationWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateApplication(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ApplicationWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ApplicationWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Application, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ApplicationWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Application, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ApplicationWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Application, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ApplicationWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Application, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetApplication executes a bulk gorm update call with patch behavior
func DefaultPatchSetApplication(ctx context.Context, objects []*Application, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*Application, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Application, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchApplication(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskApplication patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskApplication(ctx context.Context, patchee *Application, patcher *Application, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Application, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"ApplicationInstances" {
			patchee.ApplicationInstances = patcher.ApplicationInstances
			continue
		}
		if f == prefix+"ValueId" {
			patchee.ValueId = patcher.ValueId
			continue
		}
		if f == prefix+"StageId" {
			patchee.StageId = patcher.StageId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListApplication executes a gorm list call
func DefaultListApplication(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*Application, error) {
	in := Application{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ApplicationORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &ApplicationORM{}, &Application{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ApplicationORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ApplicationORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ApplicationORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Application{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ApplicationORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ApplicationORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ApplicationORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]ApplicationORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateChartVersion executes a basic gorm create call
func DefaultCreateChartVersion(ctx context.Context, in *ChartVersion, db *gorm1.DB) (*ChartVersion, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ChartVersionORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ChartVersionORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ChartVersionORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ChartVersionORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadChartVersion executes a basic gorm read call
func DefaultReadChartVersion(ctx context.Context, in *ChartVersion, db *gorm1.DB, fs *query1.FieldSelection) (*ChartVersion, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ChartVersionORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, fs, &ChartVersionORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ChartVersionORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	ormResponse := ChartVersionORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ChartVersionORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ChartVersionORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type ChartVersionORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type ChartVersionORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) error
}

func DefaultDeleteChartVersion(ctx context.Context, in *ChartVersion, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ChartVersionORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ChartVersionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ChartVersionORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ChartVersionORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ChartVersionORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteChartVersionSet(ctx context.Context, in []*ChartVersion, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ChartVersionORM{})).(ChartVersionORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	acctId, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return err
	}
	err = db.Where("account_id = ? AND id in (?)", acctId, keys).Delete(&ChartVersionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ChartVersionORM{})).(ChartVersionORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ChartVersionORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*ChartVersion, *gorm1.DB) (*gorm1.DB, error)
}
type ChartVersionORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*ChartVersion, *gorm1.DB) error
}

// DefaultStrictUpdateChartVersion clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateChartVersion(ctx context.Context, in *ChartVersion, db *gorm1.DB) (*ChartVersion, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateChartVersion")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	lockedRow := &ChartVersionORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ChartVersionORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ChartVersionORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ChartVersionORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ChartVersionORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ChartVersionORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ChartVersionORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchChartVersion executes a basic gorm update call with patch behavior
func DefaultPatchChartVersion(ctx context.Context, in *ChartVersion, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*ChartVersion, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj ChartVersion
	var err error
	if hook, ok := interface{}(&pbObj).(ChartVersionWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadChartVersion(ctx, &ChartVersion{Id: in.GetId()}, db, nil)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ChartVersionWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskChartVersion(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ChartVersionWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateChartVersion(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ChartVersionWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ChartVersionWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *ChartVersion, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ChartVersionWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *ChartVersion, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ChartVersionWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *ChartVersion, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ChartVersionWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *ChartVersion, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetChartVersion executes a bulk gorm update call with patch behavior
func DefaultPatchSetChartVersion(ctx context.Context, objects []*ChartVersion, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*ChartVersion, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*ChartVersion, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchChartVersion(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskChartVersion patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskChartVersion(ctx context.Context, patchee *ChartVersion, patcher *ChartVersion, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*ChartVersion, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"Repo" {
			patchee.Repo = patcher.Repo
			continue
		}
		if f == prefix+"Version" {
			patchee.Version = patcher.Version
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListChartVersion executes a gorm list call
func DefaultListChartVersion(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*ChartVersion, error) {
	in := ChartVersion{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ChartVersionORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &ChartVersionORM{}, &ChartVersion{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ChartVersionORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ChartVersionORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ChartVersionORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*ChartVersion{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ChartVersionORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ChartVersionORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ChartVersionORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]ChartVersionORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateApplicationInstance executes a basic gorm create call
func DefaultCreateApplicationInstance(ctx context.Context, in *ApplicationInstance, db *gorm1.DB) (*ApplicationInstance, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ApplicationInstanceORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ApplicationInstanceORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ApplicationInstanceORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ApplicationInstanceORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadApplicationInstance executes a basic gorm read call
func DefaultReadApplicationInstance(ctx context.Context, in *ApplicationInstance, db *gorm1.DB, fs *query1.FieldSelection) (*ApplicationInstance, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ApplicationInstanceORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, fs, &ApplicationInstanceORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ApplicationInstanceORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	ormResponse := ApplicationInstanceORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ApplicationInstanceORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ApplicationInstanceORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type ApplicationInstanceORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type ApplicationInstanceORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) error
}

func DefaultDeleteApplicationInstance(ctx context.Context, in *ApplicationInstance, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ApplicationInstanceORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ApplicationInstanceORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ApplicationInstanceORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ApplicationInstanceORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ApplicationInstanceORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteApplicationInstanceSet(ctx context.Context, in []*ApplicationInstance, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ApplicationInstanceORM{})).(ApplicationInstanceORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	acctId, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return err
	}
	err = db.Where("account_id = ? AND id in (?)", acctId, keys).Delete(&ApplicationInstanceORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ApplicationInstanceORM{})).(ApplicationInstanceORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ApplicationInstanceORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*ApplicationInstance, *gorm1.DB) (*gorm1.DB, error)
}
type ApplicationInstanceORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*ApplicationInstance, *gorm1.DB) error
}

// DefaultStrictUpdateApplicationInstance clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateApplicationInstance(ctx context.Context, in *ApplicationInstance, db *gorm1.DB) (*ApplicationInstance, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateApplicationInstance")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	lockedRow := &ApplicationInstanceORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ApplicationInstanceORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterDeployment := DeploymentORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterDeployment.ApplicationInstanceId = new(int64)
	*filterDeployment.ApplicationInstanceId = ormObj.Id
	if err = db.Where(filterDeployment).Delete(DeploymentORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ApplicationInstanceORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ApplicationInstanceORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ApplicationInstanceORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ApplicationInstanceORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ApplicationInstanceORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchApplicationInstance executes a basic gorm update call with patch behavior
func DefaultPatchApplicationInstance(ctx context.Context, in *ApplicationInstance, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*ApplicationInstance, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj ApplicationInstance
	var err error
	if hook, ok := interface{}(&pbObj).(ApplicationInstanceWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadApplicationInstance(ctx, &ApplicationInstance{Id: in.GetId()}, db, nil)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ApplicationInstanceWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskApplicationInstance(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ApplicationInstanceWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateApplicationInstance(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ApplicationInstanceWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ApplicationInstanceWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *ApplicationInstance, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ApplicationInstanceWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *ApplicationInstance, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ApplicationInstanceWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *ApplicationInstance, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ApplicationInstanceWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *ApplicationInstance, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetApplicationInstance executes a bulk gorm update call with patch behavior
func DefaultPatchSetApplicationInstance(ctx context.Context, objects []*ApplicationInstance, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*ApplicationInstance, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*ApplicationInstance, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchApplicationInstance(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskApplicationInstance patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskApplicationInstance(ctx context.Context, patchee *ApplicationInstance, patcher *ApplicationInstance, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*ApplicationInstance, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	var updatedDeployment bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if !updatedDeployment && strings.HasPrefix(f, prefix+"Deployment.") {
			updatedDeployment = true
			if patcher.Deployment == nil {
				patchee.Deployment = nil
				continue
			}
			if patchee.Deployment == nil {
				patchee.Deployment = &Deployment{}
			}
			if o, err := DefaultApplyFieldMaskDeployment(ctx, patchee.Deployment, patcher.Deployment, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Deployment.", db); err != nil {
				return nil, err
			} else {
				patchee.Deployment = o
			}
			continue
		}
		if f == prefix+"Deployment" {
			updatedDeployment = true
			patchee.Deployment = patcher.Deployment
			continue
		}
		if f == prefix+"ValueId" {
			patchee.ValueId = patcher.ValueId
			continue
		}
		if f == prefix+"ApplicationId" {
			patchee.ApplicationId = patcher.ApplicationId
			continue
		}
		if f == prefix+"ChartVersionId" {
			patchee.ChartVersionId = patcher.ChartVersionId
			continue
		}
		if f == prefix+"EnvironmentId" {
			patchee.EnvironmentId = patcher.EnvironmentId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListApplicationInstance executes a gorm list call
func DefaultListApplicationInstance(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*ApplicationInstance, error) {
	in := ApplicationInstance{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ApplicationInstanceORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &ApplicationInstanceORM{}, &ApplicationInstance{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ApplicationInstanceORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ApplicationInstanceORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ApplicationInstanceORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*ApplicationInstance{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ApplicationInstanceORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ApplicationInstanceORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ApplicationInstanceORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]ApplicationInstanceORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateVault executes a basic gorm create call
func DefaultCreateVault(ctx context.Context, in *Vault, db *gorm1.DB) (*Vault, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VaultORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VaultORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type VaultORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type VaultORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadVault executes a basic gorm read call
func DefaultReadVault(ctx context.Context, in *Vault, db *gorm1.DB, fs *query1.FieldSelection) (*Vault, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(VaultORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, fs, &VaultORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VaultORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	ormResponse := VaultORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(VaultORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type VaultORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type VaultORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type VaultORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) error
}

func DefaultDeleteVault(ctx context.Context, in *Vault, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(VaultORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&VaultORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(VaultORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type VaultORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type VaultORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteVaultSet(ctx context.Context, in []*Vault, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&VaultORM{})).(VaultORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	acctId, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return err
	}
	err = db.Where("account_id = ? AND id in (?)", acctId, keys).Delete(&VaultORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&VaultORM{})).(VaultORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type VaultORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Vault, *gorm1.DB) (*gorm1.DB, error)
}
type VaultORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Vault, *gorm1.DB) error
}

// DefaultStrictUpdateVault clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateVault(ctx context.Context, in *Vault, db *gorm1.DB) (*Vault, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateVault")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	lockedRow := &VaultORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(VaultORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterSecrets := SecretORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterSecrets.VaultId = new(int64)
	*filterSecrets.VaultId = ormObj.Id
	if err = db.Where(filterSecrets).Delete(SecretORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VaultORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VaultORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type VaultORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type VaultORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type VaultORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchVault executes a basic gorm update call with patch behavior
func DefaultPatchVault(ctx context.Context, in *Vault, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Vault, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Vault
	var err error
	if hook, ok := interface{}(&pbObj).(VaultWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadVault(ctx, &Vault{Id: in.GetId()}, db, nil)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(VaultWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskVault(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(VaultWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateVault(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(VaultWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type VaultWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Vault, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type VaultWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Vault, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type VaultWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Vault, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type VaultWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Vault, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetVault executes a bulk gorm update call with patch behavior
func DefaultPatchSetVault(ctx context.Context, objects []*Vault, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*Vault, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Vault, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchVault(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskVault patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskVault(ctx context.Context, patchee *Vault, patcher *Vault, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Vault, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"Secrets" {
			patchee.Secrets = patcher.Secrets
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListVault executes a gorm list call
func DefaultListVault(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*Vault, error) {
	in := Vault{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VaultORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &VaultORM{}, &Vault{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VaultORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []VaultORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VaultORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Vault{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type VaultORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type VaultORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type VaultORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]VaultORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateSecret executes a basic gorm create call
func DefaultCreateSecret(ctx context.Context, in *Secret, db *gorm1.DB) (*Secret, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SecretORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SecretORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type SecretORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type SecretORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadSecret executes a basic gorm read call
func DefaultReadSecret(ctx context.Context, in *Secret, db *gorm1.DB, fs *query1.FieldSelection) (*Secret, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(SecretORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, fs, &SecretORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SecretORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	ormResponse := SecretORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(SecretORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type SecretORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type SecretORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type SecretORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) error
}

func DefaultDeleteSecret(ctx context.Context, in *Secret, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(SecretORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&SecretORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(SecretORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type SecretORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type SecretORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteSecretSet(ctx context.Context, in []*Secret, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&SecretORM{})).(SecretORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	acctId, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return err
	}
	err = db.Where("account_id = ? AND id in (?)", acctId, keys).Delete(&SecretORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&SecretORM{})).(SecretORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type SecretORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Secret, *gorm1.DB) (*gorm1.DB, error)
}
type SecretORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Secret, *gorm1.DB) error
}

// DefaultStrictUpdateSecret clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateSecret(ctx context.Context, in *Secret, db *gorm1.DB) (*Secret, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateSecret")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	lockedRow := &SecretORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(SecretORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(SecretORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SecretORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type SecretORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type SecretORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type SecretORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchSecret executes a basic gorm update call with patch behavior
func DefaultPatchSecret(ctx context.Context, in *Secret, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Secret, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Secret
	var err error
	if hook, ok := interface{}(&pbObj).(SecretWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadSecret(ctx, &Secret{Id: in.GetId()}, db, nil)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(SecretWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskSecret(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(SecretWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateSecret(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(SecretWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type SecretWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Secret, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type SecretWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Secret, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type SecretWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Secret, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type SecretWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Secret, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetSecret executes a bulk gorm update call with patch behavior
func DefaultPatchSetSecret(ctx context.Context, objects []*Secret, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*Secret, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Secret, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchSecret(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskSecret patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskSecret(ctx context.Context, patchee *Secret, patcher *Secret, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Secret, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"Path" {
			patchee.Path = patcher.Path
			continue
		}
		if f == prefix+"Type" {
			patchee.Type = patcher.Type
			continue
		}
		if f == prefix+"Key" {
			patchee.Key = patcher.Key
			continue
		}
		if f == prefix+"VaultId" {
			patchee.VaultId = patcher.VaultId
			continue
		}
		if f == prefix+"ValueId" {
			patchee.ValueId = patcher.ValueId
			continue
		}
		if f == prefix+"AwsRdsInstanceId" {
			patchee.AwsRdsInstanceId = patcher.AwsRdsInstanceId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListSecret executes a gorm list call
func DefaultListSecret(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*Secret, error) {
	in := Secret{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SecretORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &SecretORM{}, &Secret{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SecretORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []SecretORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SecretORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Secret{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type SecretORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type SecretORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type SecretORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]SecretORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateAwsService executes a basic gorm create call
func DefaultCreateAwsService(ctx context.Context, in *AwsService, db *gorm1.DB) (*AwsService, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AwsServiceORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AwsServiceORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type AwsServiceORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AwsServiceORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadAwsService executes a basic gorm read call
func DefaultReadAwsService(ctx context.Context, in *AwsService, db *gorm1.DB, fs *query1.FieldSelection) (*AwsService, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AwsServiceORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, fs, &AwsServiceORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AwsServiceORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	ormResponse := AwsServiceORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(AwsServiceORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type AwsServiceORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type AwsServiceORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type AwsServiceORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) error
}

func DefaultDeleteAwsService(ctx context.Context, in *AwsService, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AwsServiceORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&AwsServiceORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(AwsServiceORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type AwsServiceORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AwsServiceORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteAwsServiceSet(ctx context.Context, in []*AwsService, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&AwsServiceORM{})).(AwsServiceORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	acctId, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return err
	}
	err = db.Where("account_id = ? AND id in (?)", acctId, keys).Delete(&AwsServiceORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&AwsServiceORM{})).(AwsServiceORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type AwsServiceORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*AwsService, *gorm1.DB) (*gorm1.DB, error)
}
type AwsServiceORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*AwsService, *gorm1.DB) error
}

// DefaultStrictUpdateAwsService clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateAwsService(ctx context.Context, in *AwsService, db *gorm1.DB) (*AwsService, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateAwsService")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	lockedRow := &AwsServiceORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(AwsServiceORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterAwsRdsInstances := AwsRdsInstanceORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterAwsRdsInstances.AwsServiceId = new(int64)
	*filterAwsRdsInstances.AwsServiceId = ormObj.Id
	if err = db.Where(filterAwsRdsInstances).Delete(AwsRdsInstanceORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AwsServiceORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AwsServiceORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type AwsServiceORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AwsServiceORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AwsServiceORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchAwsService executes a basic gorm update call with patch behavior
func DefaultPatchAwsService(ctx context.Context, in *AwsService, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*AwsService, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj AwsService
	var err error
	if hook, ok := interface{}(&pbObj).(AwsServiceWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadAwsService(ctx, &AwsService{Id: in.GetId()}, db, nil)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(AwsServiceWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskAwsService(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(AwsServiceWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateAwsService(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(AwsServiceWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type AwsServiceWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *AwsService, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type AwsServiceWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *AwsService, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type AwsServiceWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *AwsService, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type AwsServiceWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *AwsService, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetAwsService executes a bulk gorm update call with patch behavior
func DefaultPatchSetAwsService(ctx context.Context, objects []*AwsService, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*AwsService, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*AwsService, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchAwsService(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskAwsService patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskAwsService(ctx context.Context, patchee *AwsService, patcher *AwsService, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*AwsService, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"AwsRdsInstances" {
			patchee.AwsRdsInstances = patcher.AwsRdsInstances
			continue
		}
		if f == prefix+"RegionId" {
			patchee.RegionId = patcher.RegionId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListAwsService executes a gorm list call
func DefaultListAwsService(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*AwsService, error) {
	in := AwsService{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AwsServiceORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &AwsServiceORM{}, &AwsService{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AwsServiceORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []AwsServiceORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AwsServiceORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*AwsService{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type AwsServiceORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type AwsServiceORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type AwsServiceORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]AwsServiceORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateAwsRdsInstance executes a basic gorm create call
func DefaultCreateAwsRdsInstance(ctx context.Context, in *AwsRdsInstance, db *gorm1.DB) (*AwsRdsInstance, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AwsRdsInstanceORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AwsRdsInstanceORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type AwsRdsInstanceORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AwsRdsInstanceORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadAwsRdsInstance executes a basic gorm read call
func DefaultReadAwsRdsInstance(ctx context.Context, in *AwsRdsInstance, db *gorm1.DB, fs *query1.FieldSelection) (*AwsRdsInstance, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AwsRdsInstanceORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, fs, &AwsRdsInstanceORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AwsRdsInstanceORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	ormResponse := AwsRdsInstanceORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(AwsRdsInstanceORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type AwsRdsInstanceORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type AwsRdsInstanceORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type AwsRdsInstanceORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) error
}

func DefaultDeleteAwsRdsInstance(ctx context.Context, in *AwsRdsInstance, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AwsRdsInstanceORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&AwsRdsInstanceORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(AwsRdsInstanceORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type AwsRdsInstanceORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AwsRdsInstanceORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteAwsRdsInstanceSet(ctx context.Context, in []*AwsRdsInstance, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&AwsRdsInstanceORM{})).(AwsRdsInstanceORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	acctId, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return err
	}
	err = db.Where("account_id = ? AND id in (?)", acctId, keys).Delete(&AwsRdsInstanceORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&AwsRdsInstanceORM{})).(AwsRdsInstanceORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type AwsRdsInstanceORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*AwsRdsInstance, *gorm1.DB) (*gorm1.DB, error)
}
type AwsRdsInstanceORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*AwsRdsInstance, *gorm1.DB) error
}

// DefaultStrictUpdateAwsRdsInstance clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateAwsRdsInstance(ctx context.Context, in *AwsRdsInstance, db *gorm1.DB) (*AwsRdsInstance, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateAwsRdsInstance")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	lockedRow := &AwsRdsInstanceORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(AwsRdsInstanceORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterDatabasePassword := SecretORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterDatabasePassword.AwsRdsInstanceId = new(int64)
	*filterDatabasePassword.AwsRdsInstanceId = ormObj.Id
	if err = db.Where(filterDatabasePassword).Delete(SecretORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AwsRdsInstanceORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AwsRdsInstanceORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type AwsRdsInstanceORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AwsRdsInstanceORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AwsRdsInstanceORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchAwsRdsInstance executes a basic gorm update call with patch behavior
func DefaultPatchAwsRdsInstance(ctx context.Context, in *AwsRdsInstance, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*AwsRdsInstance, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj AwsRdsInstance
	var err error
	if hook, ok := interface{}(&pbObj).(AwsRdsInstanceWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadAwsRdsInstance(ctx, &AwsRdsInstance{Id: in.GetId()}, db, nil)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(AwsRdsInstanceWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskAwsRdsInstance(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(AwsRdsInstanceWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateAwsRdsInstance(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(AwsRdsInstanceWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type AwsRdsInstanceWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *AwsRdsInstance, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type AwsRdsInstanceWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *AwsRdsInstance, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type AwsRdsInstanceWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *AwsRdsInstance, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type AwsRdsInstanceWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *AwsRdsInstance, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetAwsRdsInstance executes a bulk gorm update call with patch behavior
func DefaultPatchSetAwsRdsInstance(ctx context.Context, objects []*AwsRdsInstance, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*AwsRdsInstance, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*AwsRdsInstance, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchAwsRdsInstance(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskAwsRdsInstance patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskAwsRdsInstance(ctx context.Context, patchee *AwsRdsInstance, patcher *AwsRdsInstance, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*AwsRdsInstance, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	var updatedDatabasePassword bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"DatabaseHost" {
			patchee.DatabaseHost = patcher.DatabaseHost
			continue
		}
		if f == prefix+"DatabaseName" {
			patchee.DatabaseName = patcher.DatabaseName
			continue
		}
		if f == prefix+"DatabaseUser" {
			patchee.DatabaseUser = patcher.DatabaseUser
			continue
		}
		if !updatedDatabasePassword && strings.HasPrefix(f, prefix+"DatabasePassword.") {
			updatedDatabasePassword = true
			if patcher.DatabasePassword == nil {
				patchee.DatabasePassword = nil
				continue
			}
			if patchee.DatabasePassword == nil {
				patchee.DatabasePassword = &Secret{}
			}
			if o, err := DefaultApplyFieldMaskSecret(ctx, patchee.DatabasePassword, patcher.DatabasePassword, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"DatabasePassword.", db); err != nil {
				return nil, err
			} else {
				patchee.DatabasePassword = o
			}
			continue
		}
		if f == prefix+"DatabasePassword" {
			updatedDatabasePassword = true
			patchee.DatabasePassword = patcher.DatabasePassword
			continue
		}
		if f == prefix+"AwsServiceId" {
			patchee.AwsServiceId = patcher.AwsServiceId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListAwsRdsInstance executes a gorm list call
func DefaultListAwsRdsInstance(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*AwsRdsInstance, error) {
	in := AwsRdsInstance{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AwsRdsInstanceORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &AwsRdsInstanceORM{}, &AwsRdsInstance{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AwsRdsInstanceORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []AwsRdsInstanceORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AwsRdsInstanceORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*AwsRdsInstance{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type AwsRdsInstanceORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type AwsRdsInstanceORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type AwsRdsInstanceORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]AwsRdsInstanceORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateValue executes a basic gorm create call
func DefaultCreateValue(ctx context.Context, in *Value, db *gorm1.DB) (*Value, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ValueORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ValueORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ValueORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ValueORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadValue executes a basic gorm read call
func DefaultReadValue(ctx context.Context, in *Value, db *gorm1.DB, fs *query1.FieldSelection) (*Value, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ValueORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, fs, &ValueORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ValueORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	ormResponse := ValueORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ValueORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ValueORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type ValueORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type ValueORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) error
}

func DefaultDeleteValue(ctx context.Context, in *Value, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ValueORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ValueORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ValueORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ValueORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ValueORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteValueSet(ctx context.Context, in []*Value, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ValueORM{})).(ValueORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	acctId, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return err
	}
	err = db.Where("account_id = ? AND id in (?)", acctId, keys).Delete(&ValueORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ValueORM{})).(ValueORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ValueORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Value, *gorm1.DB) (*gorm1.DB, error)
}
type ValueORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Value, *gorm1.DB) error
}

// DefaultStrictUpdateValue clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateValue(ctx context.Context, in *Value, db *gorm1.DB) (*Value, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateValue")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	lockedRow := &ValueORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ValueORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ValueORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ValueORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ValueORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ValueORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ValueORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchValue executes a basic gorm update call with patch behavior
func DefaultPatchValue(ctx context.Context, in *Value, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Value, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Value
	var err error
	if hook, ok := interface{}(&pbObj).(ValueWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadValue(ctx, &Value{Id: in.GetId()}, db, nil)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ValueWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskValue(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ValueWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateValue(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ValueWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ValueWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Value, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ValueWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Value, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ValueWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Value, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ValueWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Value, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetValue executes a bulk gorm update call with patch behavior
func DefaultPatchSetValue(ctx context.Context, objects []*Value, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*Value, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Value, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchValue(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskValue patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskValue(ctx context.Context, patchee *Value, patcher *Value, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Value, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	var updatedKeys bool
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if !updatedKeys && strings.HasPrefix(f, prefix+"Keys") {
			patchee.Keys = patcher.Keys
			updatedKeys = true
			continue
		}
		if f == prefix+"AwsRdsInstanceId" {
			patchee.AwsRdsInstanceId = patcher.AwsRdsInstanceId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListValue executes a gorm list call
func DefaultListValue(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*Value, error) {
	in := Value{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ValueORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &ValueORM{}, &Value{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ValueORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ValueORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ValueORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Value{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ValueORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ValueORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ValueORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]ValueORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateArtifact executes a basic gorm create call
func DefaultCreateArtifact(ctx context.Context, in *Artifact, db *gorm1.DB) (*Artifact, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ArtifactORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ArtifactORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ArtifactORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ArtifactORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadArtifact executes a basic gorm read call
func DefaultReadArtifact(ctx context.Context, in *Artifact, db *gorm1.DB, fs *query1.FieldSelection) (*Artifact, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ArtifactORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, fs, &ArtifactORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ArtifactORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	ormResponse := ArtifactORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ArtifactORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ArtifactORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type ArtifactORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type ArtifactORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) error
}

func DefaultDeleteArtifact(ctx context.Context, in *Artifact, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ArtifactORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ArtifactORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ArtifactORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ArtifactORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ArtifactORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteArtifactSet(ctx context.Context, in []*Artifact, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ArtifactORM{})).(ArtifactORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	acctId, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return err
	}
	err = db.Where("account_id = ? AND id in (?)", acctId, keys).Delete(&ArtifactORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ArtifactORM{})).(ArtifactORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ArtifactORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Artifact, *gorm1.DB) (*gorm1.DB, error)
}
type ArtifactORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Artifact, *gorm1.DB) error
}

// DefaultStrictUpdateArtifact clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateArtifact(ctx context.Context, in *Artifact, db *gorm1.DB) (*Artifact, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateArtifact")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	lockedRow := &ArtifactORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ArtifactORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ArtifactORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ArtifactORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ArtifactORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ArtifactORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ArtifactORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchArtifact executes a basic gorm update call with patch behavior
func DefaultPatchArtifact(ctx context.Context, in *Artifact, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Artifact, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Artifact
	var err error
	if hook, ok := interface{}(&pbObj).(ArtifactWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadArtifact(ctx, &Artifact{Id: in.GetId()}, db, nil)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ArtifactWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskArtifact(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ArtifactWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateArtifact(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ArtifactWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ArtifactWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Artifact, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ArtifactWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Artifact, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ArtifactWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Artifact, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ArtifactWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Artifact, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetArtifact executes a bulk gorm update call with patch behavior
func DefaultPatchSetArtifact(ctx context.Context, objects []*Artifact, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*Artifact, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Artifact, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchArtifact(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskArtifact patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskArtifact(ctx context.Context, patchee *Artifact, patcher *Artifact, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Artifact, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"Repo" {
			patchee.Repo = patcher.Repo
			continue
		}
		if f == prefix+"Commit" {
			patchee.Commit = patcher.Commit
			continue
		}
		if f == prefix+"ChartVersionId" {
			patchee.ChartVersionId = patcher.ChartVersionId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListArtifact executes a gorm list call
func DefaultListArtifact(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*Artifact, error) {
	in := Artifact{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ArtifactORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &ArtifactORM{}, &Artifact{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ArtifactORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ArtifactORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ArtifactORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Artifact{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ArtifactORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ArtifactORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ArtifactORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]ArtifactORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateKubeCluster executes a basic gorm create call
func DefaultCreateKubeCluster(ctx context.Context, in *KubeCluster, db *gorm1.DB) (*KubeCluster, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(KubeClusterORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(KubeClusterORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type KubeClusterORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type KubeClusterORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadKubeCluster executes a basic gorm read call
func DefaultReadKubeCluster(ctx context.Context, in *KubeCluster, db *gorm1.DB, fs *query1.FieldSelection) (*KubeCluster, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(KubeClusterORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, fs, &KubeClusterORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(KubeClusterORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	ormResponse := KubeClusterORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(KubeClusterORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type KubeClusterORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type KubeClusterORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type KubeClusterORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) error
}

func DefaultDeleteKubeCluster(ctx context.Context, in *KubeCluster, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(KubeClusterORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&KubeClusterORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(KubeClusterORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type KubeClusterORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type KubeClusterORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteKubeClusterSet(ctx context.Context, in []*KubeCluster, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&KubeClusterORM{})).(KubeClusterORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	acctId, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return err
	}
	err = db.Where("account_id = ? AND id in (?)", acctId, keys).Delete(&KubeClusterORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&KubeClusterORM{})).(KubeClusterORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type KubeClusterORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*KubeCluster, *gorm1.DB) (*gorm1.DB, error)
}
type KubeClusterORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*KubeCluster, *gorm1.DB) error
}

// DefaultStrictUpdateKubeCluster clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateKubeCluster(ctx context.Context, in *KubeCluster, db *gorm1.DB) (*KubeCluster, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateKubeCluster")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	lockedRow := &KubeClusterORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(KubeClusterORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(KubeClusterORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(KubeClusterORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type KubeClusterORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type KubeClusterORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type KubeClusterORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchKubeCluster executes a basic gorm update call with patch behavior
func DefaultPatchKubeCluster(ctx context.Context, in *KubeCluster, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*KubeCluster, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj KubeCluster
	var err error
	if hook, ok := interface{}(&pbObj).(KubeClusterWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadKubeCluster(ctx, &KubeCluster{Id: in.GetId()}, db, nil)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(KubeClusterWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskKubeCluster(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(KubeClusterWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateKubeCluster(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(KubeClusterWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type KubeClusterWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *KubeCluster, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type KubeClusterWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *KubeCluster, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type KubeClusterWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *KubeCluster, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type KubeClusterWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *KubeCluster, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetKubeCluster executes a bulk gorm update call with patch behavior
func DefaultPatchSetKubeCluster(ctx context.Context, objects []*KubeCluster, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*KubeCluster, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*KubeCluster, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchKubeCluster(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskKubeCluster patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskKubeCluster(ctx context.Context, patchee *KubeCluster, patcher *KubeCluster, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*KubeCluster, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListKubeCluster executes a gorm list call
func DefaultListKubeCluster(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*KubeCluster, error) {
	in := KubeCluster{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(KubeClusterORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &KubeClusterORM{}, &KubeCluster{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(KubeClusterORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []KubeClusterORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(KubeClusterORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*KubeCluster{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type KubeClusterORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type KubeClusterORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type KubeClusterORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]KubeClusterORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateDeployment executes a basic gorm create call
func DefaultCreateDeployment(ctx context.Context, in *Deployment, db *gorm1.DB) (*Deployment, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DeploymentORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DeploymentORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type DeploymentORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type DeploymentORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadDeployment executes a basic gorm read call
func DefaultReadDeployment(ctx context.Context, in *Deployment, db *gorm1.DB, fs *query1.FieldSelection) (*Deployment, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(DeploymentORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, fs, &DeploymentORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DeploymentORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	ormResponse := DeploymentORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(DeploymentORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type DeploymentORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type DeploymentORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type DeploymentORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) error
}

func DefaultDeleteDeployment(ctx context.Context, in *Deployment, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(DeploymentORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&DeploymentORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(DeploymentORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type DeploymentORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type DeploymentORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteDeploymentSet(ctx context.Context, in []*Deployment, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&DeploymentORM{})).(DeploymentORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	acctId, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return err
	}
	err = db.Where("account_id = ? AND id in (?)", acctId, keys).Delete(&DeploymentORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&DeploymentORM{})).(DeploymentORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type DeploymentORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Deployment, *gorm1.DB) (*gorm1.DB, error)
}
type DeploymentORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Deployment, *gorm1.DB) error
}

// DefaultStrictUpdateDeployment clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateDeployment(ctx context.Context, in *Deployment, db *gorm1.DB) (*Deployment, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateDeployment")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	lockedRow := &DeploymentORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(DeploymentORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(DeploymentORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DeploymentORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type DeploymentORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type DeploymentORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type DeploymentORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchDeployment executes a basic gorm update call with patch behavior
func DefaultPatchDeployment(ctx context.Context, in *Deployment, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Deployment, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Deployment
	var err error
	if hook, ok := interface{}(&pbObj).(DeploymentWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadDeployment(ctx, &Deployment{Id: in.GetId()}, db, nil)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(DeploymentWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskDeployment(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(DeploymentWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateDeployment(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(DeploymentWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type DeploymentWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Deployment, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type DeploymentWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Deployment, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type DeploymentWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Deployment, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type DeploymentWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Deployment, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetDeployment executes a bulk gorm update call with patch behavior
func DefaultPatchSetDeployment(ctx context.Context, objects []*Deployment, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*Deployment, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Deployment, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchDeployment(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskDeployment patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskDeployment(ctx context.Context, patchee *Deployment, patcher *Deployment, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Deployment, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	var updatedArtifact bool
	var updatedKubeCluster bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if !updatedArtifact && strings.HasPrefix(f, prefix+"Artifact.") {
			updatedArtifact = true
			if patcher.Artifact == nil {
				patchee.Artifact = nil
				continue
			}
			if patchee.Artifact == nil {
				patchee.Artifact = &Artifact{}
			}
			if o, err := DefaultApplyFieldMaskArtifact(ctx, patchee.Artifact, patcher.Artifact, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Artifact.", db); err != nil {
				return nil, err
			} else {
				patchee.Artifact = o
			}
			continue
		}
		if f == prefix+"Artifact" {
			updatedArtifact = true
			patchee.Artifact = patcher.Artifact
			continue
		}
		if f == prefix+"ArtifactId" {
			patchee.ArtifactId = patcher.ArtifactId
			continue
		}
		if !updatedKubeCluster && strings.HasPrefix(f, prefix+"KubeCluster.") {
			updatedKubeCluster = true
			if patcher.KubeCluster == nil {
				patchee.KubeCluster = nil
				continue
			}
			if patchee.KubeCluster == nil {
				patchee.KubeCluster = &KubeCluster{}
			}
			if o, err := DefaultApplyFieldMaskKubeCluster(ctx, patchee.KubeCluster, patcher.KubeCluster, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"KubeCluster.", db); err != nil {
				return nil, err
			} else {
				patchee.KubeCluster = o
			}
			continue
		}
		if f == prefix+"KubeCluster" {
			updatedKubeCluster = true
			patchee.KubeCluster = patcher.KubeCluster
			continue
		}
		if f == prefix+"KubeClusterId" {
			patchee.KubeClusterId = patcher.KubeClusterId
			continue
		}
		if f == prefix+"ApplicationInstanceId" {
			patchee.ApplicationInstanceId = patcher.ApplicationInstanceId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListDeployment executes a gorm list call
func DefaultListDeployment(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*Deployment, error) {
	in := Deployment{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DeploymentORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &DeploymentORM{}, &Deployment{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DeploymentORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []DeploymentORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DeploymentORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Deployment{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type DeploymentORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type DeploymentORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type DeploymentORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]DeploymentORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}
type CloudProvidersDefaultServer struct {
}

// Create ...
func (m *CloudProvidersDefaultServer) Create(ctx context.Context, in *CreateCloudProviderRequest) (*CreateCloudProviderResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(CloudProvidersCloudProviderWithBeforeCreate); ok {
		var err error
		if db, err = custom.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateCloudProvider(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreateCloudProviderResponse{Result: res}
	if custom, ok := interface{}(in).(CloudProvidersCloudProviderWithAfterCreate); ok {
		var err error
		if err = custom.AfterCreate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// CloudProvidersCloudProviderWithBeforeCreate called before DefaultCreateCloudProvider in the default Create handler
type CloudProvidersCloudProviderWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// CloudProvidersCloudProviderWithAfterCreate called before DefaultCreateCloudProvider in the default Create handler
type CloudProvidersCloudProviderWithAfterCreate interface {
	AfterCreate(context.Context, *CreateCloudProviderResponse, *gorm1.DB) error
}

// Read ...
func (m *CloudProvidersDefaultServer) Read(ctx context.Context, in *ReadCloudProviderRequest) (*ReadCloudProviderResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(CloudProvidersCloudProviderWithBeforeRead); ok {
		var err error
		if db, err = custom.BeforeRead(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadCloudProvider(ctx, &CloudProvider{Id: in.GetId()}, db, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ReadCloudProviderResponse{Result: res}
	if custom, ok := interface{}(in).(CloudProvidersCloudProviderWithAfterRead); ok {
		var err error
		if err = custom.AfterRead(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// CloudProvidersCloudProviderWithBeforeRead called before DefaultReadCloudProvider in the default Read handler
type CloudProvidersCloudProviderWithBeforeRead interface {
	BeforeRead(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// CloudProvidersCloudProviderWithAfterRead called before DefaultReadCloudProvider in the default Read handler
type CloudProvidersCloudProviderWithAfterRead interface {
	AfterRead(context.Context, *ReadCloudProviderResponse, *gorm1.DB) error
}

// Update ...
func (m *CloudProvidersDefaultServer) Update(ctx context.Context, in *UpdateCloudProviderRequest) (*UpdateCloudProviderResponse, error) {
	var err error
	var res *CloudProvider
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(CloudProvidersCloudProviderWithBeforeUpdate); ok {
		var err error
		if db, err = custom.BeforeUpdate(ctx, db); err != nil {
			return nil, err
		}
	}
	if in.GetFields() == nil {
		res, err = DefaultStrictUpdateCloudProvider(ctx, in.GetPayload(), db)
	} else {
		res, err = DefaultPatchCloudProvider(ctx, in.GetPayload(), in.GetFields(), db)
	}
	if err != nil {
		return nil, err
	}
	out := &UpdateCloudProviderResponse{Result: res}
	if custom, ok := interface{}(in).(CloudProvidersCloudProviderWithAfterUpdate); ok {
		var err error
		if err = custom.AfterUpdate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// CloudProvidersCloudProviderWithBeforeUpdate called before DefaultUpdateCloudProvider in the default Update handler
type CloudProvidersCloudProviderWithBeforeUpdate interface {
	BeforeUpdate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// CloudProvidersCloudProviderWithAfterUpdate called before DefaultUpdateCloudProvider in the default Update handler
type CloudProvidersCloudProviderWithAfterUpdate interface {
	AfterUpdate(context.Context, *UpdateCloudProviderResponse, *gorm1.DB) error
}

// Delete ...
func (m *CloudProvidersDefaultServer) Delete(ctx context.Context, in *DeleteCloudProviderRequest) (*DeleteCloudProviderResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(CloudProvidersCloudProviderWithBeforeDelete); ok {
		var err error
		if db, err = custom.BeforeDelete(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteCloudProvider(ctx, &CloudProvider{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &DeleteCloudProviderResponse{}
	if custom, ok := interface{}(in).(CloudProvidersCloudProviderWithAfterDelete); ok {
		var err error
		if err = custom.AfterDelete(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// CloudProvidersCloudProviderWithBeforeDelete called before DefaultDeleteCloudProvider in the default Delete handler
type CloudProvidersCloudProviderWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// CloudProvidersCloudProviderWithAfterDelete called before DefaultDeleteCloudProvider in the default Delete handler
type CloudProvidersCloudProviderWithAfterDelete interface {
	AfterDelete(context.Context, *DeleteCloudProviderResponse, *gorm1.DB) error
}

// List ...
func (m *CloudProvidersDefaultServer) List(ctx context.Context, in *ListCloudProviderRequest) (*ListCloudProvidersResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(CloudProvidersCloudProviderWithBeforeList); ok {
		var err error
		if db, err = custom.BeforeList(ctx, db); err != nil {
			return nil, err
		}
	}
	pagedRequest := false
	if in.GetPaging().GetLimit() >= 1 {
		in.Paging.Limit++
		pagedRequest = true
	}
	res, err := DefaultListCloudProvider(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	var resPaging *query1.PageInfo
	if pagedRequest {
		var offset int32
		var size int32 = int32(len(res))
		if size == in.GetPaging().GetLimit() {
			size--
			res = res[:size]
			offset = in.GetPaging().GetOffset() + size
		}
		resPaging = &query1.PageInfo{Offset: offset}
	}
	out := &ListCloudProvidersResponse{Results: res, Page: resPaging}
	if custom, ok := interface{}(in).(CloudProvidersCloudProviderWithAfterList); ok {
		var err error
		if err = custom.AfterList(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// CloudProvidersCloudProviderWithBeforeList called before DefaultListCloudProvider in the default List handler
type CloudProvidersCloudProviderWithBeforeList interface {
	BeforeList(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// CloudProvidersCloudProviderWithAfterList called before DefaultListCloudProvider in the default List handler
type CloudProvidersCloudProviderWithAfterList interface {
	AfterList(context.Context, *ListCloudProvidersResponse, *gorm1.DB) error
}
type RegionsDefaultServer struct {
}

// Create ...
func (m *RegionsDefaultServer) Create(ctx context.Context, in *CreateRegionRequest) (*CreateRegionResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(RegionsRegionWithBeforeCreate); ok {
		var err error
		if db, err = custom.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateRegion(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreateRegionResponse{Result: res}
	if custom, ok := interface{}(in).(RegionsRegionWithAfterCreate); ok {
		var err error
		if err = custom.AfterCreate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// RegionsRegionWithBeforeCreate called before DefaultCreateRegion in the default Create handler
type RegionsRegionWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// RegionsRegionWithAfterCreate called before DefaultCreateRegion in the default Create handler
type RegionsRegionWithAfterCreate interface {
	AfterCreate(context.Context, *CreateRegionResponse, *gorm1.DB) error
}

// Read ...
func (m *RegionsDefaultServer) Read(ctx context.Context, in *ReadRegionRequest) (*ReadRegionResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(RegionsRegionWithBeforeRead); ok {
		var err error
		if db, err = custom.BeforeRead(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadRegion(ctx, &Region{Id: in.GetId()}, db, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ReadRegionResponse{Result: res}
	if custom, ok := interface{}(in).(RegionsRegionWithAfterRead); ok {
		var err error
		if err = custom.AfterRead(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// RegionsRegionWithBeforeRead called before DefaultReadRegion in the default Read handler
type RegionsRegionWithBeforeRead interface {
	BeforeRead(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// RegionsRegionWithAfterRead called before DefaultReadRegion in the default Read handler
type RegionsRegionWithAfterRead interface {
	AfterRead(context.Context, *ReadRegionResponse, *gorm1.DB) error
}

// Update ...
func (m *RegionsDefaultServer) Update(ctx context.Context, in *UpdateRegionRequest) (*UpdateRegionResponse, error) {
	var err error
	var res *Region
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(RegionsRegionWithBeforeUpdate); ok {
		var err error
		if db, err = custom.BeforeUpdate(ctx, db); err != nil {
			return nil, err
		}
	}
	if in.GetFields() == nil {
		res, err = DefaultStrictUpdateRegion(ctx, in.GetPayload(), db)
	} else {
		res, err = DefaultPatchRegion(ctx, in.GetPayload(), in.GetFields(), db)
	}
	if err != nil {
		return nil, err
	}
	out := &UpdateRegionResponse{Result: res}
	if custom, ok := interface{}(in).(RegionsRegionWithAfterUpdate); ok {
		var err error
		if err = custom.AfterUpdate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// RegionsRegionWithBeforeUpdate called before DefaultUpdateRegion in the default Update handler
type RegionsRegionWithBeforeUpdate interface {
	BeforeUpdate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// RegionsRegionWithAfterUpdate called before DefaultUpdateRegion in the default Update handler
type RegionsRegionWithAfterUpdate interface {
	AfterUpdate(context.Context, *UpdateRegionResponse, *gorm1.DB) error
}

// Delete ...
func (m *RegionsDefaultServer) Delete(ctx context.Context, in *DeleteRegionRequest) (*DeleteRegionResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(RegionsRegionWithBeforeDelete); ok {
		var err error
		if db, err = custom.BeforeDelete(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteRegion(ctx, &Region{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &DeleteRegionResponse{}
	if custom, ok := interface{}(in).(RegionsRegionWithAfterDelete); ok {
		var err error
		if err = custom.AfterDelete(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// RegionsRegionWithBeforeDelete called before DefaultDeleteRegion in the default Delete handler
type RegionsRegionWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// RegionsRegionWithAfterDelete called before DefaultDeleteRegion in the default Delete handler
type RegionsRegionWithAfterDelete interface {
	AfterDelete(context.Context, *DeleteRegionResponse, *gorm1.DB) error
}

// List ...
func (m *RegionsDefaultServer) List(ctx context.Context, in *ListRegionRequest) (*ListRegionsResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(RegionsRegionWithBeforeList); ok {
		var err error
		if db, err = custom.BeforeList(ctx, db); err != nil {
			return nil, err
		}
	}
	pagedRequest := false
	if in.GetPaging().GetLimit() >= 1 {
		in.Paging.Limit++
		pagedRequest = true
	}
	res, err := DefaultListRegion(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	var resPaging *query1.PageInfo
	if pagedRequest {
		var offset int32
		var size int32 = int32(len(res))
		if size == in.GetPaging().GetLimit() {
			size--
			res = res[:size]
			offset = in.GetPaging().GetOffset() + size
		}
		resPaging = &query1.PageInfo{Offset: offset}
	}
	out := &ListRegionsResponse{Results: res, Page: resPaging}
	if custom, ok := interface{}(in).(RegionsRegionWithAfterList); ok {
		var err error
		if err = custom.AfterList(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// RegionsRegionWithBeforeList called before DefaultListRegion in the default List handler
type RegionsRegionWithBeforeList interface {
	BeforeList(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// RegionsRegionWithAfterList called before DefaultListRegion in the default List handler
type RegionsRegionWithAfterList interface {
	AfterList(context.Context, *ListRegionsResponse, *gorm1.DB) error
}
type StagesDefaultServer struct {
}

// Create ...
func (m *StagesDefaultServer) Create(ctx context.Context, in *CreateStageRequest) (*CreateStageResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(StagesStageWithBeforeCreate); ok {
		var err error
		if db, err = custom.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateStage(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreateStageResponse{Result: res}
	if custom, ok := interface{}(in).(StagesStageWithAfterCreate); ok {
		var err error
		if err = custom.AfterCreate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// StagesStageWithBeforeCreate called before DefaultCreateStage in the default Create handler
type StagesStageWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// StagesStageWithAfterCreate called before DefaultCreateStage in the default Create handler
type StagesStageWithAfterCreate interface {
	AfterCreate(context.Context, *CreateStageResponse, *gorm1.DB) error
}

// Read ...
func (m *StagesDefaultServer) Read(ctx context.Context, in *ReadStageRequest) (*ReadStageResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(StagesStageWithBeforeRead); ok {
		var err error
		if db, err = custom.BeforeRead(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadStage(ctx, &Stage{Id: in.GetId()}, db, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ReadStageResponse{Result: res}
	if custom, ok := interface{}(in).(StagesStageWithAfterRead); ok {
		var err error
		if err = custom.AfterRead(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// StagesStageWithBeforeRead called before DefaultReadStage in the default Read handler
type StagesStageWithBeforeRead interface {
	BeforeRead(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// StagesStageWithAfterRead called before DefaultReadStage in the default Read handler
type StagesStageWithAfterRead interface {
	AfterRead(context.Context, *ReadStageResponse, *gorm1.DB) error
}

// Update ...
func (m *StagesDefaultServer) Update(ctx context.Context, in *UpdateStageRequest) (*UpdateStageResponse, error) {
	var err error
	var res *Stage
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(StagesStageWithBeforeUpdate); ok {
		var err error
		if db, err = custom.BeforeUpdate(ctx, db); err != nil {
			return nil, err
		}
	}
	if in.GetFields() == nil {
		res, err = DefaultStrictUpdateStage(ctx, in.GetPayload(), db)
	} else {
		res, err = DefaultPatchStage(ctx, in.GetPayload(), in.GetFields(), db)
	}
	if err != nil {
		return nil, err
	}
	out := &UpdateStageResponse{Result: res}
	if custom, ok := interface{}(in).(StagesStageWithAfterUpdate); ok {
		var err error
		if err = custom.AfterUpdate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// StagesStageWithBeforeUpdate called before DefaultUpdateStage in the default Update handler
type StagesStageWithBeforeUpdate interface {
	BeforeUpdate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// StagesStageWithAfterUpdate called before DefaultUpdateStage in the default Update handler
type StagesStageWithAfterUpdate interface {
	AfterUpdate(context.Context, *UpdateStageResponse, *gorm1.DB) error
}

// Delete ...
func (m *StagesDefaultServer) Delete(ctx context.Context, in *DeleteStageRequest) (*DeleteStageResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(StagesStageWithBeforeDelete); ok {
		var err error
		if db, err = custom.BeforeDelete(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteStage(ctx, &Stage{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &DeleteStageResponse{}
	if custom, ok := interface{}(in).(StagesStageWithAfterDelete); ok {
		var err error
		if err = custom.AfterDelete(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// StagesStageWithBeforeDelete called before DefaultDeleteStage in the default Delete handler
type StagesStageWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// StagesStageWithAfterDelete called before DefaultDeleteStage in the default Delete handler
type StagesStageWithAfterDelete interface {
	AfterDelete(context.Context, *DeleteStageResponse, *gorm1.DB) error
}

// List ...
func (m *StagesDefaultServer) List(ctx context.Context, in *ListStageRequest) (*ListStagesResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(StagesStageWithBeforeList); ok {
		var err error
		if db, err = custom.BeforeList(ctx, db); err != nil {
			return nil, err
		}
	}
	pagedRequest := false
	if in.GetPaging().GetLimit() >= 1 {
		in.Paging.Limit++
		pagedRequest = true
	}
	res, err := DefaultListStage(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	var resPaging *query1.PageInfo
	if pagedRequest {
		var offset int32
		var size int32 = int32(len(res))
		if size == in.GetPaging().GetLimit() {
			size--
			res = res[:size]
			offset = in.GetPaging().GetOffset() + size
		}
		resPaging = &query1.PageInfo{Offset: offset}
	}
	out := &ListStagesResponse{Results: res, Page: resPaging}
	if custom, ok := interface{}(in).(StagesStageWithAfterList); ok {
		var err error
		if err = custom.AfterList(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// StagesStageWithBeforeList called before DefaultListStage in the default List handler
type StagesStageWithBeforeList interface {
	BeforeList(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// StagesStageWithAfterList called before DefaultListStage in the default List handler
type StagesStageWithAfterList interface {
	AfterList(context.Context, *ListStagesResponse, *gorm1.DB) error
}
type EnvironmentsDefaultServer struct {
}

// Create ...
func (m *EnvironmentsDefaultServer) Create(ctx context.Context, in *CreateEnvironmentRequest) (*CreateEnvironmentResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(EnvironmentsEnvironmentWithBeforeCreate); ok {
		var err error
		if db, err = custom.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateEnvironment(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreateEnvironmentResponse{Result: res}
	if custom, ok := interface{}(in).(EnvironmentsEnvironmentWithAfterCreate); ok {
		var err error
		if err = custom.AfterCreate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// EnvironmentsEnvironmentWithBeforeCreate called before DefaultCreateEnvironment in the default Create handler
type EnvironmentsEnvironmentWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// EnvironmentsEnvironmentWithAfterCreate called before DefaultCreateEnvironment in the default Create handler
type EnvironmentsEnvironmentWithAfterCreate interface {
	AfterCreate(context.Context, *CreateEnvironmentResponse, *gorm1.DB) error
}

// Read ...
func (m *EnvironmentsDefaultServer) Read(ctx context.Context, in *ReadEnvironmentRequest) (*ReadEnvironmentResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(EnvironmentsEnvironmentWithBeforeRead); ok {
		var err error
		if db, err = custom.BeforeRead(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadEnvironment(ctx, &Environment{Id: in.GetId()}, db, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ReadEnvironmentResponse{Result: res}
	if custom, ok := interface{}(in).(EnvironmentsEnvironmentWithAfterRead); ok {
		var err error
		if err = custom.AfterRead(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// EnvironmentsEnvironmentWithBeforeRead called before DefaultReadEnvironment in the default Read handler
type EnvironmentsEnvironmentWithBeforeRead interface {
	BeforeRead(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// EnvironmentsEnvironmentWithAfterRead called before DefaultReadEnvironment in the default Read handler
type EnvironmentsEnvironmentWithAfterRead interface {
	AfterRead(context.Context, *ReadEnvironmentResponse, *gorm1.DB) error
}

// Update ...
func (m *EnvironmentsDefaultServer) Update(ctx context.Context, in *UpdateEnvironmentRequest) (*UpdateEnvironmentResponse, error) {
	var err error
	var res *Environment
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(EnvironmentsEnvironmentWithBeforeUpdate); ok {
		var err error
		if db, err = custom.BeforeUpdate(ctx, db); err != nil {
			return nil, err
		}
	}
	if in.GetFields() == nil {
		res, err = DefaultStrictUpdateEnvironment(ctx, in.GetPayload(), db)
	} else {
		res, err = DefaultPatchEnvironment(ctx, in.GetPayload(), in.GetFields(), db)
	}
	if err != nil {
		return nil, err
	}
	out := &UpdateEnvironmentResponse{Result: res}
	if custom, ok := interface{}(in).(EnvironmentsEnvironmentWithAfterUpdate); ok {
		var err error
		if err = custom.AfterUpdate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// EnvironmentsEnvironmentWithBeforeUpdate called before DefaultUpdateEnvironment in the default Update handler
type EnvironmentsEnvironmentWithBeforeUpdate interface {
	BeforeUpdate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// EnvironmentsEnvironmentWithAfterUpdate called before DefaultUpdateEnvironment in the default Update handler
type EnvironmentsEnvironmentWithAfterUpdate interface {
	AfterUpdate(context.Context, *UpdateEnvironmentResponse, *gorm1.DB) error
}

// Delete ...
func (m *EnvironmentsDefaultServer) Delete(ctx context.Context, in *DeleteEnvironmentRequest) (*DeleteEnvironmentResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(EnvironmentsEnvironmentWithBeforeDelete); ok {
		var err error
		if db, err = custom.BeforeDelete(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteEnvironment(ctx, &Environment{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &DeleteEnvironmentResponse{}
	if custom, ok := interface{}(in).(EnvironmentsEnvironmentWithAfterDelete); ok {
		var err error
		if err = custom.AfterDelete(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// EnvironmentsEnvironmentWithBeforeDelete called before DefaultDeleteEnvironment in the default Delete handler
type EnvironmentsEnvironmentWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// EnvironmentsEnvironmentWithAfterDelete called before DefaultDeleteEnvironment in the default Delete handler
type EnvironmentsEnvironmentWithAfterDelete interface {
	AfterDelete(context.Context, *DeleteEnvironmentResponse, *gorm1.DB) error
}

// List ...
func (m *EnvironmentsDefaultServer) List(ctx context.Context, in *ListEnvironmentRequest) (*ListEnvironmentsResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(EnvironmentsEnvironmentWithBeforeList); ok {
		var err error
		if db, err = custom.BeforeList(ctx, db); err != nil {
			return nil, err
		}
	}
	pagedRequest := false
	if in.GetPaging().GetLimit() >= 1 {
		in.Paging.Limit++
		pagedRequest = true
	}
	res, err := DefaultListEnvironment(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	var resPaging *query1.PageInfo
	if pagedRequest {
		var offset int32
		var size int32 = int32(len(res))
		if size == in.GetPaging().GetLimit() {
			size--
			res = res[:size]
			offset = in.GetPaging().GetOffset() + size
		}
		resPaging = &query1.PageInfo{Offset: offset}
	}
	out := &ListEnvironmentsResponse{Results: res, Page: resPaging}
	if custom, ok := interface{}(in).(EnvironmentsEnvironmentWithAfterList); ok {
		var err error
		if err = custom.AfterList(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// EnvironmentsEnvironmentWithBeforeList called before DefaultListEnvironment in the default List handler
type EnvironmentsEnvironmentWithBeforeList interface {
	BeforeList(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// EnvironmentsEnvironmentWithAfterList called before DefaultListEnvironment in the default List handler
type EnvironmentsEnvironmentWithAfterList interface {
	AfterList(context.Context, *ListEnvironmentsResponse, *gorm1.DB) error
}
type ApplicationsDefaultServer struct {
}

// Create ...
func (m *ApplicationsDefaultServer) Create(ctx context.Context, in *CreateApplicationRequest) (*CreateApplicationResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(ApplicationsApplicationWithBeforeCreate); ok {
		var err error
		if db, err = custom.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateApplication(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreateApplicationResponse{Result: res}
	if custom, ok := interface{}(in).(ApplicationsApplicationWithAfterCreate); ok {
		var err error
		if err = custom.AfterCreate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ApplicationsApplicationWithBeforeCreate called before DefaultCreateApplication in the default Create handler
type ApplicationsApplicationWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ApplicationsApplicationWithAfterCreate called before DefaultCreateApplication in the default Create handler
type ApplicationsApplicationWithAfterCreate interface {
	AfterCreate(context.Context, *CreateApplicationResponse, *gorm1.DB) error
}

// Read ...
func (m *ApplicationsDefaultServer) Read(ctx context.Context, in *ReadApplicationRequest) (*ReadApplicationResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(ApplicationsApplicationWithBeforeRead); ok {
		var err error
		if db, err = custom.BeforeRead(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadApplication(ctx, &Application{Id: in.GetId()}, db, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ReadApplicationResponse{Result: res}
	if custom, ok := interface{}(in).(ApplicationsApplicationWithAfterRead); ok {
		var err error
		if err = custom.AfterRead(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ApplicationsApplicationWithBeforeRead called before DefaultReadApplication in the default Read handler
type ApplicationsApplicationWithBeforeRead interface {
	BeforeRead(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ApplicationsApplicationWithAfterRead called before DefaultReadApplication in the default Read handler
type ApplicationsApplicationWithAfterRead interface {
	AfterRead(context.Context, *ReadApplicationResponse, *gorm1.DB) error
}

// Update ...
func (m *ApplicationsDefaultServer) Update(ctx context.Context, in *UpdateApplicationRequest) (*UpdateApplicationResponse, error) {
	var err error
	var res *Application
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(ApplicationsApplicationWithBeforeUpdate); ok {
		var err error
		if db, err = custom.BeforeUpdate(ctx, db); err != nil {
			return nil, err
		}
	}
	if in.GetFields() == nil {
		res, err = DefaultStrictUpdateApplication(ctx, in.GetPayload(), db)
	} else {
		res, err = DefaultPatchApplication(ctx, in.GetPayload(), in.GetFields(), db)
	}
	if err != nil {
		return nil, err
	}
	out := &UpdateApplicationResponse{Result: res}
	if custom, ok := interface{}(in).(ApplicationsApplicationWithAfterUpdate); ok {
		var err error
		if err = custom.AfterUpdate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ApplicationsApplicationWithBeforeUpdate called before DefaultUpdateApplication in the default Update handler
type ApplicationsApplicationWithBeforeUpdate interface {
	BeforeUpdate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ApplicationsApplicationWithAfterUpdate called before DefaultUpdateApplication in the default Update handler
type ApplicationsApplicationWithAfterUpdate interface {
	AfterUpdate(context.Context, *UpdateApplicationResponse, *gorm1.DB) error
}

// Delete ...
func (m *ApplicationsDefaultServer) Delete(ctx context.Context, in *DeleteApplicationRequest) (*DeleteApplicationResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(ApplicationsApplicationWithBeforeDelete); ok {
		var err error
		if db, err = custom.BeforeDelete(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteApplication(ctx, &Application{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &DeleteApplicationResponse{}
	if custom, ok := interface{}(in).(ApplicationsApplicationWithAfterDelete); ok {
		var err error
		if err = custom.AfterDelete(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ApplicationsApplicationWithBeforeDelete called before DefaultDeleteApplication in the default Delete handler
type ApplicationsApplicationWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ApplicationsApplicationWithAfterDelete called before DefaultDeleteApplication in the default Delete handler
type ApplicationsApplicationWithAfterDelete interface {
	AfterDelete(context.Context, *DeleteApplicationResponse, *gorm1.DB) error
}

// List ...
func (m *ApplicationsDefaultServer) List(ctx context.Context, in *ListApplicationRequest) (*ListApplicationsResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(ApplicationsApplicationWithBeforeList); ok {
		var err error
		if db, err = custom.BeforeList(ctx, db); err != nil {
			return nil, err
		}
	}
	pagedRequest := false
	if in.GetPaging().GetLimit() >= 1 {
		in.Paging.Limit++
		pagedRequest = true
	}
	res, err := DefaultListApplication(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	var resPaging *query1.PageInfo
	if pagedRequest {
		var offset int32
		var size int32 = int32(len(res))
		if size == in.GetPaging().GetLimit() {
			size--
			res = res[:size]
			offset = in.GetPaging().GetOffset() + size
		}
		resPaging = &query1.PageInfo{Offset: offset}
	}
	out := &ListApplicationsResponse{Results: res, Page: resPaging}
	if custom, ok := interface{}(in).(ApplicationsApplicationWithAfterList); ok {
		var err error
		if err = custom.AfterList(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ApplicationsApplicationWithBeforeList called before DefaultListApplication in the default List handler
type ApplicationsApplicationWithBeforeList interface {
	BeforeList(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ApplicationsApplicationWithAfterList called before DefaultListApplication in the default List handler
type ApplicationsApplicationWithAfterList interface {
	AfterList(context.Context, *ListApplicationsResponse, *gorm1.DB) error
}
type ChartVersionsDefaultServer struct {
}

// Create ...
func (m *ChartVersionsDefaultServer) Create(ctx context.Context, in *CreateChartVersionRequest) (*CreateChartVersionResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(ChartVersionsChartVersionWithBeforeCreate); ok {
		var err error
		if db, err = custom.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateChartVersion(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreateChartVersionResponse{Result: res}
	if custom, ok := interface{}(in).(ChartVersionsChartVersionWithAfterCreate); ok {
		var err error
		if err = custom.AfterCreate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ChartVersionsChartVersionWithBeforeCreate called before DefaultCreateChartVersion in the default Create handler
type ChartVersionsChartVersionWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ChartVersionsChartVersionWithAfterCreate called before DefaultCreateChartVersion in the default Create handler
type ChartVersionsChartVersionWithAfterCreate interface {
	AfterCreate(context.Context, *CreateChartVersionResponse, *gorm1.DB) error
}

// Read ...
func (m *ChartVersionsDefaultServer) Read(ctx context.Context, in *ReadChartVersionRequest) (*ReadChartVersionResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(ChartVersionsChartVersionWithBeforeRead); ok {
		var err error
		if db, err = custom.BeforeRead(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadChartVersion(ctx, &ChartVersion{Id: in.GetId()}, db, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ReadChartVersionResponse{Result: res}
	if custom, ok := interface{}(in).(ChartVersionsChartVersionWithAfterRead); ok {
		var err error
		if err = custom.AfterRead(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ChartVersionsChartVersionWithBeforeRead called before DefaultReadChartVersion in the default Read handler
type ChartVersionsChartVersionWithBeforeRead interface {
	BeforeRead(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ChartVersionsChartVersionWithAfterRead called before DefaultReadChartVersion in the default Read handler
type ChartVersionsChartVersionWithAfterRead interface {
	AfterRead(context.Context, *ReadChartVersionResponse, *gorm1.DB) error
}

// Update ...
func (m *ChartVersionsDefaultServer) Update(ctx context.Context, in *UpdateChartVersionRequest) (*UpdateChartVersionResponse, error) {
	var err error
	var res *ChartVersion
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(ChartVersionsChartVersionWithBeforeUpdate); ok {
		var err error
		if db, err = custom.BeforeUpdate(ctx, db); err != nil {
			return nil, err
		}
	}
	if in.GetFields() == nil {
		res, err = DefaultStrictUpdateChartVersion(ctx, in.GetPayload(), db)
	} else {
		res, err = DefaultPatchChartVersion(ctx, in.GetPayload(), in.GetFields(), db)
	}
	if err != nil {
		return nil, err
	}
	out := &UpdateChartVersionResponse{Result: res}
	if custom, ok := interface{}(in).(ChartVersionsChartVersionWithAfterUpdate); ok {
		var err error
		if err = custom.AfterUpdate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ChartVersionsChartVersionWithBeforeUpdate called before DefaultUpdateChartVersion in the default Update handler
type ChartVersionsChartVersionWithBeforeUpdate interface {
	BeforeUpdate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ChartVersionsChartVersionWithAfterUpdate called before DefaultUpdateChartVersion in the default Update handler
type ChartVersionsChartVersionWithAfterUpdate interface {
	AfterUpdate(context.Context, *UpdateChartVersionResponse, *gorm1.DB) error
}

// Delete ...
func (m *ChartVersionsDefaultServer) Delete(ctx context.Context, in *DeleteChartVersionRequest) (*DeleteChartVersionResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(ChartVersionsChartVersionWithBeforeDelete); ok {
		var err error
		if db, err = custom.BeforeDelete(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteChartVersion(ctx, &ChartVersion{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &DeleteChartVersionResponse{}
	if custom, ok := interface{}(in).(ChartVersionsChartVersionWithAfterDelete); ok {
		var err error
		if err = custom.AfterDelete(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ChartVersionsChartVersionWithBeforeDelete called before DefaultDeleteChartVersion in the default Delete handler
type ChartVersionsChartVersionWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ChartVersionsChartVersionWithAfterDelete called before DefaultDeleteChartVersion in the default Delete handler
type ChartVersionsChartVersionWithAfterDelete interface {
	AfterDelete(context.Context, *DeleteChartVersionResponse, *gorm1.DB) error
}

// List ...
func (m *ChartVersionsDefaultServer) List(ctx context.Context, in *ListChartVersionRequest) (*ListChartVersionsResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(ChartVersionsChartVersionWithBeforeList); ok {
		var err error
		if db, err = custom.BeforeList(ctx, db); err != nil {
			return nil, err
		}
	}
	pagedRequest := false
	if in.GetPaging().GetLimit() >= 1 {
		in.Paging.Limit++
		pagedRequest = true
	}
	res, err := DefaultListChartVersion(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	var resPaging *query1.PageInfo
	if pagedRequest {
		var offset int32
		var size int32 = int32(len(res))
		if size == in.GetPaging().GetLimit() {
			size--
			res = res[:size]
			offset = in.GetPaging().GetOffset() + size
		}
		resPaging = &query1.PageInfo{Offset: offset}
	}
	out := &ListChartVersionsResponse{Results: res, Page: resPaging}
	if custom, ok := interface{}(in).(ChartVersionsChartVersionWithAfterList); ok {
		var err error
		if err = custom.AfterList(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ChartVersionsChartVersionWithBeforeList called before DefaultListChartVersion in the default List handler
type ChartVersionsChartVersionWithBeforeList interface {
	BeforeList(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ChartVersionsChartVersionWithAfterList called before DefaultListChartVersion in the default List handler
type ChartVersionsChartVersionWithAfterList interface {
	AfterList(context.Context, *ListChartVersionsResponse, *gorm1.DB) error
}
type ApplicationInstancesDefaultServer struct {
}

// Create ...
func (m *ApplicationInstancesDefaultServer) Create(ctx context.Context, in *CreateApplicationInstanceRequest) (*CreateApplicationInstanceResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(ApplicationInstancesApplicationInstanceWithBeforeCreate); ok {
		var err error
		if db, err = custom.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateApplicationInstance(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreateApplicationInstanceResponse{Result: res}
	if custom, ok := interface{}(in).(ApplicationInstancesApplicationInstanceWithAfterCreate); ok {
		var err error
		if err = custom.AfterCreate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ApplicationInstancesApplicationInstanceWithBeforeCreate called before DefaultCreateApplicationInstance in the default Create handler
type ApplicationInstancesApplicationInstanceWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ApplicationInstancesApplicationInstanceWithAfterCreate called before DefaultCreateApplicationInstance in the default Create handler
type ApplicationInstancesApplicationInstanceWithAfterCreate interface {
	AfterCreate(context.Context, *CreateApplicationInstanceResponse, *gorm1.DB) error
}

// Read ...
func (m *ApplicationInstancesDefaultServer) Read(ctx context.Context, in *ReadApplicationInstanceRequest) (*ReadApplicationInstanceResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(ApplicationInstancesApplicationInstanceWithBeforeRead); ok {
		var err error
		if db, err = custom.BeforeRead(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadApplicationInstance(ctx, &ApplicationInstance{Id: in.GetId()}, db, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ReadApplicationInstanceResponse{Result: res}
	if custom, ok := interface{}(in).(ApplicationInstancesApplicationInstanceWithAfterRead); ok {
		var err error
		if err = custom.AfterRead(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ApplicationInstancesApplicationInstanceWithBeforeRead called before DefaultReadApplicationInstance in the default Read handler
type ApplicationInstancesApplicationInstanceWithBeforeRead interface {
	BeforeRead(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ApplicationInstancesApplicationInstanceWithAfterRead called before DefaultReadApplicationInstance in the default Read handler
type ApplicationInstancesApplicationInstanceWithAfterRead interface {
	AfterRead(context.Context, *ReadApplicationInstanceResponse, *gorm1.DB) error
}

// Update ...
func (m *ApplicationInstancesDefaultServer) Update(ctx context.Context, in *UpdateApplicationInstanceRequest) (*UpdateApplicationInstanceResponse, error) {
	var err error
	var res *ApplicationInstance
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(ApplicationInstancesApplicationInstanceWithBeforeUpdate); ok {
		var err error
		if db, err = custom.BeforeUpdate(ctx, db); err != nil {
			return nil, err
		}
	}
	if in.GetFields() == nil {
		res, err = DefaultStrictUpdateApplicationInstance(ctx, in.GetPayload(), db)
	} else {
		res, err = DefaultPatchApplicationInstance(ctx, in.GetPayload(), in.GetFields(), db)
	}
	if err != nil {
		return nil, err
	}
	out := &UpdateApplicationInstanceResponse{Result: res}
	if custom, ok := interface{}(in).(ApplicationInstancesApplicationInstanceWithAfterUpdate); ok {
		var err error
		if err = custom.AfterUpdate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ApplicationInstancesApplicationInstanceWithBeforeUpdate called before DefaultUpdateApplicationInstance in the default Update handler
type ApplicationInstancesApplicationInstanceWithBeforeUpdate interface {
	BeforeUpdate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ApplicationInstancesApplicationInstanceWithAfterUpdate called before DefaultUpdateApplicationInstance in the default Update handler
type ApplicationInstancesApplicationInstanceWithAfterUpdate interface {
	AfterUpdate(context.Context, *UpdateApplicationInstanceResponse, *gorm1.DB) error
}

// Delete ...
func (m *ApplicationInstancesDefaultServer) Delete(ctx context.Context, in *DeleteApplicationInstanceRequest) (*DeleteApplicationInstanceResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(ApplicationInstancesApplicationInstanceWithBeforeDelete); ok {
		var err error
		if db, err = custom.BeforeDelete(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteApplicationInstance(ctx, &ApplicationInstance{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &DeleteApplicationInstanceResponse{}
	if custom, ok := interface{}(in).(ApplicationInstancesApplicationInstanceWithAfterDelete); ok {
		var err error
		if err = custom.AfterDelete(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ApplicationInstancesApplicationInstanceWithBeforeDelete called before DefaultDeleteApplicationInstance in the default Delete handler
type ApplicationInstancesApplicationInstanceWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ApplicationInstancesApplicationInstanceWithAfterDelete called before DefaultDeleteApplicationInstance in the default Delete handler
type ApplicationInstancesApplicationInstanceWithAfterDelete interface {
	AfterDelete(context.Context, *DeleteApplicationInstanceResponse, *gorm1.DB) error
}

// List ...
func (m *ApplicationInstancesDefaultServer) List(ctx context.Context, in *ListApplicationInstanceRequest) (*ListApplicationInstancesResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(ApplicationInstancesApplicationInstanceWithBeforeList); ok {
		var err error
		if db, err = custom.BeforeList(ctx, db); err != nil {
			return nil, err
		}
	}
	pagedRequest := false
	if in.GetPaging().GetLimit() >= 1 {
		in.Paging.Limit++
		pagedRequest = true
	}
	res, err := DefaultListApplicationInstance(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	var resPaging *query1.PageInfo
	if pagedRequest {
		var offset int32
		var size int32 = int32(len(res))
		if size == in.GetPaging().GetLimit() {
			size--
			res = res[:size]
			offset = in.GetPaging().GetOffset() + size
		}
		resPaging = &query1.PageInfo{Offset: offset}
	}
	out := &ListApplicationInstancesResponse{Results: res, Page: resPaging}
	if custom, ok := interface{}(in).(ApplicationInstancesApplicationInstanceWithAfterList); ok {
		var err error
		if err = custom.AfterList(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ApplicationInstancesApplicationInstanceWithBeforeList called before DefaultListApplicationInstance in the default List handler
type ApplicationInstancesApplicationInstanceWithBeforeList interface {
	BeforeList(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ApplicationInstancesApplicationInstanceWithAfterList called before DefaultListApplicationInstance in the default List handler
type ApplicationInstancesApplicationInstanceWithAfterList interface {
	AfterList(context.Context, *ListApplicationInstancesResponse, *gorm1.DB) error
}
type VaultsDefaultServer struct {
}

// Create ...
func (m *VaultsDefaultServer) Create(ctx context.Context, in *CreateVaultRequest) (*CreateVaultResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(VaultsVaultWithBeforeCreate); ok {
		var err error
		if db, err = custom.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateVault(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreateVaultResponse{Result: res}
	if custom, ok := interface{}(in).(VaultsVaultWithAfterCreate); ok {
		var err error
		if err = custom.AfterCreate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// VaultsVaultWithBeforeCreate called before DefaultCreateVault in the default Create handler
type VaultsVaultWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// VaultsVaultWithAfterCreate called before DefaultCreateVault in the default Create handler
type VaultsVaultWithAfterCreate interface {
	AfterCreate(context.Context, *CreateVaultResponse, *gorm1.DB) error
}

// Read ...
func (m *VaultsDefaultServer) Read(ctx context.Context, in *ReadVaultRequest) (*ReadVaultResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(VaultsVaultWithBeforeRead); ok {
		var err error
		if db, err = custom.BeforeRead(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadVault(ctx, &Vault{Id: in.GetId()}, db, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ReadVaultResponse{Result: res}
	if custom, ok := interface{}(in).(VaultsVaultWithAfterRead); ok {
		var err error
		if err = custom.AfterRead(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// VaultsVaultWithBeforeRead called before DefaultReadVault in the default Read handler
type VaultsVaultWithBeforeRead interface {
	BeforeRead(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// VaultsVaultWithAfterRead called before DefaultReadVault in the default Read handler
type VaultsVaultWithAfterRead interface {
	AfterRead(context.Context, *ReadVaultResponse, *gorm1.DB) error
}

// Update ...
func (m *VaultsDefaultServer) Update(ctx context.Context, in *UpdateVaultRequest) (*UpdateVaultResponse, error) {
	var err error
	var res *Vault
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(VaultsVaultWithBeforeUpdate); ok {
		var err error
		if db, err = custom.BeforeUpdate(ctx, db); err != nil {
			return nil, err
		}
	}
	if in.GetFields() == nil {
		res, err = DefaultStrictUpdateVault(ctx, in.GetPayload(), db)
	} else {
		res, err = DefaultPatchVault(ctx, in.GetPayload(), in.GetFields(), db)
	}
	if err != nil {
		return nil, err
	}
	out := &UpdateVaultResponse{Result: res}
	if custom, ok := interface{}(in).(VaultsVaultWithAfterUpdate); ok {
		var err error
		if err = custom.AfterUpdate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// VaultsVaultWithBeforeUpdate called before DefaultUpdateVault in the default Update handler
type VaultsVaultWithBeforeUpdate interface {
	BeforeUpdate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// VaultsVaultWithAfterUpdate called before DefaultUpdateVault in the default Update handler
type VaultsVaultWithAfterUpdate interface {
	AfterUpdate(context.Context, *UpdateVaultResponse, *gorm1.DB) error
}

// Delete ...
func (m *VaultsDefaultServer) Delete(ctx context.Context, in *DeleteVaultRequest) (*DeleteVaultResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(VaultsVaultWithBeforeDelete); ok {
		var err error
		if db, err = custom.BeforeDelete(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteVault(ctx, &Vault{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &DeleteVaultResponse{}
	if custom, ok := interface{}(in).(VaultsVaultWithAfterDelete); ok {
		var err error
		if err = custom.AfterDelete(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// VaultsVaultWithBeforeDelete called before DefaultDeleteVault in the default Delete handler
type VaultsVaultWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// VaultsVaultWithAfterDelete called before DefaultDeleteVault in the default Delete handler
type VaultsVaultWithAfterDelete interface {
	AfterDelete(context.Context, *DeleteVaultResponse, *gorm1.DB) error
}

// List ...
func (m *VaultsDefaultServer) List(ctx context.Context, in *ListVaultRequest) (*ListVaultsResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(VaultsVaultWithBeforeList); ok {
		var err error
		if db, err = custom.BeforeList(ctx, db); err != nil {
			return nil, err
		}
	}
	pagedRequest := false
	if in.GetPaging().GetLimit() >= 1 {
		in.Paging.Limit++
		pagedRequest = true
	}
	res, err := DefaultListVault(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	var resPaging *query1.PageInfo
	if pagedRequest {
		var offset int32
		var size int32 = int32(len(res))
		if size == in.GetPaging().GetLimit() {
			size--
			res = res[:size]
			offset = in.GetPaging().GetOffset() + size
		}
		resPaging = &query1.PageInfo{Offset: offset}
	}
	out := &ListVaultsResponse{Results: res, Page: resPaging}
	if custom, ok := interface{}(in).(VaultsVaultWithAfterList); ok {
		var err error
		if err = custom.AfterList(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// VaultsVaultWithBeforeList called before DefaultListVault in the default List handler
type VaultsVaultWithBeforeList interface {
	BeforeList(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// VaultsVaultWithAfterList called before DefaultListVault in the default List handler
type VaultsVaultWithAfterList interface {
	AfterList(context.Context, *ListVaultsResponse, *gorm1.DB) error
}
type SecretsDefaultServer struct {
}

// Create ...
func (m *SecretsDefaultServer) Create(ctx context.Context, in *CreateSecretRequest) (*CreateSecretResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(SecretsSecretWithBeforeCreate); ok {
		var err error
		if db, err = custom.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateSecret(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreateSecretResponse{Result: res}
	if custom, ok := interface{}(in).(SecretsSecretWithAfterCreate); ok {
		var err error
		if err = custom.AfterCreate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// SecretsSecretWithBeforeCreate called before DefaultCreateSecret in the default Create handler
type SecretsSecretWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// SecretsSecretWithAfterCreate called before DefaultCreateSecret in the default Create handler
type SecretsSecretWithAfterCreate interface {
	AfterCreate(context.Context, *CreateSecretResponse, *gorm1.DB) error
}

// Read ...
func (m *SecretsDefaultServer) Read(ctx context.Context, in *ReadSecretRequest) (*ReadSecretResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(SecretsSecretWithBeforeRead); ok {
		var err error
		if db, err = custom.BeforeRead(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadSecret(ctx, &Secret{Id: in.GetId()}, db, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ReadSecretResponse{Result: res}
	if custom, ok := interface{}(in).(SecretsSecretWithAfterRead); ok {
		var err error
		if err = custom.AfterRead(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// SecretsSecretWithBeforeRead called before DefaultReadSecret in the default Read handler
type SecretsSecretWithBeforeRead interface {
	BeforeRead(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// SecretsSecretWithAfterRead called before DefaultReadSecret in the default Read handler
type SecretsSecretWithAfterRead interface {
	AfterRead(context.Context, *ReadSecretResponse, *gorm1.DB) error
}

// Update ...
func (m *SecretsDefaultServer) Update(ctx context.Context, in *UpdateSecretRequest) (*UpdateSecretResponse, error) {
	var err error
	var res *Secret
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(SecretsSecretWithBeforeUpdate); ok {
		var err error
		if db, err = custom.BeforeUpdate(ctx, db); err != nil {
			return nil, err
		}
	}
	if in.GetFields() == nil {
		res, err = DefaultStrictUpdateSecret(ctx, in.GetPayload(), db)
	} else {
		res, err = DefaultPatchSecret(ctx, in.GetPayload(), in.GetFields(), db)
	}
	if err != nil {
		return nil, err
	}
	out := &UpdateSecretResponse{Result: res}
	if custom, ok := interface{}(in).(SecretsSecretWithAfterUpdate); ok {
		var err error
		if err = custom.AfterUpdate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// SecretsSecretWithBeforeUpdate called before DefaultUpdateSecret in the default Update handler
type SecretsSecretWithBeforeUpdate interface {
	BeforeUpdate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// SecretsSecretWithAfterUpdate called before DefaultUpdateSecret in the default Update handler
type SecretsSecretWithAfterUpdate interface {
	AfterUpdate(context.Context, *UpdateSecretResponse, *gorm1.DB) error
}

// Delete ...
func (m *SecretsDefaultServer) Delete(ctx context.Context, in *DeleteSecretRequest) (*DeleteSecretResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(SecretsSecretWithBeforeDelete); ok {
		var err error
		if db, err = custom.BeforeDelete(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteSecret(ctx, &Secret{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &DeleteSecretResponse{}
	if custom, ok := interface{}(in).(SecretsSecretWithAfterDelete); ok {
		var err error
		if err = custom.AfterDelete(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// SecretsSecretWithBeforeDelete called before DefaultDeleteSecret in the default Delete handler
type SecretsSecretWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// SecretsSecretWithAfterDelete called before DefaultDeleteSecret in the default Delete handler
type SecretsSecretWithAfterDelete interface {
	AfterDelete(context.Context, *DeleteSecretResponse, *gorm1.DB) error
}

// List ...
func (m *SecretsDefaultServer) List(ctx context.Context, in *ListSecretRequest) (*ListSecretsResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(SecretsSecretWithBeforeList); ok {
		var err error
		if db, err = custom.BeforeList(ctx, db); err != nil {
			return nil, err
		}
	}
	pagedRequest := false
	if in.GetPaging().GetLimit() >= 1 {
		in.Paging.Limit++
		pagedRequest = true
	}
	res, err := DefaultListSecret(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	var resPaging *query1.PageInfo
	if pagedRequest {
		var offset int32
		var size int32 = int32(len(res))
		if size == in.GetPaging().GetLimit() {
			size--
			res = res[:size]
			offset = in.GetPaging().GetOffset() + size
		}
		resPaging = &query1.PageInfo{Offset: offset}
	}
	out := &ListSecretsResponse{Results: res, Page: resPaging}
	if custom, ok := interface{}(in).(SecretsSecretWithAfterList); ok {
		var err error
		if err = custom.AfterList(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// SecretsSecretWithBeforeList called before DefaultListSecret in the default List handler
type SecretsSecretWithBeforeList interface {
	BeforeList(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// SecretsSecretWithAfterList called before DefaultListSecret in the default List handler
type SecretsSecretWithAfterList interface {
	AfterList(context.Context, *ListSecretsResponse, *gorm1.DB) error
}
type AwsServicesDefaultServer struct {
}

// Create ...
func (m *AwsServicesDefaultServer) Create(ctx context.Context, in *CreateAwsServiceRequest) (*CreateAwsServiceResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(AwsServicesAwsServiceWithBeforeCreate); ok {
		var err error
		if db, err = custom.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateAwsService(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreateAwsServiceResponse{Result: res}
	if custom, ok := interface{}(in).(AwsServicesAwsServiceWithAfterCreate); ok {
		var err error
		if err = custom.AfterCreate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// AwsServicesAwsServiceWithBeforeCreate called before DefaultCreateAwsService in the default Create handler
type AwsServicesAwsServiceWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// AwsServicesAwsServiceWithAfterCreate called before DefaultCreateAwsService in the default Create handler
type AwsServicesAwsServiceWithAfterCreate interface {
	AfterCreate(context.Context, *CreateAwsServiceResponse, *gorm1.DB) error
}

// Read ...
func (m *AwsServicesDefaultServer) Read(ctx context.Context, in *ReadAwsServiceRequest) (*ReadAwsServiceResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(AwsServicesAwsServiceWithBeforeRead); ok {
		var err error
		if db, err = custom.BeforeRead(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadAwsService(ctx, &AwsService{Id: in.GetId()}, db, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ReadAwsServiceResponse{Result: res}
	if custom, ok := interface{}(in).(AwsServicesAwsServiceWithAfterRead); ok {
		var err error
		if err = custom.AfterRead(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// AwsServicesAwsServiceWithBeforeRead called before DefaultReadAwsService in the default Read handler
type AwsServicesAwsServiceWithBeforeRead interface {
	BeforeRead(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// AwsServicesAwsServiceWithAfterRead called before DefaultReadAwsService in the default Read handler
type AwsServicesAwsServiceWithAfterRead interface {
	AfterRead(context.Context, *ReadAwsServiceResponse, *gorm1.DB) error
}

// Update ...
func (m *AwsServicesDefaultServer) Update(ctx context.Context, in *UpdateAwsServiceRequest) (*UpdateAwsServiceResponse, error) {
	var err error
	var res *AwsService
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(AwsServicesAwsServiceWithBeforeUpdate); ok {
		var err error
		if db, err = custom.BeforeUpdate(ctx, db); err != nil {
			return nil, err
		}
	}
	if in.GetFields() == nil {
		res, err = DefaultStrictUpdateAwsService(ctx, in.GetPayload(), db)
	} else {
		res, err = DefaultPatchAwsService(ctx, in.GetPayload(), in.GetFields(), db)
	}
	if err != nil {
		return nil, err
	}
	out := &UpdateAwsServiceResponse{Result: res}
	if custom, ok := interface{}(in).(AwsServicesAwsServiceWithAfterUpdate); ok {
		var err error
		if err = custom.AfterUpdate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// AwsServicesAwsServiceWithBeforeUpdate called before DefaultUpdateAwsService in the default Update handler
type AwsServicesAwsServiceWithBeforeUpdate interface {
	BeforeUpdate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// AwsServicesAwsServiceWithAfterUpdate called before DefaultUpdateAwsService in the default Update handler
type AwsServicesAwsServiceWithAfterUpdate interface {
	AfterUpdate(context.Context, *UpdateAwsServiceResponse, *gorm1.DB) error
}

// Delete ...
func (m *AwsServicesDefaultServer) Delete(ctx context.Context, in *DeleteAwsServiceRequest) (*DeleteAwsServiceResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(AwsServicesAwsServiceWithBeforeDelete); ok {
		var err error
		if db, err = custom.BeforeDelete(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteAwsService(ctx, &AwsService{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &DeleteAwsServiceResponse{}
	if custom, ok := interface{}(in).(AwsServicesAwsServiceWithAfterDelete); ok {
		var err error
		if err = custom.AfterDelete(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// AwsServicesAwsServiceWithBeforeDelete called before DefaultDeleteAwsService in the default Delete handler
type AwsServicesAwsServiceWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// AwsServicesAwsServiceWithAfterDelete called before DefaultDeleteAwsService in the default Delete handler
type AwsServicesAwsServiceWithAfterDelete interface {
	AfterDelete(context.Context, *DeleteAwsServiceResponse, *gorm1.DB) error
}

// List ...
func (m *AwsServicesDefaultServer) List(ctx context.Context, in *ListAwsServiceRequest) (*ListAwsServicesResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(AwsServicesAwsServiceWithBeforeList); ok {
		var err error
		if db, err = custom.BeforeList(ctx, db); err != nil {
			return nil, err
		}
	}
	pagedRequest := false
	if in.GetPaging().GetLimit() >= 1 {
		in.Paging.Limit++
		pagedRequest = true
	}
	res, err := DefaultListAwsService(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	var resPaging *query1.PageInfo
	if pagedRequest {
		var offset int32
		var size int32 = int32(len(res))
		if size == in.GetPaging().GetLimit() {
			size--
			res = res[:size]
			offset = in.GetPaging().GetOffset() + size
		}
		resPaging = &query1.PageInfo{Offset: offset}
	}
	out := &ListAwsServicesResponse{Results: res, Page: resPaging}
	if custom, ok := interface{}(in).(AwsServicesAwsServiceWithAfterList); ok {
		var err error
		if err = custom.AfterList(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// AwsServicesAwsServiceWithBeforeList called before DefaultListAwsService in the default List handler
type AwsServicesAwsServiceWithBeforeList interface {
	BeforeList(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// AwsServicesAwsServiceWithAfterList called before DefaultListAwsService in the default List handler
type AwsServicesAwsServiceWithAfterList interface {
	AfterList(context.Context, *ListAwsServicesResponse, *gorm1.DB) error
}
type AwsRdsInstancesDefaultServer struct {
}

// Create ...
func (m *AwsRdsInstancesDefaultServer) Create(ctx context.Context, in *CreateAwsRdsInstanceRequest) (*CreateAwsRdsInstanceResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(AwsRdsInstancesAwsRdsInstanceWithBeforeCreate); ok {
		var err error
		if db, err = custom.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateAwsRdsInstance(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreateAwsRdsInstanceResponse{Result: res}
	if custom, ok := interface{}(in).(AwsRdsInstancesAwsRdsInstanceWithAfterCreate); ok {
		var err error
		if err = custom.AfterCreate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// AwsRdsInstancesAwsRdsInstanceWithBeforeCreate called before DefaultCreateAwsRdsInstance in the default Create handler
type AwsRdsInstancesAwsRdsInstanceWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// AwsRdsInstancesAwsRdsInstanceWithAfterCreate called before DefaultCreateAwsRdsInstance in the default Create handler
type AwsRdsInstancesAwsRdsInstanceWithAfterCreate interface {
	AfterCreate(context.Context, *CreateAwsRdsInstanceResponse, *gorm1.DB) error
}

// Read ...
func (m *AwsRdsInstancesDefaultServer) Read(ctx context.Context, in *ReadAwsRdsInstanceRequest) (*ReadAwsRdsInstanceResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(AwsRdsInstancesAwsRdsInstanceWithBeforeRead); ok {
		var err error
		if db, err = custom.BeforeRead(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadAwsRdsInstance(ctx, &AwsRdsInstance{Id: in.GetId()}, db, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ReadAwsRdsInstanceResponse{Result: res}
	if custom, ok := interface{}(in).(AwsRdsInstancesAwsRdsInstanceWithAfterRead); ok {
		var err error
		if err = custom.AfterRead(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// AwsRdsInstancesAwsRdsInstanceWithBeforeRead called before DefaultReadAwsRdsInstance in the default Read handler
type AwsRdsInstancesAwsRdsInstanceWithBeforeRead interface {
	BeforeRead(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// AwsRdsInstancesAwsRdsInstanceWithAfterRead called before DefaultReadAwsRdsInstance in the default Read handler
type AwsRdsInstancesAwsRdsInstanceWithAfterRead interface {
	AfterRead(context.Context, *ReadAwsRdsInstanceResponse, *gorm1.DB) error
}

// Update ...
func (m *AwsRdsInstancesDefaultServer) Update(ctx context.Context, in *UpdateAwsRdsInstanceRequest) (*UpdateAwsRdsInstanceResponse, error) {
	var err error
	var res *AwsRdsInstance
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(AwsRdsInstancesAwsRdsInstanceWithBeforeUpdate); ok {
		var err error
		if db, err = custom.BeforeUpdate(ctx, db); err != nil {
			return nil, err
		}
	}
	if in.GetFields() == nil {
		res, err = DefaultStrictUpdateAwsRdsInstance(ctx, in.GetPayload(), db)
	} else {
		res, err = DefaultPatchAwsRdsInstance(ctx, in.GetPayload(), in.GetFields(), db)
	}
	if err != nil {
		return nil, err
	}
	out := &UpdateAwsRdsInstanceResponse{Result: res}
	if custom, ok := interface{}(in).(AwsRdsInstancesAwsRdsInstanceWithAfterUpdate); ok {
		var err error
		if err = custom.AfterUpdate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// AwsRdsInstancesAwsRdsInstanceWithBeforeUpdate called before DefaultUpdateAwsRdsInstance in the default Update handler
type AwsRdsInstancesAwsRdsInstanceWithBeforeUpdate interface {
	BeforeUpdate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// AwsRdsInstancesAwsRdsInstanceWithAfterUpdate called before DefaultUpdateAwsRdsInstance in the default Update handler
type AwsRdsInstancesAwsRdsInstanceWithAfterUpdate interface {
	AfterUpdate(context.Context, *UpdateAwsRdsInstanceResponse, *gorm1.DB) error
}

// Delete ...
func (m *AwsRdsInstancesDefaultServer) Delete(ctx context.Context, in *DeleteAwsRdsInstanceRequest) (*DeleteAwsRdsInstanceResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(AwsRdsInstancesAwsRdsInstanceWithBeforeDelete); ok {
		var err error
		if db, err = custom.BeforeDelete(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteAwsRdsInstance(ctx, &AwsRdsInstance{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &DeleteAwsRdsInstanceResponse{}
	if custom, ok := interface{}(in).(AwsRdsInstancesAwsRdsInstanceWithAfterDelete); ok {
		var err error
		if err = custom.AfterDelete(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// AwsRdsInstancesAwsRdsInstanceWithBeforeDelete called before DefaultDeleteAwsRdsInstance in the default Delete handler
type AwsRdsInstancesAwsRdsInstanceWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// AwsRdsInstancesAwsRdsInstanceWithAfterDelete called before DefaultDeleteAwsRdsInstance in the default Delete handler
type AwsRdsInstancesAwsRdsInstanceWithAfterDelete interface {
	AfterDelete(context.Context, *DeleteAwsRdsInstanceResponse, *gorm1.DB) error
}

// List ...
func (m *AwsRdsInstancesDefaultServer) List(ctx context.Context, in *ListAwsRdsInstanceRequest) (*ListAwsRdsInstancesResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(AwsRdsInstancesAwsRdsInstanceWithBeforeList); ok {
		var err error
		if db, err = custom.BeforeList(ctx, db); err != nil {
			return nil, err
		}
	}
	pagedRequest := false
	if in.GetPaging().GetLimit() >= 1 {
		in.Paging.Limit++
		pagedRequest = true
	}
	res, err := DefaultListAwsRdsInstance(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	var resPaging *query1.PageInfo
	if pagedRequest {
		var offset int32
		var size int32 = int32(len(res))
		if size == in.GetPaging().GetLimit() {
			size--
			res = res[:size]
			offset = in.GetPaging().GetOffset() + size
		}
		resPaging = &query1.PageInfo{Offset: offset}
	}
	out := &ListAwsRdsInstancesResponse{Results: res, Page: resPaging}
	if custom, ok := interface{}(in).(AwsRdsInstancesAwsRdsInstanceWithAfterList); ok {
		var err error
		if err = custom.AfterList(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// AwsRdsInstancesAwsRdsInstanceWithBeforeList called before DefaultListAwsRdsInstance in the default List handler
type AwsRdsInstancesAwsRdsInstanceWithBeforeList interface {
	BeforeList(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// AwsRdsInstancesAwsRdsInstanceWithAfterList called before DefaultListAwsRdsInstance in the default List handler
type AwsRdsInstancesAwsRdsInstanceWithAfterList interface {
	AfterList(context.Context, *ListAwsRdsInstancesResponse, *gorm1.DB) error
}
type ValuesDefaultServer struct {
}

// Create ...
func (m *ValuesDefaultServer) Create(ctx context.Context, in *CreateValueRequest) (*CreateValueResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(ValuesValueWithBeforeCreate); ok {
		var err error
		if db, err = custom.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateValue(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreateValueResponse{Result: res}
	if custom, ok := interface{}(in).(ValuesValueWithAfterCreate); ok {
		var err error
		if err = custom.AfterCreate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ValuesValueWithBeforeCreate called before DefaultCreateValue in the default Create handler
type ValuesValueWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ValuesValueWithAfterCreate called before DefaultCreateValue in the default Create handler
type ValuesValueWithAfterCreate interface {
	AfterCreate(context.Context, *CreateValueResponse, *gorm1.DB) error
}

// Read ...
func (m *ValuesDefaultServer) Read(ctx context.Context, in *ReadValueRequest) (*ReadValueResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(ValuesValueWithBeforeRead); ok {
		var err error
		if db, err = custom.BeforeRead(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadValue(ctx, &Value{Id: in.GetId()}, db, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ReadValueResponse{Result: res}
	if custom, ok := interface{}(in).(ValuesValueWithAfterRead); ok {
		var err error
		if err = custom.AfterRead(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ValuesValueWithBeforeRead called before DefaultReadValue in the default Read handler
type ValuesValueWithBeforeRead interface {
	BeforeRead(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ValuesValueWithAfterRead called before DefaultReadValue in the default Read handler
type ValuesValueWithAfterRead interface {
	AfterRead(context.Context, *ReadValueResponse, *gorm1.DB) error
}

// Update ...
func (m *ValuesDefaultServer) Update(ctx context.Context, in *UpdateValueRequest) (*UpdateValueResponse, error) {
	var err error
	var res *Value
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(ValuesValueWithBeforeUpdate); ok {
		var err error
		if db, err = custom.BeforeUpdate(ctx, db); err != nil {
			return nil, err
		}
	}
	if in.GetFields() == nil {
		res, err = DefaultStrictUpdateValue(ctx, in.GetPayload(), db)
	} else {
		res, err = DefaultPatchValue(ctx, in.GetPayload(), in.GetFields(), db)
	}
	if err != nil {
		return nil, err
	}
	out := &UpdateValueResponse{Result: res}
	if custom, ok := interface{}(in).(ValuesValueWithAfterUpdate); ok {
		var err error
		if err = custom.AfterUpdate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ValuesValueWithBeforeUpdate called before DefaultUpdateValue in the default Update handler
type ValuesValueWithBeforeUpdate interface {
	BeforeUpdate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ValuesValueWithAfterUpdate called before DefaultUpdateValue in the default Update handler
type ValuesValueWithAfterUpdate interface {
	AfterUpdate(context.Context, *UpdateValueResponse, *gorm1.DB) error
}

// Delete ...
func (m *ValuesDefaultServer) Delete(ctx context.Context, in *DeleteValueRequest) (*DeleteValueResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(ValuesValueWithBeforeDelete); ok {
		var err error
		if db, err = custom.BeforeDelete(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteValue(ctx, &Value{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &DeleteValueResponse{}
	if custom, ok := interface{}(in).(ValuesValueWithAfterDelete); ok {
		var err error
		if err = custom.AfterDelete(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ValuesValueWithBeforeDelete called before DefaultDeleteValue in the default Delete handler
type ValuesValueWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ValuesValueWithAfterDelete called before DefaultDeleteValue in the default Delete handler
type ValuesValueWithAfterDelete interface {
	AfterDelete(context.Context, *DeleteValueResponse, *gorm1.DB) error
}

// List ...
func (m *ValuesDefaultServer) List(ctx context.Context, in *ListValueRequest) (*ListValuesResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(ValuesValueWithBeforeList); ok {
		var err error
		if db, err = custom.BeforeList(ctx, db); err != nil {
			return nil, err
		}
	}
	pagedRequest := false
	if in.GetPaging().GetLimit() >= 1 {
		in.Paging.Limit++
		pagedRequest = true
	}
	res, err := DefaultListValue(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	var resPaging *query1.PageInfo
	if pagedRequest {
		var offset int32
		var size int32 = int32(len(res))
		if size == in.GetPaging().GetLimit() {
			size--
			res = res[:size]
			offset = in.GetPaging().GetOffset() + size
		}
		resPaging = &query1.PageInfo{Offset: offset}
	}
	out := &ListValuesResponse{Results: res, Page: resPaging}
	if custom, ok := interface{}(in).(ValuesValueWithAfterList); ok {
		var err error
		if err = custom.AfterList(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ValuesValueWithBeforeList called before DefaultListValue in the default List handler
type ValuesValueWithBeforeList interface {
	BeforeList(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ValuesValueWithAfterList called before DefaultListValue in the default List handler
type ValuesValueWithAfterList interface {
	AfterList(context.Context, *ListValuesResponse, *gorm1.DB) error
}
type ArtifactsDefaultServer struct {
}

// Create ...
func (m *ArtifactsDefaultServer) Create(ctx context.Context, in *CreateArtifactRequest) (*CreateArtifactResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(ArtifactsArtifactWithBeforeCreate); ok {
		var err error
		if db, err = custom.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateArtifact(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreateArtifactResponse{Result: res}
	if custom, ok := interface{}(in).(ArtifactsArtifactWithAfterCreate); ok {
		var err error
		if err = custom.AfterCreate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ArtifactsArtifactWithBeforeCreate called before DefaultCreateArtifact in the default Create handler
type ArtifactsArtifactWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ArtifactsArtifactWithAfterCreate called before DefaultCreateArtifact in the default Create handler
type ArtifactsArtifactWithAfterCreate interface {
	AfterCreate(context.Context, *CreateArtifactResponse, *gorm1.DB) error
}

// Read ...
func (m *ArtifactsDefaultServer) Read(ctx context.Context, in *ReadArtifactRequest) (*ReadArtifactResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(ArtifactsArtifactWithBeforeRead); ok {
		var err error
		if db, err = custom.BeforeRead(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadArtifact(ctx, &Artifact{Id: in.GetId()}, db, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ReadArtifactResponse{Result: res}
	if custom, ok := interface{}(in).(ArtifactsArtifactWithAfterRead); ok {
		var err error
		if err = custom.AfterRead(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ArtifactsArtifactWithBeforeRead called before DefaultReadArtifact in the default Read handler
type ArtifactsArtifactWithBeforeRead interface {
	BeforeRead(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ArtifactsArtifactWithAfterRead called before DefaultReadArtifact in the default Read handler
type ArtifactsArtifactWithAfterRead interface {
	AfterRead(context.Context, *ReadArtifactResponse, *gorm1.DB) error
}

// Update ...
func (m *ArtifactsDefaultServer) Update(ctx context.Context, in *UpdateArtifactRequest) (*UpdateArtifactResponse, error) {
	var err error
	var res *Artifact
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(ArtifactsArtifactWithBeforeUpdate); ok {
		var err error
		if db, err = custom.BeforeUpdate(ctx, db); err != nil {
			return nil, err
		}
	}
	if in.GetFields() == nil {
		res, err = DefaultStrictUpdateArtifact(ctx, in.GetPayload(), db)
	} else {
		res, err = DefaultPatchArtifact(ctx, in.GetPayload(), in.GetFields(), db)
	}
	if err != nil {
		return nil, err
	}
	out := &UpdateArtifactResponse{Result: res}
	if custom, ok := interface{}(in).(ArtifactsArtifactWithAfterUpdate); ok {
		var err error
		if err = custom.AfterUpdate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ArtifactsArtifactWithBeforeUpdate called before DefaultUpdateArtifact in the default Update handler
type ArtifactsArtifactWithBeforeUpdate interface {
	BeforeUpdate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ArtifactsArtifactWithAfterUpdate called before DefaultUpdateArtifact in the default Update handler
type ArtifactsArtifactWithAfterUpdate interface {
	AfterUpdate(context.Context, *UpdateArtifactResponse, *gorm1.DB) error
}

// Delete ...
func (m *ArtifactsDefaultServer) Delete(ctx context.Context, in *DeleteArtifactRequest) (*DeleteArtifactResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(ArtifactsArtifactWithBeforeDelete); ok {
		var err error
		if db, err = custom.BeforeDelete(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteArtifact(ctx, &Artifact{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &DeleteArtifactResponse{}
	if custom, ok := interface{}(in).(ArtifactsArtifactWithAfterDelete); ok {
		var err error
		if err = custom.AfterDelete(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ArtifactsArtifactWithBeforeDelete called before DefaultDeleteArtifact in the default Delete handler
type ArtifactsArtifactWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ArtifactsArtifactWithAfterDelete called before DefaultDeleteArtifact in the default Delete handler
type ArtifactsArtifactWithAfterDelete interface {
	AfterDelete(context.Context, *DeleteArtifactResponse, *gorm1.DB) error
}

// List ...
func (m *ArtifactsDefaultServer) List(ctx context.Context, in *ListArtifactRequest) (*ListArtifactsResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(ArtifactsArtifactWithBeforeList); ok {
		var err error
		if db, err = custom.BeforeList(ctx, db); err != nil {
			return nil, err
		}
	}
	pagedRequest := false
	if in.GetPaging().GetLimit() >= 1 {
		in.Paging.Limit++
		pagedRequest = true
	}
	res, err := DefaultListArtifact(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	var resPaging *query1.PageInfo
	if pagedRequest {
		var offset int32
		var size int32 = int32(len(res))
		if size == in.GetPaging().GetLimit() {
			size--
			res = res[:size]
			offset = in.GetPaging().GetOffset() + size
		}
		resPaging = &query1.PageInfo{Offset: offset}
	}
	out := &ListArtifactsResponse{Results: res, Page: resPaging}
	if custom, ok := interface{}(in).(ArtifactsArtifactWithAfterList); ok {
		var err error
		if err = custom.AfterList(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ArtifactsArtifactWithBeforeList called before DefaultListArtifact in the default List handler
type ArtifactsArtifactWithBeforeList interface {
	BeforeList(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ArtifactsArtifactWithAfterList called before DefaultListArtifact in the default List handler
type ArtifactsArtifactWithAfterList interface {
	AfterList(context.Context, *ListArtifactsResponse, *gorm1.DB) error
}
type KubeClustersDefaultServer struct {
}

// Create ...
func (m *KubeClustersDefaultServer) Create(ctx context.Context, in *CreateKubeClusterRequest) (*CreateKubeClusterResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(KubeClustersKubeClusterWithBeforeCreate); ok {
		var err error
		if db, err = custom.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateKubeCluster(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreateKubeClusterResponse{Result: res}
	if custom, ok := interface{}(in).(KubeClustersKubeClusterWithAfterCreate); ok {
		var err error
		if err = custom.AfterCreate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// KubeClustersKubeClusterWithBeforeCreate called before DefaultCreateKubeCluster in the default Create handler
type KubeClustersKubeClusterWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// KubeClustersKubeClusterWithAfterCreate called before DefaultCreateKubeCluster in the default Create handler
type KubeClustersKubeClusterWithAfterCreate interface {
	AfterCreate(context.Context, *CreateKubeClusterResponse, *gorm1.DB) error
}

// Read ...
func (m *KubeClustersDefaultServer) Read(ctx context.Context, in *ReadKubeClusterRequest) (*ReadKubeClusterResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(KubeClustersKubeClusterWithBeforeRead); ok {
		var err error
		if db, err = custom.BeforeRead(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadKubeCluster(ctx, &KubeCluster{Id: in.GetId()}, db, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ReadKubeClusterResponse{Result: res}
	if custom, ok := interface{}(in).(KubeClustersKubeClusterWithAfterRead); ok {
		var err error
		if err = custom.AfterRead(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// KubeClustersKubeClusterWithBeforeRead called before DefaultReadKubeCluster in the default Read handler
type KubeClustersKubeClusterWithBeforeRead interface {
	BeforeRead(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// KubeClustersKubeClusterWithAfterRead called before DefaultReadKubeCluster in the default Read handler
type KubeClustersKubeClusterWithAfterRead interface {
	AfterRead(context.Context, *ReadKubeClusterResponse, *gorm1.DB) error
}

// Update ...
func (m *KubeClustersDefaultServer) Update(ctx context.Context, in *UpdateKubeClusterRequest) (*UpdateKubeClusterResponse, error) {
	var err error
	var res *KubeCluster
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(KubeClustersKubeClusterWithBeforeUpdate); ok {
		var err error
		if db, err = custom.BeforeUpdate(ctx, db); err != nil {
			return nil, err
		}
	}
	if in.GetFields() == nil {
		res, err = DefaultStrictUpdateKubeCluster(ctx, in.GetPayload(), db)
	} else {
		res, err = DefaultPatchKubeCluster(ctx, in.GetPayload(), in.GetFields(), db)
	}
	if err != nil {
		return nil, err
	}
	out := &UpdateKubeClusterResponse{Result: res}
	if custom, ok := interface{}(in).(KubeClustersKubeClusterWithAfterUpdate); ok {
		var err error
		if err = custom.AfterUpdate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// KubeClustersKubeClusterWithBeforeUpdate called before DefaultUpdateKubeCluster in the default Update handler
type KubeClustersKubeClusterWithBeforeUpdate interface {
	BeforeUpdate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// KubeClustersKubeClusterWithAfterUpdate called before DefaultUpdateKubeCluster in the default Update handler
type KubeClustersKubeClusterWithAfterUpdate interface {
	AfterUpdate(context.Context, *UpdateKubeClusterResponse, *gorm1.DB) error
}

// Delete ...
func (m *KubeClustersDefaultServer) Delete(ctx context.Context, in *DeleteKubeClusterRequest) (*DeleteKubeClusterResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(KubeClustersKubeClusterWithBeforeDelete); ok {
		var err error
		if db, err = custom.BeforeDelete(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteKubeCluster(ctx, &KubeCluster{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &DeleteKubeClusterResponse{}
	if custom, ok := interface{}(in).(KubeClustersKubeClusterWithAfterDelete); ok {
		var err error
		if err = custom.AfterDelete(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// KubeClustersKubeClusterWithBeforeDelete called before DefaultDeleteKubeCluster in the default Delete handler
type KubeClustersKubeClusterWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// KubeClustersKubeClusterWithAfterDelete called before DefaultDeleteKubeCluster in the default Delete handler
type KubeClustersKubeClusterWithAfterDelete interface {
	AfterDelete(context.Context, *DeleteKubeClusterResponse, *gorm1.DB) error
}

// List ...
func (m *KubeClustersDefaultServer) List(ctx context.Context, in *ListKubeClusterRequest) (*ListKubeClustersResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(KubeClustersKubeClusterWithBeforeList); ok {
		var err error
		if db, err = custom.BeforeList(ctx, db); err != nil {
			return nil, err
		}
	}
	pagedRequest := false
	if in.GetPaging().GetLimit() >= 1 {
		in.Paging.Limit++
		pagedRequest = true
	}
	res, err := DefaultListKubeCluster(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	var resPaging *query1.PageInfo
	if pagedRequest {
		var offset int32
		var size int32 = int32(len(res))
		if size == in.GetPaging().GetLimit() {
			size--
			res = res[:size]
			offset = in.GetPaging().GetOffset() + size
		}
		resPaging = &query1.PageInfo{Offset: offset}
	}
	out := &ListKubeClustersResponse{Results: res, Page: resPaging}
	if custom, ok := interface{}(in).(KubeClustersKubeClusterWithAfterList); ok {
		var err error
		if err = custom.AfterList(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// KubeClustersKubeClusterWithBeforeList called before DefaultListKubeCluster in the default List handler
type KubeClustersKubeClusterWithBeforeList interface {
	BeforeList(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// KubeClustersKubeClusterWithAfterList called before DefaultListKubeCluster in the default List handler
type KubeClustersKubeClusterWithAfterList interface {
	AfterList(context.Context, *ListKubeClustersResponse, *gorm1.DB) error
}
type DeploymentsDefaultServer struct {
}

// Create ...
func (m *DeploymentsDefaultServer) Create(ctx context.Context, in *CreateDeploymentRequest) (*CreateDeploymentResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(DeploymentsDeploymentWithBeforeCreate); ok {
		var err error
		if db, err = custom.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateDeployment(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreateDeploymentResponse{Result: res}
	if custom, ok := interface{}(in).(DeploymentsDeploymentWithAfterCreate); ok {
		var err error
		if err = custom.AfterCreate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// DeploymentsDeploymentWithBeforeCreate called before DefaultCreateDeployment in the default Create handler
type DeploymentsDeploymentWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// DeploymentsDeploymentWithAfterCreate called before DefaultCreateDeployment in the default Create handler
type DeploymentsDeploymentWithAfterCreate interface {
	AfterCreate(context.Context, *CreateDeploymentResponse, *gorm1.DB) error
}

// Read ...
func (m *DeploymentsDefaultServer) Read(ctx context.Context, in *ReadDeploymentRequest) (*ReadDeploymentResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(DeploymentsDeploymentWithBeforeRead); ok {
		var err error
		if db, err = custom.BeforeRead(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadDeployment(ctx, &Deployment{Id: in.GetId()}, db, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ReadDeploymentResponse{Result: res}
	if custom, ok := interface{}(in).(DeploymentsDeploymentWithAfterRead); ok {
		var err error
		if err = custom.AfterRead(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// DeploymentsDeploymentWithBeforeRead called before DefaultReadDeployment in the default Read handler
type DeploymentsDeploymentWithBeforeRead interface {
	BeforeRead(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// DeploymentsDeploymentWithAfterRead called before DefaultReadDeployment in the default Read handler
type DeploymentsDeploymentWithAfterRead interface {
	AfterRead(context.Context, *ReadDeploymentResponse, *gorm1.DB) error
}

// Update ...
func (m *DeploymentsDefaultServer) Update(ctx context.Context, in *UpdateDeploymentRequest) (*UpdateDeploymentResponse, error) {
	var err error
	var res *Deployment
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(DeploymentsDeploymentWithBeforeUpdate); ok {
		var err error
		if db, err = custom.BeforeUpdate(ctx, db); err != nil {
			return nil, err
		}
	}
	if in.GetFields() == nil {
		res, err = DefaultStrictUpdateDeployment(ctx, in.GetPayload(), db)
	} else {
		res, err = DefaultPatchDeployment(ctx, in.GetPayload(), in.GetFields(), db)
	}
	if err != nil {
		return nil, err
	}
	out := &UpdateDeploymentResponse{Result: res}
	if custom, ok := interface{}(in).(DeploymentsDeploymentWithAfterUpdate); ok {
		var err error
		if err = custom.AfterUpdate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// DeploymentsDeploymentWithBeforeUpdate called before DefaultUpdateDeployment in the default Update handler
type DeploymentsDeploymentWithBeforeUpdate interface {
	BeforeUpdate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// DeploymentsDeploymentWithAfterUpdate called before DefaultUpdateDeployment in the default Update handler
type DeploymentsDeploymentWithAfterUpdate interface {
	AfterUpdate(context.Context, *UpdateDeploymentResponse, *gorm1.DB) error
}

// Delete ...
func (m *DeploymentsDefaultServer) Delete(ctx context.Context, in *DeleteDeploymentRequest) (*DeleteDeploymentResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(DeploymentsDeploymentWithBeforeDelete); ok {
		var err error
		if db, err = custom.BeforeDelete(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteDeployment(ctx, &Deployment{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &DeleteDeploymentResponse{}
	if custom, ok := interface{}(in).(DeploymentsDeploymentWithAfterDelete); ok {
		var err error
		if err = custom.AfterDelete(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// DeploymentsDeploymentWithBeforeDelete called before DefaultDeleteDeployment in the default Delete handler
type DeploymentsDeploymentWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// DeploymentsDeploymentWithAfterDelete called before DefaultDeleteDeployment in the default Delete handler
type DeploymentsDeploymentWithAfterDelete interface {
	AfterDelete(context.Context, *DeleteDeploymentResponse, *gorm1.DB) error
}

// List ...
func (m *DeploymentsDefaultServer) List(ctx context.Context, in *ListDeploymentRequest) (*ListDeploymentsResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(DeploymentsDeploymentWithBeforeList); ok {
		var err error
		if db, err = custom.BeforeList(ctx, db); err != nil {
			return nil, err
		}
	}
	pagedRequest := false
	if in.GetPaging().GetLimit() >= 1 {
		in.Paging.Limit++
		pagedRequest = true
	}
	res, err := DefaultListDeployment(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	var resPaging *query1.PageInfo
	if pagedRequest {
		var offset int32
		var size int32 = int32(len(res))
		if size == in.GetPaging().GetLimit() {
			size--
			res = res[:size]
			offset = in.GetPaging().GetOffset() + size
		}
		resPaging = &query1.PageInfo{Offset: offset}
	}
	out := &ListDeploymentsResponse{Results: res, Page: resPaging}
	if custom, ok := interface{}(in).(DeploymentsDeploymentWithAfterList); ok {
		var err error
		if err = custom.AfterList(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// DeploymentsDeploymentWithBeforeList called before DefaultListDeployment in the default List handler
type DeploymentsDeploymentWithBeforeList interface {
	BeforeList(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// DeploymentsDeploymentWithAfterList called before DefaultListDeployment in the default List handler
type DeploymentsDeploymentWithAfterList interface {
	AfterList(context.Context, *ListDeploymentsResponse, *gorm1.DB) error
}
