// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: github.com/seizadi/cmdb/pkg/pb/cmdb.proto

// Generated with protoc-gen-gorm version: master
// Anticipating compatibility with atlas-app-toolkit version: master

/*
Package pb is a generated protocol buffer package.

It is generated from these files:
	github.com/seizadi/cmdb/pkg/pb/cmdb.proto

It has these top-level messages:
	VersionResponse
	Region
	CreateRegionRequest
	CreateRegionResponse
	ReadRegionRequest
	ReadRegionResponse
	UpdateRegionRequest
	UpdateRegionResponse
	DeleteRegionRequest
	DeleteRegionResponse
	ListRegionRequest
	ListRegionsResponse
	Container
	CreateContainerRequest
	CreateContainerResponse
	ReadContainerRequest
	ReadContainerResponse
	UpdateContainerRequest
	UpdateContainerResponse
	DeleteContainerRequest
	DeleteContainerResponse
	ListContainerRequest
	ListContainersResponse
	VersionTag
	CreateVersionTagRequest
	CreateVersionTagResponse
	ReadVersionTagRequest
	ReadVersionTagResponse
	UpdateVersionTagRequest
	UpdateVersionTagResponse
	DeleteVersionTagRequest
	DeleteVersionTagResponse
	ListVersionTagRequest
	ListVersionTagsResponse
*/
package pb

import context "context"
import errors "errors"

import auth1 "github.com/infobloxopen/atlas-app-toolkit/auth"
import field_mask1 "google.golang.org/genproto/protobuf/field_mask"
import gateway1 "github.com/infobloxopen/atlas-app-toolkit/gateway"
import gorm1 "github.com/jinzhu/gorm"
import gorm2 "github.com/infobloxopen/atlas-app-toolkit/gorm"
import query1 "github.com/infobloxopen/atlas-app-toolkit/query"
import resource1 "github.com/infobloxopen/atlas-app-toolkit/gorm/resource"

import fmt "fmt"
import math "math"
import _ "github.com/golang/protobuf/ptypes/empty"
import _ "google.golang.org/genproto/protobuf/field_mask"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import _ "github.com/lyft/protoc-gen-validate/validate"
import _ "github.com/grpc-ecosystem/grpc-gateway/protoc-gen-swagger/options"
import _ "github.com/infobloxopen/atlas-app-toolkit/query"
import _ "github.com/infobloxopen/atlas-app-toolkit/rpc/resource"
import _ "github.com/infobloxopen/protoc-gen-atlas-query-validate/options"
import _ "github.com/infobloxopen/protoc-gen-atlas-validate/options"

// Reference imports to suppress errors if they are not otherwise used.
var _ = fmt.Errorf
var _ = math.Inf

type RegionORM struct {
	AccountID   string
	Description string
	Id          int64 `gorm:"type:serial;primary_key"`
	Name        string
}

// TableName overrides the default tablename generated by GORM
func (RegionORM) TableName() string {
	return "regions"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Region) ToORM(ctx context.Context) (RegionORM, error) {
	to := RegionORM{}
	var err error
	if prehook, ok := interface{}(m).(RegionWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.DecodeInt64(&Region{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Description = m.Description
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(RegionWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *RegionORM) ToPB(ctx context.Context) (Region, error) {
	to := Region{}
	var err error
	if prehook, ok := interface{}(m).(RegionWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&Region{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Description = m.Description
	if posthook, ok := interface{}(m).(RegionWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Region the arg will be the target, the caller the one being converted from

// RegionBeforeToORM called before default ToORM code
type RegionWithBeforeToORM interface {
	BeforeToORM(context.Context, *RegionORM) error
}

// RegionAfterToORM called after default ToORM code
type RegionWithAfterToORM interface {
	AfterToORM(context.Context, *RegionORM) error
}

// RegionBeforeToPB called before default ToPB code
type RegionWithBeforeToPB interface {
	BeforeToPB(context.Context, *Region) error
}

// RegionAfterToPB called after default ToPB code
type RegionWithAfterToPB interface {
	AfterToPB(context.Context, *Region) error
}

type ContainerORM struct {
	AccountID       string
	ContainerName   string
	Description     string
	Digest          string
	Id              int64 `gorm:"type:serial;primary_key"`
	ImagePullPolicy string
	ImageRepo       string
	ImageTag        string
	Name            string
}

// TableName overrides the default tablename generated by GORM
func (ContainerORM) TableName() string {
	return "containers"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Container) ToORM(ctx context.Context) (ContainerORM, error) {
	to := ContainerORM{}
	var err error
	if prehook, ok := interface{}(m).(ContainerWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.DecodeInt64(&Container{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Description = m.Description
	to.ContainerName = m.ContainerName
	to.ImageRepo = m.ImageRepo
	to.ImageTag = m.ImageTag
	to.ImagePullPolicy = m.ImagePullPolicy
	to.Digest = m.Digest
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(ContainerWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ContainerORM) ToPB(ctx context.Context) (Container, error) {
	to := Container{}
	var err error
	if prehook, ok := interface{}(m).(ContainerWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&Container{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Description = m.Description
	to.ContainerName = m.ContainerName
	to.ImageRepo = m.ImageRepo
	to.ImageTag = m.ImageTag
	to.ImagePullPolicy = m.ImagePullPolicy
	to.Digest = m.Digest
	if posthook, ok := interface{}(m).(ContainerWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Container the arg will be the target, the caller the one being converted from

// ContainerBeforeToORM called before default ToORM code
type ContainerWithBeforeToORM interface {
	BeforeToORM(context.Context, *ContainerORM) error
}

// ContainerAfterToORM called after default ToORM code
type ContainerWithAfterToORM interface {
	AfterToORM(context.Context, *ContainerORM) error
}

// ContainerBeforeToPB called before default ToPB code
type ContainerWithBeforeToPB interface {
	BeforeToPB(context.Context, *Container) error
}

// ContainerAfterToPB called after default ToPB code
type ContainerWithAfterToPB interface {
	AfterToPB(context.Context, *Container) error
}

type VersionTagORM struct {
	AccountID   string
	Commit      string
	Description string
	Id          int64 `gorm:"type:serial;primary_key"`
	Name        string
	Repo        string
	Version     string
}

// TableName overrides the default tablename generated by GORM
func (VersionTagORM) TableName() string {
	return "version_tags"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *VersionTag) ToORM(ctx context.Context) (VersionTagORM, error) {
	to := VersionTagORM{}
	var err error
	if prehook, ok := interface{}(m).(VersionTagWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.DecodeInt64(&VersionTag{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Description = m.Description
	to.Version = m.Version
	to.Repo = m.Repo
	to.Commit = m.Commit
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(VersionTagWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *VersionTagORM) ToPB(ctx context.Context) (VersionTag, error) {
	to := VersionTag{}
	var err error
	if prehook, ok := interface{}(m).(VersionTagWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&VersionTag{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Description = m.Description
	to.Version = m.Version
	to.Repo = m.Repo
	to.Commit = m.Commit
	if posthook, ok := interface{}(m).(VersionTagWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type VersionTag the arg will be the target, the caller the one being converted from

// VersionTagBeforeToORM called before default ToORM code
type VersionTagWithBeforeToORM interface {
	BeforeToORM(context.Context, *VersionTagORM) error
}

// VersionTagAfterToORM called after default ToORM code
type VersionTagWithAfterToORM interface {
	AfterToORM(context.Context, *VersionTagORM) error
}

// VersionTagBeforeToPB called before default ToPB code
type VersionTagWithBeforeToPB interface {
	BeforeToPB(context.Context, *VersionTag) error
}

// VersionTagAfterToPB called after default ToPB code
type VersionTagWithAfterToPB interface {
	AfterToPB(context.Context, *VersionTag) error
}

// DefaultCreateRegion executes a basic gorm create call
func DefaultCreateRegion(ctx context.Context, in *Region, db *gorm1.DB) (*Region, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultCreateRegion")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(RegionORMWithBeforeCreate); ok {
		if db, err = hook.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(RegionORMWithAfterCreate); ok {
		if err = hook.AfterCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type RegionORMWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type RegionORMWithAfterCreate interface {
	AfterCreate(context.Context, *gorm1.DB) error
}

// DefaultReadRegion executes a basic gorm read call
func DefaultReadRegion(ctx context.Context, in *Region, db *gorm1.DB, fs *query1.FieldSelection) (*Region, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultReadRegion")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.New("DefaultReadRegion requires a non-zero primary key")
	}
	if hook, ok := interface{}(&ormObj).(RegionORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, fs, &RegionORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(RegionORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	ormResponse := RegionORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(RegionORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type RegionORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type RegionORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type RegionORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) error
}

func DefaultDeleteRegion(ctx context.Context, in *Region, db *gorm1.DB) error {
	if in == nil {
		return errors.New("Nil argument to DefaultDeleteRegion")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.New("A non-zero ID value is required for a delete call")
	}
	if hook, ok := interface{}(&ormObj).(RegionORMWithBeforeDelete); ok {
		if db, err = hook.BeforeDelete(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&RegionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(RegionORMWithAfterDelete); ok {
		err = hook.AfterDelete(ctx, db)
	}
	return err
}

type RegionORMWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type RegionORMWithAfterDelete interface {
	AfterDelete(context.Context, *gorm1.DB) error
}

// DefaultStrictUpdateRegion clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateRegion(ctx context.Context, in *Region, db *gorm1.DB) (*Region, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateRegion")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	var count int64
	lockedRow := &RegionORM{}
	count = db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow).RowsAffected
	if hook, ok := interface{}(&ormObj).(RegionORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(RegionORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(RegionORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	if count == 0 {
		err = gateway1.SetCreated(ctx, "")
	}
	return &pbResponse, err
}

type RegionORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type RegionORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type RegionORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchRegion executes a basic gorm update call with patch behavior
func DefaultPatchRegion(ctx context.Context, in *Region, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Region, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultPatchRegion")
	}
	var pbObj Region
	var err error
	if hook, ok := interface{}(&pbObj).(RegionWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadRegion(ctx, &Region{Id: in.GetId()}, db, nil)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(RegionWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskRegion(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(RegionWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateRegion(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(RegionWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type RegionWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Region, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type RegionWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Region, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type RegionWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Region, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type RegionWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Region, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultApplyFieldMaskRegion patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskRegion(ctx context.Context, patchee *Region, patcher *Region, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Region, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.New("Patchee inputs to DefaultApplyFieldMaskRegion must be non-nil")
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListRegion executes a gorm list call
func DefaultListRegion(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*Region, error) {
	in := Region{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(RegionORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &RegionORM{}, &Region{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(RegionORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []RegionORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(RegionORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Region{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type RegionORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type RegionORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type RegionORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]RegionORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateContainer executes a basic gorm create call
func DefaultCreateContainer(ctx context.Context, in *Container, db *gorm1.DB) (*Container, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultCreateContainer")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ContainerORMWithBeforeCreate); ok {
		if db, err = hook.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ContainerORMWithAfterCreate); ok {
		if err = hook.AfterCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ContainerORMWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ContainerORMWithAfterCreate interface {
	AfterCreate(context.Context, *gorm1.DB) error
}

// DefaultReadContainer executes a basic gorm read call
func DefaultReadContainer(ctx context.Context, in *Container, db *gorm1.DB, fs *query1.FieldSelection) (*Container, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultReadContainer")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.New("DefaultReadContainer requires a non-zero primary key")
	}
	if hook, ok := interface{}(&ormObj).(ContainerORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, fs, &ContainerORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ContainerORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	ormResponse := ContainerORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ContainerORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ContainerORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type ContainerORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type ContainerORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) error
}

func DefaultDeleteContainer(ctx context.Context, in *Container, db *gorm1.DB) error {
	if in == nil {
		return errors.New("Nil argument to DefaultDeleteContainer")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.New("A non-zero ID value is required for a delete call")
	}
	if hook, ok := interface{}(&ormObj).(ContainerORMWithBeforeDelete); ok {
		if db, err = hook.BeforeDelete(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ContainerORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ContainerORMWithAfterDelete); ok {
		err = hook.AfterDelete(ctx, db)
	}
	return err
}

type ContainerORMWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ContainerORMWithAfterDelete interface {
	AfterDelete(context.Context, *gorm1.DB) error
}

// DefaultStrictUpdateContainer clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateContainer(ctx context.Context, in *Container, db *gorm1.DB) (*Container, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateContainer")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	var count int64
	lockedRow := &ContainerORM{}
	count = db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow).RowsAffected
	if hook, ok := interface{}(&ormObj).(ContainerORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ContainerORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ContainerORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	if count == 0 {
		err = gateway1.SetCreated(ctx, "")
	}
	return &pbResponse, err
}

type ContainerORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ContainerORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ContainerORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchContainer executes a basic gorm update call with patch behavior
func DefaultPatchContainer(ctx context.Context, in *Container, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Container, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultPatchContainer")
	}
	var pbObj Container
	var err error
	if hook, ok := interface{}(&pbObj).(ContainerWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadContainer(ctx, &Container{Id: in.GetId()}, db, nil)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ContainerWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskContainer(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ContainerWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateContainer(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ContainerWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ContainerWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Container, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ContainerWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Container, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ContainerWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Container, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ContainerWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Container, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultApplyFieldMaskContainer patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskContainer(ctx context.Context, patchee *Container, patcher *Container, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Container, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.New("Patchee inputs to DefaultApplyFieldMaskContainer must be non-nil")
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"ContainerName" {
			patchee.ContainerName = patcher.ContainerName
			continue
		}
		if f == prefix+"ImageRepo" {
			patchee.ImageRepo = patcher.ImageRepo
			continue
		}
		if f == prefix+"ImageTag" {
			patchee.ImageTag = patcher.ImageTag
			continue
		}
		if f == prefix+"ImagePullPolicy" {
			patchee.ImagePullPolicy = patcher.ImagePullPolicy
			continue
		}
		if f == prefix+"Digest" {
			patchee.Digest = patcher.Digest
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListContainer executes a gorm list call
func DefaultListContainer(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*Container, error) {
	in := Container{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ContainerORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &ContainerORM{}, &Container{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ContainerORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ContainerORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ContainerORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Container{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ContainerORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ContainerORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ContainerORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]ContainerORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateVersionTag executes a basic gorm create call
func DefaultCreateVersionTag(ctx context.Context, in *VersionTag, db *gorm1.DB) (*VersionTag, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultCreateVersionTag")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VersionTagORMWithBeforeCreate); ok {
		if db, err = hook.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VersionTagORMWithAfterCreate); ok {
		if err = hook.AfterCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type VersionTagORMWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type VersionTagORMWithAfterCreate interface {
	AfterCreate(context.Context, *gorm1.DB) error
}

// DefaultReadVersionTag executes a basic gorm read call
func DefaultReadVersionTag(ctx context.Context, in *VersionTag, db *gorm1.DB, fs *query1.FieldSelection) (*VersionTag, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultReadVersionTag")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.New("DefaultReadVersionTag requires a non-zero primary key")
	}
	if hook, ok := interface{}(&ormObj).(VersionTagORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, fs, &VersionTagORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VersionTagORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	ormResponse := VersionTagORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(VersionTagORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type VersionTagORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type VersionTagORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type VersionTagORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) error
}

func DefaultDeleteVersionTag(ctx context.Context, in *VersionTag, db *gorm1.DB) error {
	if in == nil {
		return errors.New("Nil argument to DefaultDeleteVersionTag")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.New("A non-zero ID value is required for a delete call")
	}
	if hook, ok := interface{}(&ormObj).(VersionTagORMWithBeforeDelete); ok {
		if db, err = hook.BeforeDelete(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&VersionTagORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(VersionTagORMWithAfterDelete); ok {
		err = hook.AfterDelete(ctx, db)
	}
	return err
}

type VersionTagORMWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type VersionTagORMWithAfterDelete interface {
	AfterDelete(context.Context, *gorm1.DB) error
}

// DefaultStrictUpdateVersionTag clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateVersionTag(ctx context.Context, in *VersionTag, db *gorm1.DB) (*VersionTag, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateVersionTag")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	var count int64
	lockedRow := &VersionTagORM{}
	count = db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow).RowsAffected
	if hook, ok := interface{}(&ormObj).(VersionTagORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(VersionTagORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VersionTagORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	if count == 0 {
		err = gateway1.SetCreated(ctx, "")
	}
	return &pbResponse, err
}

type VersionTagORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type VersionTagORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type VersionTagORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchVersionTag executes a basic gorm update call with patch behavior
func DefaultPatchVersionTag(ctx context.Context, in *VersionTag, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*VersionTag, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultPatchVersionTag")
	}
	var pbObj VersionTag
	var err error
	if hook, ok := interface{}(&pbObj).(VersionTagWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadVersionTag(ctx, &VersionTag{Id: in.GetId()}, db, nil)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(VersionTagWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskVersionTag(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(VersionTagWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateVersionTag(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(VersionTagWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type VersionTagWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *VersionTag, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type VersionTagWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *VersionTag, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type VersionTagWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *VersionTag, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type VersionTagWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *VersionTag, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultApplyFieldMaskVersionTag patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskVersionTag(ctx context.Context, patchee *VersionTag, patcher *VersionTag, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*VersionTag, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.New("Patchee inputs to DefaultApplyFieldMaskVersionTag must be non-nil")
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"Version" {
			patchee.Version = patcher.Version
			continue
		}
		if f == prefix+"Repo" {
			patchee.Repo = patcher.Repo
			continue
		}
		if f == prefix+"Commit" {
			patchee.Commit = patcher.Commit
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListVersionTag executes a gorm list call
func DefaultListVersionTag(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*VersionTag, error) {
	in := VersionTag{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VersionTagORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &VersionTagORM{}, &VersionTag{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VersionTagORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []VersionTagORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VersionTagORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*VersionTag{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type VersionTagORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type VersionTagORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type VersionTagORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]VersionTagORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}
type RegionsDefaultServer struct {
}

// Create ...
func (m *RegionsDefaultServer) Create(ctx context.Context, in *CreateRegionRequest) (*CreateRegionResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors.New("Database Transaction For Request Missing")
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(RegionsRegionWithBeforeCreate); ok {
		var err error
		if db, err = custom.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateRegion(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreateRegionResponse{Result: res}
	if custom, ok := interface{}(in).(RegionsRegionWithAfterCreate); ok {
		var err error
		if err = custom.AfterCreate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// RegionsRegionWithBeforeCreate called before DefaultCreateRegion in the default Create handler
type RegionsRegionWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// RegionsRegionWithAfterCreate called before DefaultCreateRegion in the default Create handler
type RegionsRegionWithAfterCreate interface {
	AfterCreate(context.Context, *CreateRegionResponse, *gorm1.DB) error
}

// Read ...
func (m *RegionsDefaultServer) Read(ctx context.Context, in *ReadRegionRequest) (*ReadRegionResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors.New("Database Transaction For Request Missing")
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(RegionsRegionWithBeforeRead); ok {
		var err error
		if db, err = custom.BeforeRead(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadRegion(ctx, &Region{Id: in.GetId()}, db, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ReadRegionResponse{Result: res}
	if custom, ok := interface{}(in).(RegionsRegionWithAfterRead); ok {
		var err error
		if err = custom.AfterRead(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// RegionsRegionWithBeforeRead called before DefaultReadRegion in the default Read handler
type RegionsRegionWithBeforeRead interface {
	BeforeRead(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// RegionsRegionWithAfterRead called before DefaultReadRegion in the default Read handler
type RegionsRegionWithAfterRead interface {
	AfterRead(context.Context, *ReadRegionResponse, *gorm1.DB) error
}

// Update ...
func (m *RegionsDefaultServer) Update(ctx context.Context, in *UpdateRegionRequest) (*UpdateRegionResponse, error) {
	var err error
	var res *Region
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors.New("Database Transaction For Request Missing")
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(RegionsRegionWithBeforeUpdate); ok {
		var err error
		if db, err = custom.BeforeUpdate(ctx, db); err != nil {
			return nil, err
		}
	}
	if in.GetFields() == nil {
		res, err = DefaultStrictUpdateRegion(ctx, in.GetPayload(), db)
	} else {
		res, err = DefaultPatchRegion(ctx, in.GetPayload(), in.GetFields(), db)
	}
	if err != nil {
		return nil, err
	}
	out := &UpdateRegionResponse{Result: res}
	if custom, ok := interface{}(in).(RegionsRegionWithAfterUpdate); ok {
		var err error
		if err = custom.AfterUpdate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// RegionsRegionWithBeforeUpdate called before DefaultUpdateRegion in the default Update handler
type RegionsRegionWithBeforeUpdate interface {
	BeforeUpdate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// RegionsRegionWithAfterUpdate called before DefaultUpdateRegion in the default Update handler
type RegionsRegionWithAfterUpdate interface {
	AfterUpdate(context.Context, *UpdateRegionResponse, *gorm1.DB) error
}

// Delete ...
func (m *RegionsDefaultServer) Delete(ctx context.Context, in *DeleteRegionRequest) (*DeleteRegionResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors.New("Database Transaction For Request Missing")
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(RegionsRegionWithBeforeDelete); ok {
		var err error
		if db, err = custom.BeforeDelete(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteRegion(ctx, &Region{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &DeleteRegionResponse{}
	if custom, ok := interface{}(in).(RegionsRegionWithAfterDelete); ok {
		var err error
		if err = custom.AfterDelete(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// RegionsRegionWithBeforeDelete called before DefaultDeleteRegion in the default Delete handler
type RegionsRegionWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// RegionsRegionWithAfterDelete called before DefaultDeleteRegion in the default Delete handler
type RegionsRegionWithAfterDelete interface {
	AfterDelete(context.Context, *DeleteRegionResponse, *gorm1.DB) error
}

// List ...
func (m *RegionsDefaultServer) List(ctx context.Context, in *ListRegionRequest) (*ListRegionsResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors.New("Database Transaction For Request Missing")
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(RegionsRegionWithBeforeList); ok {
		var err error
		if db, err = custom.BeforeList(ctx, db); err != nil {
			return nil, err
		}
	}
	pagedRequest := false
	if in.GetPaging().GetLimit() >= 1 {
		in.Paging.Limit++
		pagedRequest = true
	}
	res, err := DefaultListRegion(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	var resPaging *query1.PageInfo
	if pagedRequest {
		var offset int32
		var size int32 = int32(len(res))
		if size == in.GetPaging().GetLimit() {
			size--
			res = res[:size]
			offset = in.GetPaging().GetOffset() + size
		}
		resPaging = &query1.PageInfo{Offset: offset}
	}
	out := &ListRegionsResponse{Results: res, Page: resPaging}
	if custom, ok := interface{}(in).(RegionsRegionWithAfterList); ok {
		var err error
		if err = custom.AfterList(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// RegionsRegionWithBeforeList called before DefaultListRegion in the default List handler
type RegionsRegionWithBeforeList interface {
	BeforeList(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// RegionsRegionWithAfterList called before DefaultListRegion in the default List handler
type RegionsRegionWithAfterList interface {
	AfterList(context.Context, *ListRegionsResponse, *gorm1.DB) error
}
type ContainersDefaultServer struct {
}

// Create ...
func (m *ContainersDefaultServer) Create(ctx context.Context, in *CreateContainerRequest) (*CreateContainerResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors.New("Database Transaction For Request Missing")
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(ContainersContainerWithBeforeCreate); ok {
		var err error
		if db, err = custom.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateContainer(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreateContainerResponse{Result: res}
	if custom, ok := interface{}(in).(ContainersContainerWithAfterCreate); ok {
		var err error
		if err = custom.AfterCreate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ContainersContainerWithBeforeCreate called before DefaultCreateContainer in the default Create handler
type ContainersContainerWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ContainersContainerWithAfterCreate called before DefaultCreateContainer in the default Create handler
type ContainersContainerWithAfterCreate interface {
	AfterCreate(context.Context, *CreateContainerResponse, *gorm1.DB) error
}

// Read ...
func (m *ContainersDefaultServer) Read(ctx context.Context, in *ReadContainerRequest) (*ReadContainerResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors.New("Database Transaction For Request Missing")
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(ContainersContainerWithBeforeRead); ok {
		var err error
		if db, err = custom.BeforeRead(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadContainer(ctx, &Container{Id: in.GetId()}, db, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ReadContainerResponse{Result: res}
	if custom, ok := interface{}(in).(ContainersContainerWithAfterRead); ok {
		var err error
		if err = custom.AfterRead(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ContainersContainerWithBeforeRead called before DefaultReadContainer in the default Read handler
type ContainersContainerWithBeforeRead interface {
	BeforeRead(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ContainersContainerWithAfterRead called before DefaultReadContainer in the default Read handler
type ContainersContainerWithAfterRead interface {
	AfterRead(context.Context, *ReadContainerResponse, *gorm1.DB) error
}

// Update ...
func (m *ContainersDefaultServer) Update(ctx context.Context, in *UpdateContainerRequest) (*UpdateContainerResponse, error) {
	var err error
	var res *Container
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors.New("Database Transaction For Request Missing")
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(ContainersContainerWithBeforeUpdate); ok {
		var err error
		if db, err = custom.BeforeUpdate(ctx, db); err != nil {
			return nil, err
		}
	}
	if in.GetFields() == nil {
		res, err = DefaultStrictUpdateContainer(ctx, in.GetPayload(), db)
	} else {
		res, err = DefaultPatchContainer(ctx, in.GetPayload(), in.GetFields(), db)
	}
	if err != nil {
		return nil, err
	}
	out := &UpdateContainerResponse{Result: res}
	if custom, ok := interface{}(in).(ContainersContainerWithAfterUpdate); ok {
		var err error
		if err = custom.AfterUpdate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ContainersContainerWithBeforeUpdate called before DefaultUpdateContainer in the default Update handler
type ContainersContainerWithBeforeUpdate interface {
	BeforeUpdate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ContainersContainerWithAfterUpdate called before DefaultUpdateContainer in the default Update handler
type ContainersContainerWithAfterUpdate interface {
	AfterUpdate(context.Context, *UpdateContainerResponse, *gorm1.DB) error
}

// Delete ...
func (m *ContainersDefaultServer) Delete(ctx context.Context, in *DeleteContainerRequest) (*DeleteContainerResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors.New("Database Transaction For Request Missing")
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(ContainersContainerWithBeforeDelete); ok {
		var err error
		if db, err = custom.BeforeDelete(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteContainer(ctx, &Container{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &DeleteContainerResponse{}
	if custom, ok := interface{}(in).(ContainersContainerWithAfterDelete); ok {
		var err error
		if err = custom.AfterDelete(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ContainersContainerWithBeforeDelete called before DefaultDeleteContainer in the default Delete handler
type ContainersContainerWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ContainersContainerWithAfterDelete called before DefaultDeleteContainer in the default Delete handler
type ContainersContainerWithAfterDelete interface {
	AfterDelete(context.Context, *DeleteContainerResponse, *gorm1.DB) error
}

// List ...
func (m *ContainersDefaultServer) List(ctx context.Context, in *ListContainerRequest) (*ListContainersResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors.New("Database Transaction For Request Missing")
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(ContainersContainerWithBeforeList); ok {
		var err error
		if db, err = custom.BeforeList(ctx, db); err != nil {
			return nil, err
		}
	}
	pagedRequest := false
	if in.GetPaging().GetLimit() >= 1 {
		in.Paging.Limit++
		pagedRequest = true
	}
	res, err := DefaultListContainer(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	var resPaging *query1.PageInfo
	if pagedRequest {
		var offset int32
		var size int32 = int32(len(res))
		if size == in.GetPaging().GetLimit() {
			size--
			res = res[:size]
			offset = in.GetPaging().GetOffset() + size
		}
		resPaging = &query1.PageInfo{Offset: offset}
	}
	out := &ListContainersResponse{Results: res, Page: resPaging}
	if custom, ok := interface{}(in).(ContainersContainerWithAfterList); ok {
		var err error
		if err = custom.AfterList(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ContainersContainerWithBeforeList called before DefaultListContainer in the default List handler
type ContainersContainerWithBeforeList interface {
	BeforeList(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ContainersContainerWithAfterList called before DefaultListContainer in the default List handler
type ContainersContainerWithAfterList interface {
	AfterList(context.Context, *ListContainersResponse, *gorm1.DB) error
}
type VersionTagsDefaultServer struct {
}

// Create ...
func (m *VersionTagsDefaultServer) Create(ctx context.Context, in *CreateVersionTagRequest) (*CreateVersionTagResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors.New("Database Transaction For Request Missing")
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(VersionTagsVersionTagWithBeforeCreate); ok {
		var err error
		if db, err = custom.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateVersionTag(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreateVersionTagResponse{Result: res}
	if custom, ok := interface{}(in).(VersionTagsVersionTagWithAfterCreate); ok {
		var err error
		if err = custom.AfterCreate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// VersionTagsVersionTagWithBeforeCreate called before DefaultCreateVersionTag in the default Create handler
type VersionTagsVersionTagWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// VersionTagsVersionTagWithAfterCreate called before DefaultCreateVersionTag in the default Create handler
type VersionTagsVersionTagWithAfterCreate interface {
	AfterCreate(context.Context, *CreateVersionTagResponse, *gorm1.DB) error
}

// Read ...
func (m *VersionTagsDefaultServer) Read(ctx context.Context, in *ReadVersionTagRequest) (*ReadVersionTagResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors.New("Database Transaction For Request Missing")
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(VersionTagsVersionTagWithBeforeRead); ok {
		var err error
		if db, err = custom.BeforeRead(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadVersionTag(ctx, &VersionTag{Id: in.GetId()}, db, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ReadVersionTagResponse{Result: res}
	if custom, ok := interface{}(in).(VersionTagsVersionTagWithAfterRead); ok {
		var err error
		if err = custom.AfterRead(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// VersionTagsVersionTagWithBeforeRead called before DefaultReadVersionTag in the default Read handler
type VersionTagsVersionTagWithBeforeRead interface {
	BeforeRead(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// VersionTagsVersionTagWithAfterRead called before DefaultReadVersionTag in the default Read handler
type VersionTagsVersionTagWithAfterRead interface {
	AfterRead(context.Context, *ReadVersionTagResponse, *gorm1.DB) error
}

// Update ...
func (m *VersionTagsDefaultServer) Update(ctx context.Context, in *UpdateVersionTagRequest) (*UpdateVersionTagResponse, error) {
	var err error
	var res *VersionTag
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors.New("Database Transaction For Request Missing")
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(VersionTagsVersionTagWithBeforeUpdate); ok {
		var err error
		if db, err = custom.BeforeUpdate(ctx, db); err != nil {
			return nil, err
		}
	}
	if in.GetFields() == nil {
		res, err = DefaultStrictUpdateVersionTag(ctx, in.GetPayload(), db)
	} else {
		res, err = DefaultPatchVersionTag(ctx, in.GetPayload(), in.GetFields(), db)
	}
	if err != nil {
		return nil, err
	}
	out := &UpdateVersionTagResponse{Result: res}
	if custom, ok := interface{}(in).(VersionTagsVersionTagWithAfterUpdate); ok {
		var err error
		if err = custom.AfterUpdate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// VersionTagsVersionTagWithBeforeUpdate called before DefaultUpdateVersionTag in the default Update handler
type VersionTagsVersionTagWithBeforeUpdate interface {
	BeforeUpdate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// VersionTagsVersionTagWithAfterUpdate called before DefaultUpdateVersionTag in the default Update handler
type VersionTagsVersionTagWithAfterUpdate interface {
	AfterUpdate(context.Context, *UpdateVersionTagResponse, *gorm1.DB) error
}

// Delete ...
func (m *VersionTagsDefaultServer) Delete(ctx context.Context, in *DeleteVersionTagRequest) (*DeleteVersionTagResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors.New("Database Transaction For Request Missing")
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(VersionTagsVersionTagWithBeforeDelete); ok {
		var err error
		if db, err = custom.BeforeDelete(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteVersionTag(ctx, &VersionTag{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &DeleteVersionTagResponse{}
	if custom, ok := interface{}(in).(VersionTagsVersionTagWithAfterDelete); ok {
		var err error
		if err = custom.AfterDelete(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// VersionTagsVersionTagWithBeforeDelete called before DefaultDeleteVersionTag in the default Delete handler
type VersionTagsVersionTagWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// VersionTagsVersionTagWithAfterDelete called before DefaultDeleteVersionTag in the default Delete handler
type VersionTagsVersionTagWithAfterDelete interface {
	AfterDelete(context.Context, *DeleteVersionTagResponse, *gorm1.DB) error
}

// List ...
func (m *VersionTagsDefaultServer) List(ctx context.Context, in *ListVersionTagRequest) (*ListVersionTagsResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors.New("Database Transaction For Request Missing")
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(VersionTagsVersionTagWithBeforeList); ok {
		var err error
		if db, err = custom.BeforeList(ctx, db); err != nil {
			return nil, err
		}
	}
	pagedRequest := false
	if in.GetPaging().GetLimit() >= 1 {
		in.Paging.Limit++
		pagedRequest = true
	}
	res, err := DefaultListVersionTag(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	var resPaging *query1.PageInfo
	if pagedRequest {
		var offset int32
		var size int32 = int32(len(res))
		if size == in.GetPaging().GetLimit() {
			size--
			res = res[:size]
			offset = in.GetPaging().GetOffset() + size
		}
		resPaging = &query1.PageInfo{Offset: offset}
	}
	out := &ListVersionTagsResponse{Results: res, Page: resPaging}
	if custom, ok := interface{}(in).(VersionTagsVersionTagWithAfterList); ok {
		var err error
		if err = custom.AfterList(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// VersionTagsVersionTagWithBeforeList called before DefaultListVersionTag in the default List handler
type VersionTagsVersionTagWithBeforeList interface {
	BeforeList(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// VersionTagsVersionTagWithAfterList called before DefaultListVersionTag in the default List handler
type VersionTagsVersionTagWithAfterList interface {
	AfterList(context.Context, *ListVersionTagsResponse, *gorm1.DB) error
}
