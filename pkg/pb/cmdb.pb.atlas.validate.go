// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: github.com/seizadi/cmdb/pkg/pb/cmdb.proto

package pb // import "github.com/seizadi/cmdb/pkg/pb"

import bytes "bytes"
import context "context"
import fmt "fmt"
import http "net/http"
import ioutil "io/ioutil"
import json "encoding/json"
import metadata "google.golang.org/grpc/metadata"
import runtime "github.com/grpc-ecosystem/grpc-gateway/runtime"
import runtime1 "github.com/infobloxopen/protoc-gen-atlas-validate/runtime"
import resource "github.com/infobloxopen/atlas-app-toolkit/rpc/resource"
import query "github.com/infobloxopen/atlas-app-toolkit/query"
import field_mask "google.golang.org/genproto/protobuf/field_mask"
import types "github.com/infobloxopen/protoc-gen-gorm/types"
import proto "github.com/gogo/protobuf/proto"
import math "math"
import _ "github.com/golang/protobuf/ptypes/empty"
import _ "github.com/grpc-ecosystem/grpc-gateway/protoc-gen-swagger/options"
import _ "github.com/infobloxopen/atlas-app-toolkit/query"
import _ "github.com/infobloxopen/atlas-app-toolkit/rpc/resource"
import _ "github.com/infobloxopen/protoc-gen-atlas-query-validate/options"
import _ "github.com/infobloxopen/protoc-gen-atlas-validate/options"
import _ "github.com/infobloxopen/protoc-gen-gorm/options"
import _ "github.com/infobloxopen/protoc-gen-gorm/types"
import _ "github.com/lyft/protoc-gen-validate/validate"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import _ "google.golang.org/genproto/protobuf/field_mask"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// validate_Cmdb_GetVersion_0 is an entrypoint for validating "GET" HTTP request
// that match *.pb.gw.go/pattern_Cmdb_GetVersion_0.
func validate_Cmdb_GetVersion_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_Vaults_Create_0 is an entrypoint for validating "POST" HTTP request
// that match *.pb.gw.go/pattern_Vaults_Create_0.
func validate_Vaults_Create_0(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_Vault(ctx, r, "")
}

// validate_Vaults_Read_0 is an entrypoint for validating "GET" HTTP request
// that match *.pb.gw.go/pattern_Vaults_Read_0.
func validate_Vaults_Read_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_Vaults_Update_0 is an entrypoint for validating "PUT" HTTP request
// that match *.pb.gw.go/pattern_Vaults_Update_0.
func validate_Vaults_Update_0(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_Vault(ctx, r, "")
}

// validate_Vaults_Update_1 is an entrypoint for validating "PATCH" HTTP request
// that match *.pb.gw.go/pattern_Vaults_Update_1.
func validate_Vaults_Update_1(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_Vault(ctx, r, "")
}

// validate_Vaults_Delete_0 is an entrypoint for validating "DELETE" HTTP request
// that match *.pb.gw.go/pattern_Vaults_Delete_0.
func validate_Vaults_Delete_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_Vaults_List_0 is an entrypoint for validating "GET" HTTP request
// that match *.pb.gw.go/pattern_Vaults_List_0.
func validate_Vaults_List_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_VersionTags_Create_0 is an entrypoint for validating "POST" HTTP request
// that match *.pb.gw.go/pattern_VersionTags_Create_0.
func validate_VersionTags_Create_0(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_VersionTag(ctx, r, "")
}

// validate_VersionTags_Read_0 is an entrypoint for validating "GET" HTTP request
// that match *.pb.gw.go/pattern_VersionTags_Read_0.
func validate_VersionTags_Read_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_VersionTags_Update_0 is an entrypoint for validating "PUT" HTTP request
// that match *.pb.gw.go/pattern_VersionTags_Update_0.
func validate_VersionTags_Update_0(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_VersionTag(ctx, r, "")
}

// validate_VersionTags_Update_1 is an entrypoint for validating "PATCH" HTTP request
// that match *.pb.gw.go/pattern_VersionTags_Update_1.
func validate_VersionTags_Update_1(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_VersionTag(ctx, r, "")
}

// validate_VersionTags_Delete_0 is an entrypoint for validating "DELETE" HTTP request
// that match *.pb.gw.go/pattern_VersionTags_Delete_0.
func validate_VersionTags_Delete_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_VersionTags_List_0 is an entrypoint for validating "GET" HTTP request
// that match *.pb.gw.go/pattern_VersionTags_List_0.
func validate_VersionTags_List_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_ApplicationInstances_Create_0 is an entrypoint for validating "POST" HTTP request
// that match *.pb.gw.go/pattern_ApplicationInstances_Create_0.
func validate_ApplicationInstances_Create_0(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_ApplicationInstance(ctx, r, "")
}

// validate_ApplicationInstances_Read_0 is an entrypoint for validating "GET" HTTP request
// that match *.pb.gw.go/pattern_ApplicationInstances_Read_0.
func validate_ApplicationInstances_Read_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_ApplicationInstances_Update_0 is an entrypoint for validating "PUT" HTTP request
// that match *.pb.gw.go/pattern_ApplicationInstances_Update_0.
func validate_ApplicationInstances_Update_0(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_ApplicationInstance(ctx, r, "")
}

// validate_ApplicationInstances_Update_1 is an entrypoint for validating "PATCH" HTTP request
// that match *.pb.gw.go/pattern_ApplicationInstances_Update_1.
func validate_ApplicationInstances_Update_1(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_ApplicationInstance(ctx, r, "")
}

// validate_ApplicationInstances_Delete_0 is an entrypoint for validating "DELETE" HTTP request
// that match *.pb.gw.go/pattern_ApplicationInstances_Delete_0.
func validate_ApplicationInstances_Delete_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_ApplicationInstances_List_0 is an entrypoint for validating "GET" HTTP request
// that match *.pb.gw.go/pattern_ApplicationInstances_List_0.
func validate_ApplicationInstances_List_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_AwsRdsInstances_Create_0 is an entrypoint for validating "POST" HTTP request
// that match *.pb.gw.go/pattern_AwsRdsInstances_Create_0.
func validate_AwsRdsInstances_Create_0(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_AwsRdsInstance(ctx, r, "")
}

// validate_AwsRdsInstances_Read_0 is an entrypoint for validating "GET" HTTP request
// that match *.pb.gw.go/pattern_AwsRdsInstances_Read_0.
func validate_AwsRdsInstances_Read_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_AwsRdsInstances_Update_0 is an entrypoint for validating "PUT" HTTP request
// that match *.pb.gw.go/pattern_AwsRdsInstances_Update_0.
func validate_AwsRdsInstances_Update_0(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_AwsRdsInstance(ctx, r, "")
}

// validate_AwsRdsInstances_Update_1 is an entrypoint for validating "PATCH" HTTP request
// that match *.pb.gw.go/pattern_AwsRdsInstances_Update_1.
func validate_AwsRdsInstances_Update_1(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_AwsRdsInstance(ctx, r, "")
}

// validate_AwsRdsInstances_Delete_0 is an entrypoint for validating "DELETE" HTTP request
// that match *.pb.gw.go/pattern_AwsRdsInstances_Delete_0.
func validate_AwsRdsInstances_Delete_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_AwsRdsInstances_List_0 is an entrypoint for validating "GET" HTTP request
// that match *.pb.gw.go/pattern_AwsRdsInstances_List_0.
func validate_AwsRdsInstances_List_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_Containers_Create_0 is an entrypoint for validating "POST" HTTP request
// that match *.pb.gw.go/pattern_Containers_Create_0.
func validate_Containers_Create_0(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_Container(ctx, r, "")
}

// validate_Containers_Read_0 is an entrypoint for validating "GET" HTTP request
// that match *.pb.gw.go/pattern_Containers_Read_0.
func validate_Containers_Read_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_Containers_Update_0 is an entrypoint for validating "PUT" HTTP request
// that match *.pb.gw.go/pattern_Containers_Update_0.
func validate_Containers_Update_0(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_Container(ctx, r, "")
}

// validate_Containers_Update_1 is an entrypoint for validating "PATCH" HTTP request
// that match *.pb.gw.go/pattern_Containers_Update_1.
func validate_Containers_Update_1(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_Container(ctx, r, "")
}

// validate_Containers_Delete_0 is an entrypoint for validating "DELETE" HTTP request
// that match *.pb.gw.go/pattern_Containers_Delete_0.
func validate_Containers_Delete_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_Containers_List_0 is an entrypoint for validating "GET" HTTP request
// that match *.pb.gw.go/pattern_Containers_List_0.
func validate_Containers_List_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_Environments_Create_0 is an entrypoint for validating "POST" HTTP request
// that match *.pb.gw.go/pattern_Environments_Create_0.
func validate_Environments_Create_0(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_Environment(ctx, r, "")
}

// validate_Environments_Read_0 is an entrypoint for validating "GET" HTTP request
// that match *.pb.gw.go/pattern_Environments_Read_0.
func validate_Environments_Read_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_Environments_Update_0 is an entrypoint for validating "PUT" HTTP request
// that match *.pb.gw.go/pattern_Environments_Update_0.
func validate_Environments_Update_0(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_Environment(ctx, r, "")
}

// validate_Environments_Update_1 is an entrypoint for validating "PATCH" HTTP request
// that match *.pb.gw.go/pattern_Environments_Update_1.
func validate_Environments_Update_1(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_Environment(ctx, r, "")
}

// validate_Environments_Delete_0 is an entrypoint for validating "DELETE" HTTP request
// that match *.pb.gw.go/pattern_Environments_Delete_0.
func validate_Environments_Delete_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_Environments_List_0 is an entrypoint for validating "GET" HTTP request
// that match *.pb.gw.go/pattern_Environments_List_0.
func validate_Environments_List_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_Manifests_Create_0 is an entrypoint for validating "POST" HTTP request
// that match *.pb.gw.go/pattern_Manifests_Create_0.
func validate_Manifests_Create_0(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_Manifest(ctx, r, "")
}

// validate_Manifests_Read_0 is an entrypoint for validating "GET" HTTP request
// that match *.pb.gw.go/pattern_Manifests_Read_0.
func validate_Manifests_Read_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_Manifests_Update_0 is an entrypoint for validating "PUT" HTTP request
// that match *.pb.gw.go/pattern_Manifests_Update_0.
func validate_Manifests_Update_0(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_Manifest(ctx, r, "")
}

// validate_Manifests_Update_1 is an entrypoint for validating "PATCH" HTTP request
// that match *.pb.gw.go/pattern_Manifests_Update_1.
func validate_Manifests_Update_1(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_Manifest(ctx, r, "")
}

// validate_Manifests_Delete_0 is an entrypoint for validating "DELETE" HTTP request
// that match *.pb.gw.go/pattern_Manifests_Delete_0.
func validate_Manifests_Delete_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_Manifests_List_0 is an entrypoint for validating "GET" HTTP request
// that match *.pb.gw.go/pattern_Manifests_List_0.
func validate_Manifests_List_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_Secrets_Create_0 is an entrypoint for validating "POST" HTTP request
// that match *.pb.gw.go/pattern_Secrets_Create_0.
func validate_Secrets_Create_0(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_Secret(ctx, r, "")
}

// validate_Secrets_Read_0 is an entrypoint for validating "GET" HTTP request
// that match *.pb.gw.go/pattern_Secrets_Read_0.
func validate_Secrets_Read_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_Secrets_Update_0 is an entrypoint for validating "PUT" HTTP request
// that match *.pb.gw.go/pattern_Secrets_Update_0.
func validate_Secrets_Update_0(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_Secret(ctx, r, "")
}

// validate_Secrets_Update_1 is an entrypoint for validating "PATCH" HTTP request
// that match *.pb.gw.go/pattern_Secrets_Update_1.
func validate_Secrets_Update_1(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_Secret(ctx, r, "")
}

// validate_Secrets_Delete_0 is an entrypoint for validating "DELETE" HTTP request
// that match *.pb.gw.go/pattern_Secrets_Delete_0.
func validate_Secrets_Delete_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_Secrets_List_0 is an entrypoint for validating "GET" HTTP request
// that match *.pb.gw.go/pattern_Secrets_List_0.
func validate_Secrets_List_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_Artifacts_Create_0 is an entrypoint for validating "POST" HTTP request
// that match *.pb.gw.go/pattern_Artifacts_Create_0.
func validate_Artifacts_Create_0(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_Artifact(ctx, r, "")
}

// validate_Artifacts_Read_0 is an entrypoint for validating "GET" HTTP request
// that match *.pb.gw.go/pattern_Artifacts_Read_0.
func validate_Artifacts_Read_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_Artifacts_Update_0 is an entrypoint for validating "PUT" HTTP request
// that match *.pb.gw.go/pattern_Artifacts_Update_0.
func validate_Artifacts_Update_0(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_Artifact(ctx, r, "")
}

// validate_Artifacts_Update_1 is an entrypoint for validating "PATCH" HTTP request
// that match *.pb.gw.go/pattern_Artifacts_Update_1.
func validate_Artifacts_Update_1(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_Artifact(ctx, r, "")
}

// validate_Artifacts_Delete_0 is an entrypoint for validating "DELETE" HTTP request
// that match *.pb.gw.go/pattern_Artifacts_Delete_0.
func validate_Artifacts_Delete_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_Artifacts_List_0 is an entrypoint for validating "GET" HTTP request
// that match *.pb.gw.go/pattern_Artifacts_List_0.
func validate_Artifacts_List_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_AwsServices_Create_0 is an entrypoint for validating "POST" HTTP request
// that match *.pb.gw.go/pattern_AwsServices_Create_0.
func validate_AwsServices_Create_0(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_AwsService(ctx, r, "")
}

// validate_AwsServices_Read_0 is an entrypoint for validating "GET" HTTP request
// that match *.pb.gw.go/pattern_AwsServices_Read_0.
func validate_AwsServices_Read_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_AwsServices_Update_0 is an entrypoint for validating "PUT" HTTP request
// that match *.pb.gw.go/pattern_AwsServices_Update_0.
func validate_AwsServices_Update_0(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_AwsService(ctx, r, "")
}

// validate_AwsServices_Update_1 is an entrypoint for validating "PATCH" HTTP request
// that match *.pb.gw.go/pattern_AwsServices_Update_1.
func validate_AwsServices_Update_1(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_AwsService(ctx, r, "")
}

// validate_AwsServices_Delete_0 is an entrypoint for validating "DELETE" HTTP request
// that match *.pb.gw.go/pattern_AwsServices_Delete_0.
func validate_AwsServices_Delete_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_AwsServices_List_0 is an entrypoint for validating "GET" HTTP request
// that match *.pb.gw.go/pattern_AwsServices_List_0.
func validate_AwsServices_List_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_Deployments_Create_0 is an entrypoint for validating "POST" HTTP request
// that match *.pb.gw.go/pattern_Deployments_Create_0.
func validate_Deployments_Create_0(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_Deployment(ctx, r, "")
}

// validate_Deployments_Read_0 is an entrypoint for validating "GET" HTTP request
// that match *.pb.gw.go/pattern_Deployments_Read_0.
func validate_Deployments_Read_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_Deployments_Update_0 is an entrypoint for validating "PUT" HTTP request
// that match *.pb.gw.go/pattern_Deployments_Update_0.
func validate_Deployments_Update_0(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_Deployment(ctx, r, "")
}

// validate_Deployments_Update_1 is an entrypoint for validating "PATCH" HTTP request
// that match *.pb.gw.go/pattern_Deployments_Update_1.
func validate_Deployments_Update_1(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_Deployment(ctx, r, "")
}

// validate_Deployments_Delete_0 is an entrypoint for validating "DELETE" HTTP request
// that match *.pb.gw.go/pattern_Deployments_Delete_0.
func validate_Deployments_Delete_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_Deployments_List_0 is an entrypoint for validating "GET" HTTP request
// that match *.pb.gw.go/pattern_Deployments_List_0.
func validate_Deployments_List_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_KubeClusters_Create_0 is an entrypoint for validating "POST" HTTP request
// that match *.pb.gw.go/pattern_KubeClusters_Create_0.
func validate_KubeClusters_Create_0(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_KubeCluster(ctx, r, "")
}

// validate_KubeClusters_Read_0 is an entrypoint for validating "GET" HTTP request
// that match *.pb.gw.go/pattern_KubeClusters_Read_0.
func validate_KubeClusters_Read_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_KubeClusters_Update_0 is an entrypoint for validating "PUT" HTTP request
// that match *.pb.gw.go/pattern_KubeClusters_Update_0.
func validate_KubeClusters_Update_0(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_KubeCluster(ctx, r, "")
}

// validate_KubeClusters_Update_1 is an entrypoint for validating "PATCH" HTTP request
// that match *.pb.gw.go/pattern_KubeClusters_Update_1.
func validate_KubeClusters_Update_1(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_KubeCluster(ctx, r, "")
}

// validate_KubeClusters_Delete_0 is an entrypoint for validating "DELETE" HTTP request
// that match *.pb.gw.go/pattern_KubeClusters_Delete_0.
func validate_KubeClusters_Delete_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_KubeClusters_List_0 is an entrypoint for validating "GET" HTTP request
// that match *.pb.gw.go/pattern_KubeClusters_List_0.
func validate_KubeClusters_List_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_CloudProviders_Create_0 is an entrypoint for validating "POST" HTTP request
// that match *.pb.gw.go/pattern_CloudProviders_Create_0.
func validate_CloudProviders_Create_0(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_CloudProvider(ctx, r, "")
}

// validate_CloudProviders_Read_0 is an entrypoint for validating "GET" HTTP request
// that match *.pb.gw.go/pattern_CloudProviders_Read_0.
func validate_CloudProviders_Read_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_CloudProviders_Update_0 is an entrypoint for validating "PUT" HTTP request
// that match *.pb.gw.go/pattern_CloudProviders_Update_0.
func validate_CloudProviders_Update_0(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_CloudProvider(ctx, r, "")
}

// validate_CloudProviders_Update_1 is an entrypoint for validating "PATCH" HTTP request
// that match *.pb.gw.go/pattern_CloudProviders_Update_1.
func validate_CloudProviders_Update_1(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_CloudProvider(ctx, r, "")
}

// validate_CloudProviders_Delete_0 is an entrypoint for validating "DELETE" HTTP request
// that match *.pb.gw.go/pattern_CloudProviders_Delete_0.
func validate_CloudProviders_Delete_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_CloudProviders_List_0 is an entrypoint for validating "GET" HTTP request
// that match *.pb.gw.go/pattern_CloudProviders_List_0.
func validate_CloudProviders_List_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_Regions_Create_0 is an entrypoint for validating "POST" HTTP request
// that match *.pb.gw.go/pattern_Regions_Create_0.
func validate_Regions_Create_0(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_Region(ctx, r, "")
}

// validate_Regions_Read_0 is an entrypoint for validating "GET" HTTP request
// that match *.pb.gw.go/pattern_Regions_Read_0.
func validate_Regions_Read_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_Regions_Update_0 is an entrypoint for validating "PUT" HTTP request
// that match *.pb.gw.go/pattern_Regions_Update_0.
func validate_Regions_Update_0(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_Region(ctx, r, "")
}

// validate_Regions_Update_1 is an entrypoint for validating "PATCH" HTTP request
// that match *.pb.gw.go/pattern_Regions_Update_1.
func validate_Regions_Update_1(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_Region(ctx, r, "")
}

// validate_Regions_Delete_0 is an entrypoint for validating "DELETE" HTTP request
// that match *.pb.gw.go/pattern_Regions_Delete_0.
func validate_Regions_Delete_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_Regions_List_0 is an entrypoint for validating "GET" HTTP request
// that match *.pb.gw.go/pattern_Regions_List_0.
func validate_Regions_List_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_Object_VersionResponse function validates a JSON for a given object.
func validate_Object_VersionResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&VersionResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_VersionResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "version":
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object VersionResponse.
func (_ *VersionResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&VersionResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_VersionResponse(ctx, r, path)
}

func validate_required_Object_VersionResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_Vault function validates a JSON for a given object.
func validate_Object_Vault(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&Vault{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_Vault(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "name":
		case "description":
		case "path":
		case "secrets":
			if v[k] == nil {
				continue
			}
			var vArr []json.RawMessage
			vArrPath := runtime1.JoinPath(path, k)
			if err = json.Unmarshal(v[k], &vArr); err != nil {
				return fmt.Errorf("invalid value for %q: expected array.", vArrPath)
			}
			for i, vv := range vArr {
				vvPath := fmt.Sprintf("%s.[%d]", vArrPath, i)
				if err = validate_Object_Secret(ctx, vv, vvPath); err != nil {
					return err
				}
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object Vault.
func (_ *Vault) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&Vault{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_Vault(ctx, r, path)
}

func validate_required_Object_Vault(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_CreateVaultRequest function validates a JSON for a given object.
func validate_Object_CreateVaultRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateVaultRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_CreateVaultRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "payload":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Vault(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object CreateVaultRequest.
func (_ *CreateVaultRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateVaultRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_CreateVaultRequest(ctx, r, path)
}

func validate_required_Object_CreateVaultRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_CreateVaultResponse function validates a JSON for a given object.
func validate_Object_CreateVaultResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateVaultResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_CreateVaultResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Vault(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object CreateVaultResponse.
func (_ *CreateVaultResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateVaultResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_CreateVaultResponse(ctx, r, path)
}

func validate_required_Object_CreateVaultResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ReadVaultRequest function validates a JSON for a given object.
func validate_Object_ReadVaultRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadVaultRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ReadVaultRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.FieldSelection{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ReadVaultRequest.
func (_ *ReadVaultRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadVaultRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ReadVaultRequest(ctx, r, path)
}

func validate_required_Object_ReadVaultRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ReadVaultResponse function validates a JSON for a given object.
func validate_Object_ReadVaultResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadVaultResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ReadVaultResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Vault(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ReadVaultResponse.
func (_ *ReadVaultResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadVaultResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ReadVaultResponse(ctx, r, path)
}

func validate_required_Object_ReadVaultResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_UpdateVaultRequest function validates a JSON for a given object.
func validate_Object_UpdateVaultRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateVaultRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_UpdateVaultRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "payload":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Vault(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&field_mask.FieldMask{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object UpdateVaultRequest.
func (_ *UpdateVaultRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateVaultRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_UpdateVaultRequest(ctx, r, path)
}

func validate_required_Object_UpdateVaultRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_UpdateVaultResponse function validates a JSON for a given object.
func validate_Object_UpdateVaultResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateVaultResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_UpdateVaultResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Vault(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object UpdateVaultResponse.
func (_ *UpdateVaultResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateVaultResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_UpdateVaultResponse(ctx, r, path)
}

func validate_required_Object_UpdateVaultResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_DeleteVaultRequest function validates a JSON for a given object.
func validate_Object_DeleteVaultRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteVaultRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_DeleteVaultRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object DeleteVaultRequest.
func (_ *DeleteVaultRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteVaultRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_DeleteVaultRequest(ctx, r, path)
}

func validate_required_Object_DeleteVaultRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_DeleteVaultResponse function validates a JSON for a given object.
func validate_Object_DeleteVaultResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteVaultResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_DeleteVaultResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object DeleteVaultResponse.
func (_ *DeleteVaultResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteVaultResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_DeleteVaultResponse(ctx, r, path)
}

func validate_required_Object_DeleteVaultResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ListVaultRequest function validates a JSON for a given object.
func validate_Object_ListVaultRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListVaultRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ListVaultRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "filter":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Filtering{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "order_by":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Sorting{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.FieldSelection{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "paging":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Pagination{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ListVaultRequest.
func (_ *ListVaultRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListVaultRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ListVaultRequest(ctx, r, path)
}

func validate_required_Object_ListVaultRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ListVaultsResponse function validates a JSON for a given object.
func validate_Object_ListVaultsResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListVaultsResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ListVaultsResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "results":
			if v[k] == nil {
				continue
			}
			var vArr []json.RawMessage
			vArrPath := runtime1.JoinPath(path, k)
			if err = json.Unmarshal(v[k], &vArr); err != nil {
				return fmt.Errorf("invalid value for %q: expected array.", vArrPath)
			}
			for i, vv := range vArr {
				vvPath := fmt.Sprintf("%s.[%d]", vArrPath, i)
				if err = validate_Object_Vault(ctx, vv, vvPath); err != nil {
					return err
				}
			}
		case "page":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.PageInfo{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ListVaultsResponse.
func (_ *ListVaultsResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListVaultsResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ListVaultsResponse(ctx, r, path)
}

func validate_required_Object_ListVaultsResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_VersionTag function validates a JSON for a given object.
func validate_Object_VersionTag(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&VersionTag{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_VersionTag(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "name":
		case "description":
		case "version":
		case "artifacts":
			if v[k] == nil {
				continue
			}
			var vArr []json.RawMessage
			vArrPath := runtime1.JoinPath(path, k)
			if err = json.Unmarshal(v[k], &vArr); err != nil {
				return fmt.Errorf("invalid value for %q: expected array.", vArrPath)
			}
			for i, vv := range vArr {
				vvPath := fmt.Sprintf("%s.[%d]", vArrPath, i)
				if err = validate_Object_Artifact(ctx, vv, vvPath); err != nil {
					return err
				}
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object VersionTag.
func (_ *VersionTag) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&VersionTag{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_VersionTag(ctx, r, path)
}

func validate_required_Object_VersionTag(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_CreateVersionTagRequest function validates a JSON for a given object.
func validate_Object_CreateVersionTagRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateVersionTagRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_CreateVersionTagRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "payload":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_VersionTag(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object CreateVersionTagRequest.
func (_ *CreateVersionTagRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateVersionTagRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_CreateVersionTagRequest(ctx, r, path)
}

func validate_required_Object_CreateVersionTagRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_CreateVersionTagResponse function validates a JSON for a given object.
func validate_Object_CreateVersionTagResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateVersionTagResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_CreateVersionTagResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_VersionTag(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object CreateVersionTagResponse.
func (_ *CreateVersionTagResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateVersionTagResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_CreateVersionTagResponse(ctx, r, path)
}

func validate_required_Object_CreateVersionTagResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ReadVersionTagRequest function validates a JSON for a given object.
func validate_Object_ReadVersionTagRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadVersionTagRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ReadVersionTagRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.FieldSelection{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ReadVersionTagRequest.
func (_ *ReadVersionTagRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadVersionTagRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ReadVersionTagRequest(ctx, r, path)
}

func validate_required_Object_ReadVersionTagRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ReadVersionTagResponse function validates a JSON for a given object.
func validate_Object_ReadVersionTagResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadVersionTagResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ReadVersionTagResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_VersionTag(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ReadVersionTagResponse.
func (_ *ReadVersionTagResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadVersionTagResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ReadVersionTagResponse(ctx, r, path)
}

func validate_required_Object_ReadVersionTagResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_UpdateVersionTagRequest function validates a JSON for a given object.
func validate_Object_UpdateVersionTagRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateVersionTagRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_UpdateVersionTagRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "payload":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_VersionTag(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&field_mask.FieldMask{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object UpdateVersionTagRequest.
func (_ *UpdateVersionTagRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateVersionTagRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_UpdateVersionTagRequest(ctx, r, path)
}

func validate_required_Object_UpdateVersionTagRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_UpdateVersionTagResponse function validates a JSON for a given object.
func validate_Object_UpdateVersionTagResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateVersionTagResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_UpdateVersionTagResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_VersionTag(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object UpdateVersionTagResponse.
func (_ *UpdateVersionTagResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateVersionTagResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_UpdateVersionTagResponse(ctx, r, path)
}

func validate_required_Object_UpdateVersionTagResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_DeleteVersionTagRequest function validates a JSON for a given object.
func validate_Object_DeleteVersionTagRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteVersionTagRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_DeleteVersionTagRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object DeleteVersionTagRequest.
func (_ *DeleteVersionTagRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteVersionTagRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_DeleteVersionTagRequest(ctx, r, path)
}

func validate_required_Object_DeleteVersionTagRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_DeleteVersionTagResponse function validates a JSON for a given object.
func validate_Object_DeleteVersionTagResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteVersionTagResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_DeleteVersionTagResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object DeleteVersionTagResponse.
func (_ *DeleteVersionTagResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteVersionTagResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_DeleteVersionTagResponse(ctx, r, path)
}

func validate_required_Object_DeleteVersionTagResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ListVersionTagRequest function validates a JSON for a given object.
func validate_Object_ListVersionTagRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListVersionTagRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ListVersionTagRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "filter":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Filtering{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "order_by":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Sorting{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.FieldSelection{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "paging":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Pagination{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ListVersionTagRequest.
func (_ *ListVersionTagRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListVersionTagRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ListVersionTagRequest(ctx, r, path)
}

func validate_required_Object_ListVersionTagRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ListVersionTagsResponse function validates a JSON for a given object.
func validate_Object_ListVersionTagsResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListVersionTagsResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ListVersionTagsResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "results":
			if v[k] == nil {
				continue
			}
			var vArr []json.RawMessage
			vArrPath := runtime1.JoinPath(path, k)
			if err = json.Unmarshal(v[k], &vArr); err != nil {
				return fmt.Errorf("invalid value for %q: expected array.", vArrPath)
			}
			for i, vv := range vArr {
				vvPath := fmt.Sprintf("%s.[%d]", vArrPath, i)
				if err = validate_Object_VersionTag(ctx, vv, vvPath); err != nil {
					return err
				}
			}
		case "page":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.PageInfo{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ListVersionTagsResponse.
func (_ *ListVersionTagsResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListVersionTagsResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ListVersionTagsResponse(ctx, r, path)
}

func validate_required_Object_ListVersionTagsResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ApplicationInstance function validates a JSON for a given object.
func validate_Object_ApplicationInstance(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ApplicationInstance{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ApplicationInstance(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "name":
		case "description":
		case "app_name":
		case "repo":
		case "version_tag":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_VersionTag(ctx, vv, vvPath); err != nil {
				return err
			}
		case "version_tag_id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "manifest":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Manifest(ctx, vv, vvPath); err != nil {
				return err
			}
		case "manifest_id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "containers":
			if v[k] == nil {
				continue
			}
			var vArr []json.RawMessage
			vArrPath := runtime1.JoinPath(path, k)
			if err = json.Unmarshal(v[k], &vArr); err != nil {
				return fmt.Errorf("invalid value for %q: expected array.", vArrPath)
			}
			for i, vv := range vArr {
				vvPath := fmt.Sprintf("%s.[%d]", vArrPath, i)
				if err = validate_Object_Container(ctx, vv, vvPath); err != nil {
					return err
				}
			}
		case "environment_id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "deployment":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Deployment(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ApplicationInstance.
func (_ *ApplicationInstance) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ApplicationInstance{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ApplicationInstance(ctx, r, path)
}

func validate_required_Object_ApplicationInstance(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_CreateApplicationInstanceRequest function validates a JSON for a given object.
func validate_Object_CreateApplicationInstanceRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateApplicationInstanceRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_CreateApplicationInstanceRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "payload":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_ApplicationInstance(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object CreateApplicationInstanceRequest.
func (_ *CreateApplicationInstanceRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateApplicationInstanceRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_CreateApplicationInstanceRequest(ctx, r, path)
}

func validate_required_Object_CreateApplicationInstanceRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_CreateApplicationInstanceResponse function validates a JSON for a given object.
func validate_Object_CreateApplicationInstanceResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateApplicationInstanceResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_CreateApplicationInstanceResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_ApplicationInstance(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object CreateApplicationInstanceResponse.
func (_ *CreateApplicationInstanceResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateApplicationInstanceResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_CreateApplicationInstanceResponse(ctx, r, path)
}

func validate_required_Object_CreateApplicationInstanceResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ReadApplicationInstanceRequest function validates a JSON for a given object.
func validate_Object_ReadApplicationInstanceRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadApplicationInstanceRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ReadApplicationInstanceRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.FieldSelection{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ReadApplicationInstanceRequest.
func (_ *ReadApplicationInstanceRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadApplicationInstanceRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ReadApplicationInstanceRequest(ctx, r, path)
}

func validate_required_Object_ReadApplicationInstanceRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ReadApplicationInstanceResponse function validates a JSON for a given object.
func validate_Object_ReadApplicationInstanceResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadApplicationInstanceResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ReadApplicationInstanceResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_ApplicationInstance(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ReadApplicationInstanceResponse.
func (_ *ReadApplicationInstanceResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadApplicationInstanceResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ReadApplicationInstanceResponse(ctx, r, path)
}

func validate_required_Object_ReadApplicationInstanceResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_UpdateApplicationInstanceRequest function validates a JSON for a given object.
func validate_Object_UpdateApplicationInstanceRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateApplicationInstanceRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_UpdateApplicationInstanceRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "payload":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_ApplicationInstance(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&field_mask.FieldMask{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object UpdateApplicationInstanceRequest.
func (_ *UpdateApplicationInstanceRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateApplicationInstanceRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_UpdateApplicationInstanceRequest(ctx, r, path)
}

func validate_required_Object_UpdateApplicationInstanceRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_UpdateApplicationInstanceResponse function validates a JSON for a given object.
func validate_Object_UpdateApplicationInstanceResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateApplicationInstanceResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_UpdateApplicationInstanceResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_ApplicationInstance(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object UpdateApplicationInstanceResponse.
func (_ *UpdateApplicationInstanceResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateApplicationInstanceResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_UpdateApplicationInstanceResponse(ctx, r, path)
}

func validate_required_Object_UpdateApplicationInstanceResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_DeleteApplicationInstanceRequest function validates a JSON for a given object.
func validate_Object_DeleteApplicationInstanceRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteApplicationInstanceRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_DeleteApplicationInstanceRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object DeleteApplicationInstanceRequest.
func (_ *DeleteApplicationInstanceRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteApplicationInstanceRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_DeleteApplicationInstanceRequest(ctx, r, path)
}

func validate_required_Object_DeleteApplicationInstanceRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_DeleteApplicationInstanceResponse function validates a JSON for a given object.
func validate_Object_DeleteApplicationInstanceResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteApplicationInstanceResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_DeleteApplicationInstanceResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object DeleteApplicationInstanceResponse.
func (_ *DeleteApplicationInstanceResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteApplicationInstanceResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_DeleteApplicationInstanceResponse(ctx, r, path)
}

func validate_required_Object_DeleteApplicationInstanceResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ListApplicationInstanceRequest function validates a JSON for a given object.
func validate_Object_ListApplicationInstanceRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListApplicationInstanceRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ListApplicationInstanceRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "filter":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Filtering{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "order_by":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Sorting{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.FieldSelection{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "paging":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Pagination{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ListApplicationInstanceRequest.
func (_ *ListApplicationInstanceRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListApplicationInstanceRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ListApplicationInstanceRequest(ctx, r, path)
}

func validate_required_Object_ListApplicationInstanceRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ListApplicationInstancesResponse function validates a JSON for a given object.
func validate_Object_ListApplicationInstancesResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListApplicationInstancesResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ListApplicationInstancesResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "results":
			if v[k] == nil {
				continue
			}
			var vArr []json.RawMessage
			vArrPath := runtime1.JoinPath(path, k)
			if err = json.Unmarshal(v[k], &vArr); err != nil {
				return fmt.Errorf("invalid value for %q: expected array.", vArrPath)
			}
			for i, vv := range vArr {
				vvPath := fmt.Sprintf("%s.[%d]", vArrPath, i)
				if err = validate_Object_ApplicationInstance(ctx, vv, vvPath); err != nil {
					return err
				}
			}
		case "page":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.PageInfo{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ListApplicationInstancesResponse.
func (_ *ListApplicationInstancesResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListApplicationInstancesResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ListApplicationInstancesResponse(ctx, r, path)
}

func validate_required_Object_ListApplicationInstancesResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_AwsRdsInstance function validates a JSON for a given object.
func validate_Object_AwsRdsInstance(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&AwsRdsInstance{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_AwsRdsInstance(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "name":
		case "description":
		case "database_host":
		case "database_name":
		case "database_user":
		case "database_password":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Secret(ctx, vv, vvPath); err != nil {
				return err
			}
		case "aws_service_id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object AwsRdsInstance.
func (_ *AwsRdsInstance) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&AwsRdsInstance{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_AwsRdsInstance(ctx, r, path)
}

func validate_required_Object_AwsRdsInstance(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_CreateAwsRdsInstanceRequest function validates a JSON for a given object.
func validate_Object_CreateAwsRdsInstanceRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateAwsRdsInstanceRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_CreateAwsRdsInstanceRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "payload":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_AwsRdsInstance(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object CreateAwsRdsInstanceRequest.
func (_ *CreateAwsRdsInstanceRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateAwsRdsInstanceRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_CreateAwsRdsInstanceRequest(ctx, r, path)
}

func validate_required_Object_CreateAwsRdsInstanceRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_CreateAwsRdsInstanceResponse function validates a JSON for a given object.
func validate_Object_CreateAwsRdsInstanceResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateAwsRdsInstanceResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_CreateAwsRdsInstanceResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_AwsRdsInstance(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object CreateAwsRdsInstanceResponse.
func (_ *CreateAwsRdsInstanceResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateAwsRdsInstanceResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_CreateAwsRdsInstanceResponse(ctx, r, path)
}

func validate_required_Object_CreateAwsRdsInstanceResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ReadAwsRdsInstanceRequest function validates a JSON for a given object.
func validate_Object_ReadAwsRdsInstanceRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadAwsRdsInstanceRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ReadAwsRdsInstanceRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.FieldSelection{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ReadAwsRdsInstanceRequest.
func (_ *ReadAwsRdsInstanceRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadAwsRdsInstanceRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ReadAwsRdsInstanceRequest(ctx, r, path)
}

func validate_required_Object_ReadAwsRdsInstanceRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ReadAwsRdsInstanceResponse function validates a JSON for a given object.
func validate_Object_ReadAwsRdsInstanceResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadAwsRdsInstanceResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ReadAwsRdsInstanceResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_AwsRdsInstance(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ReadAwsRdsInstanceResponse.
func (_ *ReadAwsRdsInstanceResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadAwsRdsInstanceResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ReadAwsRdsInstanceResponse(ctx, r, path)
}

func validate_required_Object_ReadAwsRdsInstanceResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_UpdateAwsRdsInstanceRequest function validates a JSON for a given object.
func validate_Object_UpdateAwsRdsInstanceRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateAwsRdsInstanceRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_UpdateAwsRdsInstanceRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "payload":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_AwsRdsInstance(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&field_mask.FieldMask{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object UpdateAwsRdsInstanceRequest.
func (_ *UpdateAwsRdsInstanceRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateAwsRdsInstanceRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_UpdateAwsRdsInstanceRequest(ctx, r, path)
}

func validate_required_Object_UpdateAwsRdsInstanceRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_UpdateAwsRdsInstanceResponse function validates a JSON for a given object.
func validate_Object_UpdateAwsRdsInstanceResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateAwsRdsInstanceResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_UpdateAwsRdsInstanceResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_AwsRdsInstance(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object UpdateAwsRdsInstanceResponse.
func (_ *UpdateAwsRdsInstanceResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateAwsRdsInstanceResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_UpdateAwsRdsInstanceResponse(ctx, r, path)
}

func validate_required_Object_UpdateAwsRdsInstanceResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_DeleteAwsRdsInstanceRequest function validates a JSON for a given object.
func validate_Object_DeleteAwsRdsInstanceRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteAwsRdsInstanceRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_DeleteAwsRdsInstanceRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object DeleteAwsRdsInstanceRequest.
func (_ *DeleteAwsRdsInstanceRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteAwsRdsInstanceRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_DeleteAwsRdsInstanceRequest(ctx, r, path)
}

func validate_required_Object_DeleteAwsRdsInstanceRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_DeleteAwsRdsInstanceResponse function validates a JSON for a given object.
func validate_Object_DeleteAwsRdsInstanceResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteAwsRdsInstanceResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_DeleteAwsRdsInstanceResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object DeleteAwsRdsInstanceResponse.
func (_ *DeleteAwsRdsInstanceResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteAwsRdsInstanceResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_DeleteAwsRdsInstanceResponse(ctx, r, path)
}

func validate_required_Object_DeleteAwsRdsInstanceResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ListAwsRdsInstanceRequest function validates a JSON for a given object.
func validate_Object_ListAwsRdsInstanceRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListAwsRdsInstanceRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ListAwsRdsInstanceRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "filter":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Filtering{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "order_by":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Sorting{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.FieldSelection{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "paging":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Pagination{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ListAwsRdsInstanceRequest.
func (_ *ListAwsRdsInstanceRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListAwsRdsInstanceRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ListAwsRdsInstanceRequest(ctx, r, path)
}

func validate_required_Object_ListAwsRdsInstanceRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ListAwsRdsInstancesResponse function validates a JSON for a given object.
func validate_Object_ListAwsRdsInstancesResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListAwsRdsInstancesResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ListAwsRdsInstancesResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "results":
			if v[k] == nil {
				continue
			}
			var vArr []json.RawMessage
			vArrPath := runtime1.JoinPath(path, k)
			if err = json.Unmarshal(v[k], &vArr); err != nil {
				return fmt.Errorf("invalid value for %q: expected array.", vArrPath)
			}
			for i, vv := range vArr {
				vvPath := fmt.Sprintf("%s.[%d]", vArrPath, i)
				if err = validate_Object_AwsRdsInstance(ctx, vv, vvPath); err != nil {
					return err
				}
			}
		case "page":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.PageInfo{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ListAwsRdsInstancesResponse.
func (_ *ListAwsRdsInstancesResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListAwsRdsInstancesResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ListAwsRdsInstancesResponse(ctx, r, path)
}

func validate_required_Object_ListAwsRdsInstancesResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_Container function validates a JSON for a given object.
func validate_Object_Container(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&Container{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_Container(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "name":
		case "description":
		case "container_name":
		case "image_repo":
		case "image_tag":
		case "image_pull_policy":
		case "digest":
		case "application_instance_id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object Container.
func (_ *Container) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&Container{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_Container(ctx, r, path)
}

func validate_required_Object_Container(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_CreateContainerRequest function validates a JSON for a given object.
func validate_Object_CreateContainerRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateContainerRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_CreateContainerRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "payload":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Container(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object CreateContainerRequest.
func (_ *CreateContainerRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateContainerRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_CreateContainerRequest(ctx, r, path)
}

func validate_required_Object_CreateContainerRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_CreateContainerResponse function validates a JSON for a given object.
func validate_Object_CreateContainerResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateContainerResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_CreateContainerResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Container(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object CreateContainerResponse.
func (_ *CreateContainerResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateContainerResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_CreateContainerResponse(ctx, r, path)
}

func validate_required_Object_CreateContainerResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ReadContainerRequest function validates a JSON for a given object.
func validate_Object_ReadContainerRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadContainerRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ReadContainerRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.FieldSelection{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ReadContainerRequest.
func (_ *ReadContainerRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadContainerRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ReadContainerRequest(ctx, r, path)
}

func validate_required_Object_ReadContainerRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ReadContainerResponse function validates a JSON for a given object.
func validate_Object_ReadContainerResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadContainerResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ReadContainerResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Container(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ReadContainerResponse.
func (_ *ReadContainerResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadContainerResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ReadContainerResponse(ctx, r, path)
}

func validate_required_Object_ReadContainerResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_UpdateContainerRequest function validates a JSON for a given object.
func validate_Object_UpdateContainerRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateContainerRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_UpdateContainerRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "payload":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Container(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&field_mask.FieldMask{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object UpdateContainerRequest.
func (_ *UpdateContainerRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateContainerRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_UpdateContainerRequest(ctx, r, path)
}

func validate_required_Object_UpdateContainerRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_UpdateContainerResponse function validates a JSON for a given object.
func validate_Object_UpdateContainerResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateContainerResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_UpdateContainerResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Container(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object UpdateContainerResponse.
func (_ *UpdateContainerResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateContainerResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_UpdateContainerResponse(ctx, r, path)
}

func validate_required_Object_UpdateContainerResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_DeleteContainerRequest function validates a JSON for a given object.
func validate_Object_DeleteContainerRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteContainerRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_DeleteContainerRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object DeleteContainerRequest.
func (_ *DeleteContainerRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteContainerRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_DeleteContainerRequest(ctx, r, path)
}

func validate_required_Object_DeleteContainerRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_DeleteContainerResponse function validates a JSON for a given object.
func validate_Object_DeleteContainerResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteContainerResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_DeleteContainerResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object DeleteContainerResponse.
func (_ *DeleteContainerResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteContainerResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_DeleteContainerResponse(ctx, r, path)
}

func validate_required_Object_DeleteContainerResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ListContainerRequest function validates a JSON for a given object.
func validate_Object_ListContainerRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListContainerRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ListContainerRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "filter":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Filtering{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "order_by":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Sorting{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.FieldSelection{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "paging":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Pagination{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ListContainerRequest.
func (_ *ListContainerRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListContainerRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ListContainerRequest(ctx, r, path)
}

func validate_required_Object_ListContainerRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ListContainersResponse function validates a JSON for a given object.
func validate_Object_ListContainersResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListContainersResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ListContainersResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "results":
			if v[k] == nil {
				continue
			}
			var vArr []json.RawMessage
			vArrPath := runtime1.JoinPath(path, k)
			if err = json.Unmarshal(v[k], &vArr); err != nil {
				return fmt.Errorf("invalid value for %q: expected array.", vArrPath)
			}
			for i, vv := range vArr {
				vvPath := fmt.Sprintf("%s.[%d]", vArrPath, i)
				if err = validate_Object_Container(ctx, vv, vvPath); err != nil {
					return err
				}
			}
		case "page":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.PageInfo{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ListContainersResponse.
func (_ *ListContainersResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListContainersResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ListContainersResponse(ctx, r, path)
}

func validate_required_Object_ListContainersResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_Environment function validates a JSON for a given object.
func validate_Object_Environment(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&Environment{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_Environment(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "name":
		case "description":
		case "code":
		case "application_instances":
			if v[k] == nil {
				continue
			}
			var vArr []json.RawMessage
			vArrPath := runtime1.JoinPath(path, k)
			if err = json.Unmarshal(v[k], &vArr); err != nil {
				return fmt.Errorf("invalid value for %q: expected array.", vArrPath)
			}
			for i, vv := range vArr {
				vvPath := fmt.Sprintf("%s.[%d]", vArrPath, i)
				if err = validate_Object_ApplicationInstance(ctx, vv, vvPath); err != nil {
					return err
				}
			}
		case "region_id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object Environment.
func (_ *Environment) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&Environment{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_Environment(ctx, r, path)
}

func validate_required_Object_Environment(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_CreateEnvironmentRequest function validates a JSON for a given object.
func validate_Object_CreateEnvironmentRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateEnvironmentRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_CreateEnvironmentRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "payload":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Environment(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object CreateEnvironmentRequest.
func (_ *CreateEnvironmentRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateEnvironmentRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_CreateEnvironmentRequest(ctx, r, path)
}

func validate_required_Object_CreateEnvironmentRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_CreateEnvironmentResponse function validates a JSON for a given object.
func validate_Object_CreateEnvironmentResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateEnvironmentResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_CreateEnvironmentResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Environment(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object CreateEnvironmentResponse.
func (_ *CreateEnvironmentResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateEnvironmentResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_CreateEnvironmentResponse(ctx, r, path)
}

func validate_required_Object_CreateEnvironmentResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ReadEnvironmentRequest function validates a JSON for a given object.
func validate_Object_ReadEnvironmentRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadEnvironmentRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ReadEnvironmentRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.FieldSelection{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ReadEnvironmentRequest.
func (_ *ReadEnvironmentRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadEnvironmentRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ReadEnvironmentRequest(ctx, r, path)
}

func validate_required_Object_ReadEnvironmentRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ReadEnvironmentResponse function validates a JSON for a given object.
func validate_Object_ReadEnvironmentResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadEnvironmentResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ReadEnvironmentResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Environment(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ReadEnvironmentResponse.
func (_ *ReadEnvironmentResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadEnvironmentResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ReadEnvironmentResponse(ctx, r, path)
}

func validate_required_Object_ReadEnvironmentResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_UpdateEnvironmentRequest function validates a JSON for a given object.
func validate_Object_UpdateEnvironmentRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateEnvironmentRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_UpdateEnvironmentRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "payload":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Environment(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&field_mask.FieldMask{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object UpdateEnvironmentRequest.
func (_ *UpdateEnvironmentRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateEnvironmentRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_UpdateEnvironmentRequest(ctx, r, path)
}

func validate_required_Object_UpdateEnvironmentRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_UpdateEnvironmentResponse function validates a JSON for a given object.
func validate_Object_UpdateEnvironmentResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateEnvironmentResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_UpdateEnvironmentResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Environment(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object UpdateEnvironmentResponse.
func (_ *UpdateEnvironmentResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateEnvironmentResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_UpdateEnvironmentResponse(ctx, r, path)
}

func validate_required_Object_UpdateEnvironmentResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_DeleteEnvironmentRequest function validates a JSON for a given object.
func validate_Object_DeleteEnvironmentRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteEnvironmentRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_DeleteEnvironmentRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object DeleteEnvironmentRequest.
func (_ *DeleteEnvironmentRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteEnvironmentRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_DeleteEnvironmentRequest(ctx, r, path)
}

func validate_required_Object_DeleteEnvironmentRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_DeleteEnvironmentResponse function validates a JSON for a given object.
func validate_Object_DeleteEnvironmentResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteEnvironmentResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_DeleteEnvironmentResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object DeleteEnvironmentResponse.
func (_ *DeleteEnvironmentResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteEnvironmentResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_DeleteEnvironmentResponse(ctx, r, path)
}

func validate_required_Object_DeleteEnvironmentResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ListEnvironmentRequest function validates a JSON for a given object.
func validate_Object_ListEnvironmentRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListEnvironmentRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ListEnvironmentRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "filter":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Filtering{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "order_by":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Sorting{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.FieldSelection{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "paging":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Pagination{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ListEnvironmentRequest.
func (_ *ListEnvironmentRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListEnvironmentRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ListEnvironmentRequest(ctx, r, path)
}

func validate_required_Object_ListEnvironmentRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ListEnvironmentsResponse function validates a JSON for a given object.
func validate_Object_ListEnvironmentsResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListEnvironmentsResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ListEnvironmentsResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "results":
			if v[k] == nil {
				continue
			}
			var vArr []json.RawMessage
			vArrPath := runtime1.JoinPath(path, k)
			if err = json.Unmarshal(v[k], &vArr); err != nil {
				return fmt.Errorf("invalid value for %q: expected array.", vArrPath)
			}
			for i, vv := range vArr {
				vvPath := fmt.Sprintf("%s.[%d]", vArrPath, i)
				if err = validate_Object_Environment(ctx, vv, vvPath); err != nil {
					return err
				}
			}
		case "page":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.PageInfo{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ListEnvironmentsResponse.
func (_ *ListEnvironmentsResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListEnvironmentsResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ListEnvironmentsResponse(ctx, r, path)
}

func validate_required_Object_ListEnvironmentsResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_Manifest function validates a JSON for a given object.
func validate_Object_Manifest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&Manifest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_Manifest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "name":
		case "description":
		case "repo":
		case "commit":
		case "values":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&types.JSONValue{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "services":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&types.JSONValue{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "ingress":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&types.JSONValue{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "resources":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&types.JSONValue{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "node_selector":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&types.JSONValue{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "tolerations":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&types.JSONValue{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "affinity":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&types.JSONValue{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "artifact":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Artifact(ctx, vv, vvPath); err != nil {
				return err
			}
		case "artifact_id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "vault":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Vault(ctx, vv, vvPath); err != nil {
				return err
			}
		case "vault_id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "aws_service":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_AwsService(ctx, vv, vvPath); err != nil {
				return err
			}
		case "aws_service_id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object Manifest.
func (_ *Manifest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&Manifest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_Manifest(ctx, r, path)
}

func validate_required_Object_Manifest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_CreateManifestRequest function validates a JSON for a given object.
func validate_Object_CreateManifestRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateManifestRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_CreateManifestRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "payload":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Manifest(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object CreateManifestRequest.
func (_ *CreateManifestRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateManifestRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_CreateManifestRequest(ctx, r, path)
}

func validate_required_Object_CreateManifestRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_CreateManifestResponse function validates a JSON for a given object.
func validate_Object_CreateManifestResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateManifestResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_CreateManifestResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Manifest(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object CreateManifestResponse.
func (_ *CreateManifestResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateManifestResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_CreateManifestResponse(ctx, r, path)
}

func validate_required_Object_CreateManifestResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ReadManifestRequest function validates a JSON for a given object.
func validate_Object_ReadManifestRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadManifestRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ReadManifestRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.FieldSelection{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ReadManifestRequest.
func (_ *ReadManifestRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadManifestRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ReadManifestRequest(ctx, r, path)
}

func validate_required_Object_ReadManifestRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ReadManifestResponse function validates a JSON for a given object.
func validate_Object_ReadManifestResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadManifestResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ReadManifestResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Manifest(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ReadManifestResponse.
func (_ *ReadManifestResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadManifestResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ReadManifestResponse(ctx, r, path)
}

func validate_required_Object_ReadManifestResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_UpdateManifestRequest function validates a JSON for a given object.
func validate_Object_UpdateManifestRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateManifestRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_UpdateManifestRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "payload":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Manifest(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&field_mask.FieldMask{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object UpdateManifestRequest.
func (_ *UpdateManifestRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateManifestRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_UpdateManifestRequest(ctx, r, path)
}

func validate_required_Object_UpdateManifestRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_UpdateManifestResponse function validates a JSON for a given object.
func validate_Object_UpdateManifestResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateManifestResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_UpdateManifestResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Manifest(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object UpdateManifestResponse.
func (_ *UpdateManifestResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateManifestResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_UpdateManifestResponse(ctx, r, path)
}

func validate_required_Object_UpdateManifestResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_DeleteManifestRequest function validates a JSON for a given object.
func validate_Object_DeleteManifestRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteManifestRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_DeleteManifestRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object DeleteManifestRequest.
func (_ *DeleteManifestRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteManifestRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_DeleteManifestRequest(ctx, r, path)
}

func validate_required_Object_DeleteManifestRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_DeleteManifestResponse function validates a JSON for a given object.
func validate_Object_DeleteManifestResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteManifestResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_DeleteManifestResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object DeleteManifestResponse.
func (_ *DeleteManifestResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteManifestResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_DeleteManifestResponse(ctx, r, path)
}

func validate_required_Object_DeleteManifestResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ListManifestRequest function validates a JSON for a given object.
func validate_Object_ListManifestRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListManifestRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ListManifestRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "filter":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Filtering{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "order_by":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Sorting{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.FieldSelection{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "paging":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Pagination{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ListManifestRequest.
func (_ *ListManifestRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListManifestRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ListManifestRequest(ctx, r, path)
}

func validate_required_Object_ListManifestRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ListManifestsResponse function validates a JSON for a given object.
func validate_Object_ListManifestsResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListManifestsResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ListManifestsResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "results":
			if v[k] == nil {
				continue
			}
			var vArr []json.RawMessage
			vArrPath := runtime1.JoinPath(path, k)
			if err = json.Unmarshal(v[k], &vArr); err != nil {
				return fmt.Errorf("invalid value for %q: expected array.", vArrPath)
			}
			for i, vv := range vArr {
				vvPath := fmt.Sprintf("%s.[%d]", vArrPath, i)
				if err = validate_Object_Manifest(ctx, vv, vvPath); err != nil {
					return err
				}
			}
		case "page":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.PageInfo{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ListManifestsResponse.
func (_ *ListManifestsResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListManifestsResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ListManifestsResponse(ctx, r, path)
}

func validate_required_Object_ListManifestsResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_Secret function validates a JSON for a given object.
func validate_Object_Secret(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&Secret{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_Secret(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "name":
		case "description":
		case "type":
		case "key":
		case "vault_id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "aws_rds_instance_id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object Secret.
func (_ *Secret) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&Secret{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_Secret(ctx, r, path)
}

func validate_required_Object_Secret(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_CreateSecretRequest function validates a JSON for a given object.
func validate_Object_CreateSecretRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateSecretRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_CreateSecretRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "payload":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Secret(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object CreateSecretRequest.
func (_ *CreateSecretRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateSecretRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_CreateSecretRequest(ctx, r, path)
}

func validate_required_Object_CreateSecretRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_CreateSecretResponse function validates a JSON for a given object.
func validate_Object_CreateSecretResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateSecretResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_CreateSecretResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Secret(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object CreateSecretResponse.
func (_ *CreateSecretResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateSecretResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_CreateSecretResponse(ctx, r, path)
}

func validate_required_Object_CreateSecretResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ReadSecretRequest function validates a JSON for a given object.
func validate_Object_ReadSecretRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadSecretRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ReadSecretRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.FieldSelection{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ReadSecretRequest.
func (_ *ReadSecretRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadSecretRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ReadSecretRequest(ctx, r, path)
}

func validate_required_Object_ReadSecretRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ReadSecretResponse function validates a JSON for a given object.
func validate_Object_ReadSecretResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadSecretResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ReadSecretResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Secret(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ReadSecretResponse.
func (_ *ReadSecretResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadSecretResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ReadSecretResponse(ctx, r, path)
}

func validate_required_Object_ReadSecretResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_UpdateSecretRequest function validates a JSON for a given object.
func validate_Object_UpdateSecretRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateSecretRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_UpdateSecretRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "payload":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Secret(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&field_mask.FieldMask{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object UpdateSecretRequest.
func (_ *UpdateSecretRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateSecretRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_UpdateSecretRequest(ctx, r, path)
}

func validate_required_Object_UpdateSecretRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_UpdateSecretResponse function validates a JSON for a given object.
func validate_Object_UpdateSecretResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateSecretResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_UpdateSecretResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Secret(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object UpdateSecretResponse.
func (_ *UpdateSecretResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateSecretResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_UpdateSecretResponse(ctx, r, path)
}

func validate_required_Object_UpdateSecretResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_DeleteSecretRequest function validates a JSON for a given object.
func validate_Object_DeleteSecretRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteSecretRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_DeleteSecretRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object DeleteSecretRequest.
func (_ *DeleteSecretRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteSecretRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_DeleteSecretRequest(ctx, r, path)
}

func validate_required_Object_DeleteSecretRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_DeleteSecretResponse function validates a JSON for a given object.
func validate_Object_DeleteSecretResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteSecretResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_DeleteSecretResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object DeleteSecretResponse.
func (_ *DeleteSecretResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteSecretResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_DeleteSecretResponse(ctx, r, path)
}

func validate_required_Object_DeleteSecretResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ListSecretRequest function validates a JSON for a given object.
func validate_Object_ListSecretRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListSecretRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ListSecretRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "filter":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Filtering{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "order_by":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Sorting{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.FieldSelection{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "paging":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Pagination{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ListSecretRequest.
func (_ *ListSecretRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListSecretRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ListSecretRequest(ctx, r, path)
}

func validate_required_Object_ListSecretRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ListSecretsResponse function validates a JSON for a given object.
func validate_Object_ListSecretsResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListSecretsResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ListSecretsResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "results":
			if v[k] == nil {
				continue
			}
			var vArr []json.RawMessage
			vArrPath := runtime1.JoinPath(path, k)
			if err = json.Unmarshal(v[k], &vArr); err != nil {
				return fmt.Errorf("invalid value for %q: expected array.", vArrPath)
			}
			for i, vv := range vArr {
				vvPath := fmt.Sprintf("%s.[%d]", vArrPath, i)
				if err = validate_Object_Secret(ctx, vv, vvPath); err != nil {
					return err
				}
			}
		case "page":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.PageInfo{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ListSecretsResponse.
func (_ *ListSecretsResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListSecretsResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ListSecretsResponse(ctx, r, path)
}

func validate_required_Object_ListSecretsResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_Artifact function validates a JSON for a given object.
func validate_Object_Artifact(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&Artifact{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_Artifact(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "name":
		case "description":
		case "repo":
		case "commit":
		case "version_tag_id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object Artifact.
func (_ *Artifact) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&Artifact{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_Artifact(ctx, r, path)
}

func validate_required_Object_Artifact(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_CreateArtifactRequest function validates a JSON for a given object.
func validate_Object_CreateArtifactRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateArtifactRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_CreateArtifactRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "payload":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Artifact(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object CreateArtifactRequest.
func (_ *CreateArtifactRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateArtifactRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_CreateArtifactRequest(ctx, r, path)
}

func validate_required_Object_CreateArtifactRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_CreateArtifactResponse function validates a JSON for a given object.
func validate_Object_CreateArtifactResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateArtifactResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_CreateArtifactResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Artifact(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object CreateArtifactResponse.
func (_ *CreateArtifactResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateArtifactResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_CreateArtifactResponse(ctx, r, path)
}

func validate_required_Object_CreateArtifactResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ReadArtifactRequest function validates a JSON for a given object.
func validate_Object_ReadArtifactRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadArtifactRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ReadArtifactRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.FieldSelection{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ReadArtifactRequest.
func (_ *ReadArtifactRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadArtifactRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ReadArtifactRequest(ctx, r, path)
}

func validate_required_Object_ReadArtifactRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ReadArtifactResponse function validates a JSON for a given object.
func validate_Object_ReadArtifactResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadArtifactResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ReadArtifactResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Artifact(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ReadArtifactResponse.
func (_ *ReadArtifactResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadArtifactResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ReadArtifactResponse(ctx, r, path)
}

func validate_required_Object_ReadArtifactResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_UpdateArtifactRequest function validates a JSON for a given object.
func validate_Object_UpdateArtifactRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateArtifactRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_UpdateArtifactRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "payload":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Artifact(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&field_mask.FieldMask{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object UpdateArtifactRequest.
func (_ *UpdateArtifactRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateArtifactRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_UpdateArtifactRequest(ctx, r, path)
}

func validate_required_Object_UpdateArtifactRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_UpdateArtifactResponse function validates a JSON for a given object.
func validate_Object_UpdateArtifactResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateArtifactResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_UpdateArtifactResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Artifact(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object UpdateArtifactResponse.
func (_ *UpdateArtifactResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateArtifactResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_UpdateArtifactResponse(ctx, r, path)
}

func validate_required_Object_UpdateArtifactResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_DeleteArtifactRequest function validates a JSON for a given object.
func validate_Object_DeleteArtifactRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteArtifactRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_DeleteArtifactRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object DeleteArtifactRequest.
func (_ *DeleteArtifactRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteArtifactRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_DeleteArtifactRequest(ctx, r, path)
}

func validate_required_Object_DeleteArtifactRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_DeleteArtifactResponse function validates a JSON for a given object.
func validate_Object_DeleteArtifactResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteArtifactResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_DeleteArtifactResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object DeleteArtifactResponse.
func (_ *DeleteArtifactResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteArtifactResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_DeleteArtifactResponse(ctx, r, path)
}

func validate_required_Object_DeleteArtifactResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ListArtifactRequest function validates a JSON for a given object.
func validate_Object_ListArtifactRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListArtifactRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ListArtifactRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "filter":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Filtering{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "order_by":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Sorting{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.FieldSelection{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "paging":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Pagination{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ListArtifactRequest.
func (_ *ListArtifactRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListArtifactRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ListArtifactRequest(ctx, r, path)
}

func validate_required_Object_ListArtifactRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ListArtifactsResponse function validates a JSON for a given object.
func validate_Object_ListArtifactsResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListArtifactsResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ListArtifactsResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "results":
			if v[k] == nil {
				continue
			}
			var vArr []json.RawMessage
			vArrPath := runtime1.JoinPath(path, k)
			if err = json.Unmarshal(v[k], &vArr); err != nil {
				return fmt.Errorf("invalid value for %q: expected array.", vArrPath)
			}
			for i, vv := range vArr {
				vvPath := fmt.Sprintf("%s.[%d]", vArrPath, i)
				if err = validate_Object_Artifact(ctx, vv, vvPath); err != nil {
					return err
				}
			}
		case "page":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.PageInfo{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ListArtifactsResponse.
func (_ *ListArtifactsResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListArtifactsResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ListArtifactsResponse(ctx, r, path)
}

func validate_required_Object_ListArtifactsResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_AwsService function validates a JSON for a given object.
func validate_Object_AwsService(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&AwsService{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_AwsService(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "name":
		case "description":
		case "aws_rds_instances":
			if v[k] == nil {
				continue
			}
			var vArr []json.RawMessage
			vArrPath := runtime1.JoinPath(path, k)
			if err = json.Unmarshal(v[k], &vArr); err != nil {
				return fmt.Errorf("invalid value for %q: expected array.", vArrPath)
			}
			for i, vv := range vArr {
				vvPath := fmt.Sprintf("%s.[%d]", vArrPath, i)
				if err = validate_Object_AwsRdsInstance(ctx, vv, vvPath); err != nil {
					return err
				}
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object AwsService.
func (_ *AwsService) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&AwsService{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_AwsService(ctx, r, path)
}

func validate_required_Object_AwsService(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_CreateAwsServiceRequest function validates a JSON for a given object.
func validate_Object_CreateAwsServiceRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateAwsServiceRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_CreateAwsServiceRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "payload":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_AwsService(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object CreateAwsServiceRequest.
func (_ *CreateAwsServiceRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateAwsServiceRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_CreateAwsServiceRequest(ctx, r, path)
}

func validate_required_Object_CreateAwsServiceRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_CreateAwsServiceResponse function validates a JSON for a given object.
func validate_Object_CreateAwsServiceResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateAwsServiceResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_CreateAwsServiceResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_AwsService(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object CreateAwsServiceResponse.
func (_ *CreateAwsServiceResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateAwsServiceResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_CreateAwsServiceResponse(ctx, r, path)
}

func validate_required_Object_CreateAwsServiceResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ReadAwsServiceRequest function validates a JSON for a given object.
func validate_Object_ReadAwsServiceRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadAwsServiceRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ReadAwsServiceRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.FieldSelection{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ReadAwsServiceRequest.
func (_ *ReadAwsServiceRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadAwsServiceRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ReadAwsServiceRequest(ctx, r, path)
}

func validate_required_Object_ReadAwsServiceRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ReadAwsServiceResponse function validates a JSON for a given object.
func validate_Object_ReadAwsServiceResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadAwsServiceResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ReadAwsServiceResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_AwsService(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ReadAwsServiceResponse.
func (_ *ReadAwsServiceResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadAwsServiceResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ReadAwsServiceResponse(ctx, r, path)
}

func validate_required_Object_ReadAwsServiceResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_UpdateAwsServiceRequest function validates a JSON for a given object.
func validate_Object_UpdateAwsServiceRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateAwsServiceRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_UpdateAwsServiceRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "payload":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_AwsService(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&field_mask.FieldMask{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object UpdateAwsServiceRequest.
func (_ *UpdateAwsServiceRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateAwsServiceRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_UpdateAwsServiceRequest(ctx, r, path)
}

func validate_required_Object_UpdateAwsServiceRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_UpdateAwsServiceResponse function validates a JSON for a given object.
func validate_Object_UpdateAwsServiceResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateAwsServiceResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_UpdateAwsServiceResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_AwsService(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object UpdateAwsServiceResponse.
func (_ *UpdateAwsServiceResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateAwsServiceResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_UpdateAwsServiceResponse(ctx, r, path)
}

func validate_required_Object_UpdateAwsServiceResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_DeleteAwsServiceRequest function validates a JSON for a given object.
func validate_Object_DeleteAwsServiceRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteAwsServiceRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_DeleteAwsServiceRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object DeleteAwsServiceRequest.
func (_ *DeleteAwsServiceRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteAwsServiceRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_DeleteAwsServiceRequest(ctx, r, path)
}

func validate_required_Object_DeleteAwsServiceRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_DeleteAwsServiceResponse function validates a JSON for a given object.
func validate_Object_DeleteAwsServiceResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteAwsServiceResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_DeleteAwsServiceResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object DeleteAwsServiceResponse.
func (_ *DeleteAwsServiceResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteAwsServiceResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_DeleteAwsServiceResponse(ctx, r, path)
}

func validate_required_Object_DeleteAwsServiceResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ListAwsServiceRequest function validates a JSON for a given object.
func validate_Object_ListAwsServiceRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListAwsServiceRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ListAwsServiceRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "filter":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Filtering{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "order_by":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Sorting{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.FieldSelection{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "paging":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Pagination{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ListAwsServiceRequest.
func (_ *ListAwsServiceRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListAwsServiceRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ListAwsServiceRequest(ctx, r, path)
}

func validate_required_Object_ListAwsServiceRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ListAwsServicesResponse function validates a JSON for a given object.
func validate_Object_ListAwsServicesResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListAwsServicesResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ListAwsServicesResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "results":
			if v[k] == nil {
				continue
			}
			var vArr []json.RawMessage
			vArrPath := runtime1.JoinPath(path, k)
			if err = json.Unmarshal(v[k], &vArr); err != nil {
				return fmt.Errorf("invalid value for %q: expected array.", vArrPath)
			}
			for i, vv := range vArr {
				vvPath := fmt.Sprintf("%s.[%d]", vArrPath, i)
				if err = validate_Object_AwsService(ctx, vv, vvPath); err != nil {
					return err
				}
			}
		case "page":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.PageInfo{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ListAwsServicesResponse.
func (_ *ListAwsServicesResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListAwsServicesResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ListAwsServicesResponse(ctx, r, path)
}

func validate_required_Object_ListAwsServicesResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_Deployment function validates a JSON for a given object.
func validate_Object_Deployment(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&Deployment{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_Deployment(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "name":
		case "description":
		case "artifact":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Artifact(ctx, vv, vvPath); err != nil {
				return err
			}
		case "artifact_id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "kube_cluster":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_KubeCluster(ctx, vv, vvPath); err != nil {
				return err
			}
		case "kube_cluster_id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "application_instance_id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object Deployment.
func (_ *Deployment) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&Deployment{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_Deployment(ctx, r, path)
}

func validate_required_Object_Deployment(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_CreateDeploymentRequest function validates a JSON for a given object.
func validate_Object_CreateDeploymentRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateDeploymentRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_CreateDeploymentRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "payload":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Deployment(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object CreateDeploymentRequest.
func (_ *CreateDeploymentRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateDeploymentRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_CreateDeploymentRequest(ctx, r, path)
}

func validate_required_Object_CreateDeploymentRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_CreateDeploymentResponse function validates a JSON for a given object.
func validate_Object_CreateDeploymentResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateDeploymentResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_CreateDeploymentResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Deployment(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object CreateDeploymentResponse.
func (_ *CreateDeploymentResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateDeploymentResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_CreateDeploymentResponse(ctx, r, path)
}

func validate_required_Object_CreateDeploymentResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ReadDeploymentRequest function validates a JSON for a given object.
func validate_Object_ReadDeploymentRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadDeploymentRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ReadDeploymentRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.FieldSelection{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ReadDeploymentRequest.
func (_ *ReadDeploymentRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadDeploymentRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ReadDeploymentRequest(ctx, r, path)
}

func validate_required_Object_ReadDeploymentRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ReadDeploymentResponse function validates a JSON for a given object.
func validate_Object_ReadDeploymentResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadDeploymentResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ReadDeploymentResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Deployment(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ReadDeploymentResponse.
func (_ *ReadDeploymentResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadDeploymentResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ReadDeploymentResponse(ctx, r, path)
}

func validate_required_Object_ReadDeploymentResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_UpdateDeploymentRequest function validates a JSON for a given object.
func validate_Object_UpdateDeploymentRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateDeploymentRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_UpdateDeploymentRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "payload":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Deployment(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&field_mask.FieldMask{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object UpdateDeploymentRequest.
func (_ *UpdateDeploymentRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateDeploymentRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_UpdateDeploymentRequest(ctx, r, path)
}

func validate_required_Object_UpdateDeploymentRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_UpdateDeploymentResponse function validates a JSON for a given object.
func validate_Object_UpdateDeploymentResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateDeploymentResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_UpdateDeploymentResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Deployment(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object UpdateDeploymentResponse.
func (_ *UpdateDeploymentResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateDeploymentResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_UpdateDeploymentResponse(ctx, r, path)
}

func validate_required_Object_UpdateDeploymentResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_DeleteDeploymentRequest function validates a JSON for a given object.
func validate_Object_DeleteDeploymentRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteDeploymentRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_DeleteDeploymentRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object DeleteDeploymentRequest.
func (_ *DeleteDeploymentRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteDeploymentRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_DeleteDeploymentRequest(ctx, r, path)
}

func validate_required_Object_DeleteDeploymentRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_DeleteDeploymentResponse function validates a JSON for a given object.
func validate_Object_DeleteDeploymentResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteDeploymentResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_DeleteDeploymentResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object DeleteDeploymentResponse.
func (_ *DeleteDeploymentResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteDeploymentResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_DeleteDeploymentResponse(ctx, r, path)
}

func validate_required_Object_DeleteDeploymentResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ListDeploymentRequest function validates a JSON for a given object.
func validate_Object_ListDeploymentRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListDeploymentRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ListDeploymentRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "filter":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Filtering{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "order_by":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Sorting{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.FieldSelection{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "paging":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Pagination{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ListDeploymentRequest.
func (_ *ListDeploymentRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListDeploymentRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ListDeploymentRequest(ctx, r, path)
}

func validate_required_Object_ListDeploymentRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ListDeploymentsResponse function validates a JSON for a given object.
func validate_Object_ListDeploymentsResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListDeploymentsResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ListDeploymentsResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "results":
			if v[k] == nil {
				continue
			}
			var vArr []json.RawMessage
			vArrPath := runtime1.JoinPath(path, k)
			if err = json.Unmarshal(v[k], &vArr); err != nil {
				return fmt.Errorf("invalid value for %q: expected array.", vArrPath)
			}
			for i, vv := range vArr {
				vvPath := fmt.Sprintf("%s.[%d]", vArrPath, i)
				if err = validate_Object_Deployment(ctx, vv, vvPath); err != nil {
					return err
				}
			}
		case "page":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.PageInfo{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ListDeploymentsResponse.
func (_ *ListDeploymentsResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListDeploymentsResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ListDeploymentsResponse(ctx, r, path)
}

func validate_required_Object_ListDeploymentsResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_KubeCluster function validates a JSON for a given object.
func validate_Object_KubeCluster(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&KubeCluster{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_KubeCluster(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "name":
		case "description":
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object KubeCluster.
func (_ *KubeCluster) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&KubeCluster{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_KubeCluster(ctx, r, path)
}

func validate_required_Object_KubeCluster(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_CreateKubeClusterRequest function validates a JSON for a given object.
func validate_Object_CreateKubeClusterRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateKubeClusterRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_CreateKubeClusterRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "payload":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_KubeCluster(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object CreateKubeClusterRequest.
func (_ *CreateKubeClusterRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateKubeClusterRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_CreateKubeClusterRequest(ctx, r, path)
}

func validate_required_Object_CreateKubeClusterRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_CreateKubeClusterResponse function validates a JSON for a given object.
func validate_Object_CreateKubeClusterResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateKubeClusterResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_CreateKubeClusterResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_KubeCluster(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object CreateKubeClusterResponse.
func (_ *CreateKubeClusterResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateKubeClusterResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_CreateKubeClusterResponse(ctx, r, path)
}

func validate_required_Object_CreateKubeClusterResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ReadKubeClusterRequest function validates a JSON for a given object.
func validate_Object_ReadKubeClusterRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadKubeClusterRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ReadKubeClusterRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.FieldSelection{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ReadKubeClusterRequest.
func (_ *ReadKubeClusterRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadKubeClusterRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ReadKubeClusterRequest(ctx, r, path)
}

func validate_required_Object_ReadKubeClusterRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ReadKubeClusterResponse function validates a JSON for a given object.
func validate_Object_ReadKubeClusterResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadKubeClusterResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ReadKubeClusterResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_KubeCluster(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ReadKubeClusterResponse.
func (_ *ReadKubeClusterResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadKubeClusterResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ReadKubeClusterResponse(ctx, r, path)
}

func validate_required_Object_ReadKubeClusterResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_UpdateKubeClusterRequest function validates a JSON for a given object.
func validate_Object_UpdateKubeClusterRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateKubeClusterRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_UpdateKubeClusterRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "payload":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_KubeCluster(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&field_mask.FieldMask{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object UpdateKubeClusterRequest.
func (_ *UpdateKubeClusterRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateKubeClusterRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_UpdateKubeClusterRequest(ctx, r, path)
}

func validate_required_Object_UpdateKubeClusterRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_UpdateKubeClusterResponse function validates a JSON for a given object.
func validate_Object_UpdateKubeClusterResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateKubeClusterResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_UpdateKubeClusterResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_KubeCluster(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object UpdateKubeClusterResponse.
func (_ *UpdateKubeClusterResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateKubeClusterResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_UpdateKubeClusterResponse(ctx, r, path)
}

func validate_required_Object_UpdateKubeClusterResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_DeleteKubeClusterRequest function validates a JSON for a given object.
func validate_Object_DeleteKubeClusterRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteKubeClusterRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_DeleteKubeClusterRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object DeleteKubeClusterRequest.
func (_ *DeleteKubeClusterRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteKubeClusterRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_DeleteKubeClusterRequest(ctx, r, path)
}

func validate_required_Object_DeleteKubeClusterRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_DeleteKubeClusterResponse function validates a JSON for a given object.
func validate_Object_DeleteKubeClusterResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteKubeClusterResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_DeleteKubeClusterResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object DeleteKubeClusterResponse.
func (_ *DeleteKubeClusterResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteKubeClusterResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_DeleteKubeClusterResponse(ctx, r, path)
}

func validate_required_Object_DeleteKubeClusterResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ListKubeClusterRequest function validates a JSON for a given object.
func validate_Object_ListKubeClusterRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListKubeClusterRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ListKubeClusterRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "filter":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Filtering{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "order_by":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Sorting{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.FieldSelection{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "paging":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Pagination{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ListKubeClusterRequest.
func (_ *ListKubeClusterRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListKubeClusterRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ListKubeClusterRequest(ctx, r, path)
}

func validate_required_Object_ListKubeClusterRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ListKubeClustersResponse function validates a JSON for a given object.
func validate_Object_ListKubeClustersResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListKubeClustersResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ListKubeClustersResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "results":
			if v[k] == nil {
				continue
			}
			var vArr []json.RawMessage
			vArrPath := runtime1.JoinPath(path, k)
			if err = json.Unmarshal(v[k], &vArr); err != nil {
				return fmt.Errorf("invalid value for %q: expected array.", vArrPath)
			}
			for i, vv := range vArr {
				vvPath := fmt.Sprintf("%s.[%d]", vArrPath, i)
				if err = validate_Object_KubeCluster(ctx, vv, vvPath); err != nil {
					return err
				}
			}
		case "page":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.PageInfo{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ListKubeClustersResponse.
func (_ *ListKubeClustersResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListKubeClustersResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ListKubeClustersResponse(ctx, r, path)
}

func validate_required_Object_ListKubeClustersResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_CloudProvider function validates a JSON for a given object.
func validate_Object_CloudProvider(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CloudProvider{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_CloudProvider(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "name":
		case "description":
		case "provider":
		case "account":
		case "regions":
			if v[k] == nil {
				continue
			}
			var vArr []json.RawMessage
			vArrPath := runtime1.JoinPath(path, k)
			if err = json.Unmarshal(v[k], &vArr); err != nil {
				return fmt.Errorf("invalid value for %q: expected array.", vArrPath)
			}
			for i, vv := range vArr {
				vvPath := fmt.Sprintf("%s.[%d]", vArrPath, i)
				if err = validate_Object_Region(ctx, vv, vvPath); err != nil {
					return err
				}
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object CloudProvider.
func (_ *CloudProvider) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CloudProvider{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_CloudProvider(ctx, r, path)
}

func validate_required_Object_CloudProvider(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_CreateCloudProviderRequest function validates a JSON for a given object.
func validate_Object_CreateCloudProviderRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateCloudProviderRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_CreateCloudProviderRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "payload":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_CloudProvider(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object CreateCloudProviderRequest.
func (_ *CreateCloudProviderRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateCloudProviderRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_CreateCloudProviderRequest(ctx, r, path)
}

func validate_required_Object_CreateCloudProviderRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_CreateCloudProviderResponse function validates a JSON for a given object.
func validate_Object_CreateCloudProviderResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateCloudProviderResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_CreateCloudProviderResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_CloudProvider(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object CreateCloudProviderResponse.
func (_ *CreateCloudProviderResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateCloudProviderResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_CreateCloudProviderResponse(ctx, r, path)
}

func validate_required_Object_CreateCloudProviderResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ReadCloudProviderRequest function validates a JSON for a given object.
func validate_Object_ReadCloudProviderRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadCloudProviderRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ReadCloudProviderRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.FieldSelection{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ReadCloudProviderRequest.
func (_ *ReadCloudProviderRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadCloudProviderRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ReadCloudProviderRequest(ctx, r, path)
}

func validate_required_Object_ReadCloudProviderRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ReadCloudProviderResponse function validates a JSON for a given object.
func validate_Object_ReadCloudProviderResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadCloudProviderResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ReadCloudProviderResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_CloudProvider(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ReadCloudProviderResponse.
func (_ *ReadCloudProviderResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadCloudProviderResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ReadCloudProviderResponse(ctx, r, path)
}

func validate_required_Object_ReadCloudProviderResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_UpdateCloudProviderRequest function validates a JSON for a given object.
func validate_Object_UpdateCloudProviderRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateCloudProviderRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_UpdateCloudProviderRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "payload":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_CloudProvider(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&field_mask.FieldMask{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object UpdateCloudProviderRequest.
func (_ *UpdateCloudProviderRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateCloudProviderRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_UpdateCloudProviderRequest(ctx, r, path)
}

func validate_required_Object_UpdateCloudProviderRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_UpdateCloudProviderResponse function validates a JSON for a given object.
func validate_Object_UpdateCloudProviderResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateCloudProviderResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_UpdateCloudProviderResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_CloudProvider(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object UpdateCloudProviderResponse.
func (_ *UpdateCloudProviderResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateCloudProviderResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_UpdateCloudProviderResponse(ctx, r, path)
}

func validate_required_Object_UpdateCloudProviderResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_DeleteCloudProviderRequest function validates a JSON for a given object.
func validate_Object_DeleteCloudProviderRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteCloudProviderRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_DeleteCloudProviderRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object DeleteCloudProviderRequest.
func (_ *DeleteCloudProviderRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteCloudProviderRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_DeleteCloudProviderRequest(ctx, r, path)
}

func validate_required_Object_DeleteCloudProviderRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_DeleteCloudProviderResponse function validates a JSON for a given object.
func validate_Object_DeleteCloudProviderResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteCloudProviderResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_DeleteCloudProviderResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object DeleteCloudProviderResponse.
func (_ *DeleteCloudProviderResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteCloudProviderResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_DeleteCloudProviderResponse(ctx, r, path)
}

func validate_required_Object_DeleteCloudProviderResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ListCloudProviderRequest function validates a JSON for a given object.
func validate_Object_ListCloudProviderRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListCloudProviderRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ListCloudProviderRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "filter":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Filtering{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "order_by":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Sorting{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.FieldSelection{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "paging":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Pagination{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ListCloudProviderRequest.
func (_ *ListCloudProviderRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListCloudProviderRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ListCloudProviderRequest(ctx, r, path)
}

func validate_required_Object_ListCloudProviderRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ListCloudProvidersResponse function validates a JSON for a given object.
func validate_Object_ListCloudProvidersResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListCloudProvidersResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ListCloudProvidersResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "results":
			if v[k] == nil {
				continue
			}
			var vArr []json.RawMessage
			vArrPath := runtime1.JoinPath(path, k)
			if err = json.Unmarshal(v[k], &vArr); err != nil {
				return fmt.Errorf("invalid value for %q: expected array.", vArrPath)
			}
			for i, vv := range vArr {
				vvPath := fmt.Sprintf("%s.[%d]", vArrPath, i)
				if err = validate_Object_CloudProvider(ctx, vv, vvPath); err != nil {
					return err
				}
			}
		case "page":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.PageInfo{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ListCloudProvidersResponse.
func (_ *ListCloudProvidersResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListCloudProvidersResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ListCloudProvidersResponse(ctx, r, path)
}

func validate_required_Object_ListCloudProvidersResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_Region function validates a JSON for a given object.
func validate_Object_Region(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&Region{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_Region(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "name":
		case "description":
		case "environments":
			if v[k] == nil {
				continue
			}
			var vArr []json.RawMessage
			vArrPath := runtime1.JoinPath(path, k)
			if err = json.Unmarshal(v[k], &vArr); err != nil {
				return fmt.Errorf("invalid value for %q: expected array.", vArrPath)
			}
			for i, vv := range vArr {
				vvPath := fmt.Sprintf("%s.[%d]", vArrPath, i)
				if err = validate_Object_Environment(ctx, vv, vvPath); err != nil {
					return err
				}
			}
		case "cloud_provider_id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object Region.
func (_ *Region) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&Region{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_Region(ctx, r, path)
}

func validate_required_Object_Region(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_CreateRegionRequest function validates a JSON for a given object.
func validate_Object_CreateRegionRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateRegionRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_CreateRegionRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "payload":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Region(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object CreateRegionRequest.
func (_ *CreateRegionRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateRegionRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_CreateRegionRequest(ctx, r, path)
}

func validate_required_Object_CreateRegionRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_CreateRegionResponse function validates a JSON for a given object.
func validate_Object_CreateRegionResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateRegionResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_CreateRegionResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Region(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object CreateRegionResponse.
func (_ *CreateRegionResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateRegionResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_CreateRegionResponse(ctx, r, path)
}

func validate_required_Object_CreateRegionResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ReadRegionRequest function validates a JSON for a given object.
func validate_Object_ReadRegionRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadRegionRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ReadRegionRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.FieldSelection{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ReadRegionRequest.
func (_ *ReadRegionRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadRegionRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ReadRegionRequest(ctx, r, path)
}

func validate_required_Object_ReadRegionRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ReadRegionResponse function validates a JSON for a given object.
func validate_Object_ReadRegionResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadRegionResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ReadRegionResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Region(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ReadRegionResponse.
func (_ *ReadRegionResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadRegionResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ReadRegionResponse(ctx, r, path)
}

func validate_required_Object_ReadRegionResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_UpdateRegionRequest function validates a JSON for a given object.
func validate_Object_UpdateRegionRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateRegionRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_UpdateRegionRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "payload":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Region(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&field_mask.FieldMask{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object UpdateRegionRequest.
func (_ *UpdateRegionRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateRegionRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_UpdateRegionRequest(ctx, r, path)
}

func validate_required_Object_UpdateRegionRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_UpdateRegionResponse function validates a JSON for a given object.
func validate_Object_UpdateRegionResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateRegionResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_UpdateRegionResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Region(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object UpdateRegionResponse.
func (_ *UpdateRegionResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateRegionResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_UpdateRegionResponse(ctx, r, path)
}

func validate_required_Object_UpdateRegionResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_DeleteRegionRequest function validates a JSON for a given object.
func validate_Object_DeleteRegionRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteRegionRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_DeleteRegionRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object DeleteRegionRequest.
func (_ *DeleteRegionRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteRegionRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_DeleteRegionRequest(ctx, r, path)
}

func validate_required_Object_DeleteRegionRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_DeleteRegionResponse function validates a JSON for a given object.
func validate_Object_DeleteRegionResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteRegionResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_DeleteRegionResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object DeleteRegionResponse.
func (_ *DeleteRegionResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteRegionResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_DeleteRegionResponse(ctx, r, path)
}

func validate_required_Object_DeleteRegionResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ListRegionRequest function validates a JSON for a given object.
func validate_Object_ListRegionRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListRegionRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ListRegionRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "filter":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Filtering{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "order_by":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Sorting{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.FieldSelection{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "paging":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Pagination{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ListRegionRequest.
func (_ *ListRegionRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListRegionRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ListRegionRequest(ctx, r, path)
}

func validate_required_Object_ListRegionRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ListRegionsResponse function validates a JSON for a given object.
func validate_Object_ListRegionsResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListRegionsResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ListRegionsResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "results":
			if v[k] == nil {
				continue
			}
			var vArr []json.RawMessage
			vArrPath := runtime1.JoinPath(path, k)
			if err = json.Unmarshal(v[k], &vArr); err != nil {
				return fmt.Errorf("invalid value for %q: expected array.", vArrPath)
			}
			for i, vv := range vArr {
				vvPath := fmt.Sprintf("%s.[%d]", vArrPath, i)
				if err = validate_Object_Region(ctx, vv, vvPath); err != nil {
					return err
				}
			}
		case "page":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.PageInfo{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ListRegionsResponse.
func (_ *ListRegionsResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListRegionsResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ListRegionsResponse(ctx, r, path)
}

func validate_required_Object_ListRegionsResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

var validate_Patterns = []struct {
	pattern    runtime.Pattern
	httpMethod string
	validator  func(context.Context, json.RawMessage) error
	// Included for introspection purpose.
	allowUnknown bool
}{
	// patterns for file github.com/seizadi/cmdb/pkg/pb/cmdb.proto
	{
		pattern:      pattern_Cmdb_GetVersion_0,
		httpMethod:   "GET",
		validator:    validate_Cmdb_GetVersion_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Vaults_Create_0,
		httpMethod:   "POST",
		validator:    validate_Vaults_Create_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Vaults_Read_0,
		httpMethod:   "GET",
		validator:    validate_Vaults_Read_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Vaults_Update_0,
		httpMethod:   "PUT",
		validator:    validate_Vaults_Update_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Vaults_Update_1,
		httpMethod:   "PATCH",
		validator:    validate_Vaults_Update_1,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Vaults_Delete_0,
		httpMethod:   "DELETE",
		validator:    validate_Vaults_Delete_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Vaults_List_0,
		httpMethod:   "GET",
		validator:    validate_Vaults_List_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_VersionTags_Create_0,
		httpMethod:   "POST",
		validator:    validate_VersionTags_Create_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_VersionTags_Read_0,
		httpMethod:   "GET",
		validator:    validate_VersionTags_Read_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_VersionTags_Update_0,
		httpMethod:   "PUT",
		validator:    validate_VersionTags_Update_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_VersionTags_Update_1,
		httpMethod:   "PATCH",
		validator:    validate_VersionTags_Update_1,
		allowUnknown: false,
	},
	{
		pattern:      pattern_VersionTags_Delete_0,
		httpMethod:   "DELETE",
		validator:    validate_VersionTags_Delete_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_VersionTags_List_0,
		httpMethod:   "GET",
		validator:    validate_VersionTags_List_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_ApplicationInstances_Create_0,
		httpMethod:   "POST",
		validator:    validate_ApplicationInstances_Create_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_ApplicationInstances_Read_0,
		httpMethod:   "GET",
		validator:    validate_ApplicationInstances_Read_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_ApplicationInstances_Update_0,
		httpMethod:   "PUT",
		validator:    validate_ApplicationInstances_Update_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_ApplicationInstances_Update_1,
		httpMethod:   "PATCH",
		validator:    validate_ApplicationInstances_Update_1,
		allowUnknown: false,
	},
	{
		pattern:      pattern_ApplicationInstances_Delete_0,
		httpMethod:   "DELETE",
		validator:    validate_ApplicationInstances_Delete_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_ApplicationInstances_List_0,
		httpMethod:   "GET",
		validator:    validate_ApplicationInstances_List_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_AwsRdsInstances_Create_0,
		httpMethod:   "POST",
		validator:    validate_AwsRdsInstances_Create_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_AwsRdsInstances_Read_0,
		httpMethod:   "GET",
		validator:    validate_AwsRdsInstances_Read_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_AwsRdsInstances_Update_0,
		httpMethod:   "PUT",
		validator:    validate_AwsRdsInstances_Update_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_AwsRdsInstances_Update_1,
		httpMethod:   "PATCH",
		validator:    validate_AwsRdsInstances_Update_1,
		allowUnknown: false,
	},
	{
		pattern:      pattern_AwsRdsInstances_Delete_0,
		httpMethod:   "DELETE",
		validator:    validate_AwsRdsInstances_Delete_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_AwsRdsInstances_List_0,
		httpMethod:   "GET",
		validator:    validate_AwsRdsInstances_List_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Containers_Create_0,
		httpMethod:   "POST",
		validator:    validate_Containers_Create_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Containers_Read_0,
		httpMethod:   "GET",
		validator:    validate_Containers_Read_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Containers_Update_0,
		httpMethod:   "PUT",
		validator:    validate_Containers_Update_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Containers_Update_1,
		httpMethod:   "PATCH",
		validator:    validate_Containers_Update_1,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Containers_Delete_0,
		httpMethod:   "DELETE",
		validator:    validate_Containers_Delete_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Containers_List_0,
		httpMethod:   "GET",
		validator:    validate_Containers_List_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Environments_Create_0,
		httpMethod:   "POST",
		validator:    validate_Environments_Create_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Environments_Read_0,
		httpMethod:   "GET",
		validator:    validate_Environments_Read_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Environments_Update_0,
		httpMethod:   "PUT",
		validator:    validate_Environments_Update_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Environments_Update_1,
		httpMethod:   "PATCH",
		validator:    validate_Environments_Update_1,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Environments_Delete_0,
		httpMethod:   "DELETE",
		validator:    validate_Environments_Delete_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Environments_List_0,
		httpMethod:   "GET",
		validator:    validate_Environments_List_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Manifests_Create_0,
		httpMethod:   "POST",
		validator:    validate_Manifests_Create_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Manifests_Read_0,
		httpMethod:   "GET",
		validator:    validate_Manifests_Read_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Manifests_Update_0,
		httpMethod:   "PUT",
		validator:    validate_Manifests_Update_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Manifests_Update_1,
		httpMethod:   "PATCH",
		validator:    validate_Manifests_Update_1,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Manifests_Delete_0,
		httpMethod:   "DELETE",
		validator:    validate_Manifests_Delete_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Manifests_List_0,
		httpMethod:   "GET",
		validator:    validate_Manifests_List_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Secrets_Create_0,
		httpMethod:   "POST",
		validator:    validate_Secrets_Create_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Secrets_Read_0,
		httpMethod:   "GET",
		validator:    validate_Secrets_Read_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Secrets_Update_0,
		httpMethod:   "PUT",
		validator:    validate_Secrets_Update_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Secrets_Update_1,
		httpMethod:   "PATCH",
		validator:    validate_Secrets_Update_1,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Secrets_Delete_0,
		httpMethod:   "DELETE",
		validator:    validate_Secrets_Delete_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Secrets_List_0,
		httpMethod:   "GET",
		validator:    validate_Secrets_List_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Artifacts_Create_0,
		httpMethod:   "POST",
		validator:    validate_Artifacts_Create_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Artifacts_Read_0,
		httpMethod:   "GET",
		validator:    validate_Artifacts_Read_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Artifacts_Update_0,
		httpMethod:   "PUT",
		validator:    validate_Artifacts_Update_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Artifacts_Update_1,
		httpMethod:   "PATCH",
		validator:    validate_Artifacts_Update_1,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Artifacts_Delete_0,
		httpMethod:   "DELETE",
		validator:    validate_Artifacts_Delete_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Artifacts_List_0,
		httpMethod:   "GET",
		validator:    validate_Artifacts_List_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_AwsServices_Create_0,
		httpMethod:   "POST",
		validator:    validate_AwsServices_Create_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_AwsServices_Read_0,
		httpMethod:   "GET",
		validator:    validate_AwsServices_Read_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_AwsServices_Update_0,
		httpMethod:   "PUT",
		validator:    validate_AwsServices_Update_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_AwsServices_Update_1,
		httpMethod:   "PATCH",
		validator:    validate_AwsServices_Update_1,
		allowUnknown: false,
	},
	{
		pattern:      pattern_AwsServices_Delete_0,
		httpMethod:   "DELETE",
		validator:    validate_AwsServices_Delete_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_AwsServices_List_0,
		httpMethod:   "GET",
		validator:    validate_AwsServices_List_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Deployments_Create_0,
		httpMethod:   "POST",
		validator:    validate_Deployments_Create_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Deployments_Read_0,
		httpMethod:   "GET",
		validator:    validate_Deployments_Read_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Deployments_Update_0,
		httpMethod:   "PUT",
		validator:    validate_Deployments_Update_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Deployments_Update_1,
		httpMethod:   "PATCH",
		validator:    validate_Deployments_Update_1,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Deployments_Delete_0,
		httpMethod:   "DELETE",
		validator:    validate_Deployments_Delete_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Deployments_List_0,
		httpMethod:   "GET",
		validator:    validate_Deployments_List_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_KubeClusters_Create_0,
		httpMethod:   "POST",
		validator:    validate_KubeClusters_Create_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_KubeClusters_Read_0,
		httpMethod:   "GET",
		validator:    validate_KubeClusters_Read_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_KubeClusters_Update_0,
		httpMethod:   "PUT",
		validator:    validate_KubeClusters_Update_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_KubeClusters_Update_1,
		httpMethod:   "PATCH",
		validator:    validate_KubeClusters_Update_1,
		allowUnknown: false,
	},
	{
		pattern:      pattern_KubeClusters_Delete_0,
		httpMethod:   "DELETE",
		validator:    validate_KubeClusters_Delete_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_KubeClusters_List_0,
		httpMethod:   "GET",
		validator:    validate_KubeClusters_List_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_CloudProviders_Create_0,
		httpMethod:   "POST",
		validator:    validate_CloudProviders_Create_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_CloudProviders_Read_0,
		httpMethod:   "GET",
		validator:    validate_CloudProviders_Read_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_CloudProviders_Update_0,
		httpMethod:   "PUT",
		validator:    validate_CloudProviders_Update_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_CloudProviders_Update_1,
		httpMethod:   "PATCH",
		validator:    validate_CloudProviders_Update_1,
		allowUnknown: false,
	},
	{
		pattern:      pattern_CloudProviders_Delete_0,
		httpMethod:   "DELETE",
		validator:    validate_CloudProviders_Delete_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_CloudProviders_List_0,
		httpMethod:   "GET",
		validator:    validate_CloudProviders_List_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Regions_Create_0,
		httpMethod:   "POST",
		validator:    validate_Regions_Create_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Regions_Read_0,
		httpMethod:   "GET",
		validator:    validate_Regions_Read_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Regions_Update_0,
		httpMethod:   "PUT",
		validator:    validate_Regions_Update_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Regions_Update_1,
		httpMethod:   "PATCH",
		validator:    validate_Regions_Update_1,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Regions_Delete_0,
		httpMethod:   "DELETE",
		validator:    validate_Regions_Delete_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Regions_List_0,
		httpMethod:   "GET",
		validator:    validate_Regions_List_0,
		allowUnknown: false,
	},
}

// AtlasValidateAnnotator parses JSON input and validates unknown fields
// based on 'allow_unknown_fields' options specified in proto file.
func AtlasValidateAnnotator(ctx context.Context, r *http.Request) metadata.MD {
	md := make(metadata.MD)
	for _, v := range validate_Patterns {
		if r.Method == v.httpMethod && runtime1.PatternMatch(v.pattern, r.URL.Path) {
			var b []byte
			var err error
			if b, err = ioutil.ReadAll(r.Body); err != nil {
				md.Set("Atlas-Validation-Error", "invalid value: unable to parse body")
				return md
			}
			r.Body = ioutil.NopCloser(bytes.NewReader(b))
			ctx := context.WithValue(context.WithValue(context.Background(), runtime1.HTTPMethodContextKey, r.Method), runtime1.AllowUnknownContextKey, v.allowUnknown)
			if err = v.validator(ctx, b); err != nil {
				md.Set("Atlas-Validation-Error", err.Error())
			}
			break
		}
	}
	return md
}
